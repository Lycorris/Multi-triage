<Issues>
  <Issue>
    <IssueID>3628</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>TestCase: An explicit test case makes all test cases explicit</Title>
    <CreatedDate>04/09/2020</CreatedDate>
    <ClosedDate>04/09/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:answered</Name>
        <IssueID>3628</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>3628</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>If you create a test method with a number of test cases and mark one of them as Explicit, all the test cases are skipped unless explicitly selected. It seems that marking a single test cases as explicit affects all the test cases.

This is not what I would expect from the documentation of [TestCase]( where it says:

"Explicit is set to true in order to make the individual test case Explicit. Use Reason to explain why."

I have attached a simple C#-project with an example and a screen dump of running the tests from this project in the console runner.
![TestCaseExplicit](
[TestCaseExplicit.zip](

NUnit: version 3.12
NUnit-Console: Version 3.11.1

</Description>
  </Issue>
  <Issue>
    <IssueID>3627</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>How to extract a list of tests cases and their categories programmatically.</Title>
    <CreatedDate>27/08/2020</CreatedDate>
    <ClosedDate>31/08/2020</ClosedDate>
    <IssueLabels />
    <Description>Hello Folks,

This is a question.

I am trying to get a list of all the test cases and their respective categories.

Currently I see three options:
1) Reflection: going through all methods, check for TestAttribute/TestCaseAttribute/TestFixture...

2) Using a runner, extract the xml with runner.Explore and parse the xml.

3) Use what NUnit is already doing.

My question revolves around the latter:
How to "flatten" the categories for each testcase? (when categories are put on abstract class or the whole class)
Ideally I would like to reuse what is already in use in NUnit to extract its test list.
Any suggestion as to where to start reading ?

Best regards,
Simon


</Description>
  </Issue>
  <Issue>
    <IssueID>3622</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>EmptyDirectoryConstraint doesn't need to enumerate entire directory contents</Title>
    <CreatedDate>17/08/2020</CreatedDate>
    <ClosedDate>25/08/2020</ClosedDate>
    <IssueLabels />
    <Description>`EmptyDirectoryConstraint` currently tries to read in and instantiate all content in a directory in order to determine if the directory is empty or not empty.



An alternative could be to use one call to `EnumerateFileSystemInfos().Any()` to detect existence of either files or subdirectories without instantiating a whole array of them. Unfortunately, this API isn't available in .NET 35, so some sort of fallback would be required to go this route. A fallback could be either the currently implementation, or using `GetFileSystemInfos().Any()`. Example:

``</Description>
  </Issue>
  <Issue>
    <IssueID>3618</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>3618</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>NUnit has a P/Invoke whose native function doesn't exist on all platforms</Title>
    <CreatedDate>11/08/2020</CreatedDate>
    <ClosedDate>12/08/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>3618</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>3618</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>
  Undefined symbols for architecture arm64:
    "_GetVersionEx", referenced from:
        wrapper_managed_to_native_NUnit_Framework_Internal_OSPlatform_GetVersionEx_NUnit_Framework_Internal_OSPlatform_OSVERSIONINFOEX_ in nunit.framework.dll.o
  ld: symbol(s) not found for architecture arm64

MTOUCH : error MT5210: Native linking failed, undefined symbol: _GetVersionEx. Please verify that all the necessary frameworks have been referenced and native libraries are properly linked in. [/Users/rolf/Projects/nunitlite-3.12.0/nunitlite-3.12.0.csproj]
`</Code>
    <Description>Repro project: [nunitlite-3.12.0-c582df3.zip](

To reproduce, download and extract, and then execute `msbuild /p:Platform=iPhone /r`

This results in a few errors:

``

[Full build log](

This is the P/Invoke in question: 

This is clearly a Windows-only P/Invoke, since `GetVersionEx` is a Windows-only function.

For Xamarin.iOS apps it's highly recommended to not have P/Invokes to functions that don't exist on the platform, because otherwise we have to apply a workaround that has a performance impact on the application.

Would it be possible to rework this code somehow so that the NUnit assemblies that are used for Xamarin.iOS (and tvOS/watchOS) don't have this P/Invoke?</Description>
    <PullRequests>
      <PullRequest>
        <RepoID>nunitWebScrap</RepoID>
        <IssueID>3618</IssueID>
        <PullRequestID>3610</PullRequestID>
        <Title>Guard uname against DllNotFoundException</Title>
        <Description>Resolves </Description>
        <CreatedDate>31/07/2020</CreatedDate>
        <ClosedDate>01/08/2020</ClosedDate>
        <PullRequestLabels>
          <PullRequestLabel>
            <Name>awaiting:review</Name>
            <IssueID>3618</IssueID>
            <PullRequestID>3610</PullRequestID>
            <RepoID>nunitWebScrap</RepoID>
          </PullRequestLabel>
        </PullRequestLabels>
        <PullRequestAssignees />
      </PullRequest>
    </PullRequests>
  </Issue>
  <Issue>
    <IssueID>3617</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Visual Studio - test didn't run when using TestCaseSource</Title>
    <CreatedDate>11/08/2020</CreatedDate>
    <ClosedDate>11/08/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>3617</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>When using the TestCaseSource, visual studio shows a not run test.

``

Output:

![image](
</Description>
  </Issue>
  <Issue>
    <IssueID>3615</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Listening to Socket in SetUp</Title>
    <CreatedDate>06/08/2020</CreatedDate>
    <ClosedDate>12/08/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:answered</Name>
        <IssueID>3615</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>3615</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Hi, I want to write Tests for my MasterServer. 
I have two testing methods, that don't do anything as of yet. 
I have a Setup-method with "SetUp"-attribute, in which I start the MasterServer =&gt; listening on a specific port. 
When I run the TestFixture, the second test always fails, because I am already listening on that port. 
I thought SetUp is for any logic, that is run before any test, but I didn't know that consecutive calls of my Setup-method will have impact on each other (variables already being initialized etc.). 
I can run every test in isolation without any problem and I thought that's what unit tests are all about, that's why I was surprised by this behaviour. Will implementing a TearDown-method, that stops listening on the socket (basically unitialize the MasterServer), help? Is this the right thing to do in terms of architecture or are there any alternatives?</Description>
  </Issue>
  <Issue>
    <IssueID>3614</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>enum == but not the same</Title>
    <CreatedDate>06/08/2020</CreatedDate>
    <ClosedDate>07/08/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>3614</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>nUnit 3.12.0

test a function like
``

As 'AreSame' check reference, why assert '==' pass but asser 'same' fails. 
Does C# 's enum value share the same instance, doesn't it ?
</Description>
  </Issue>
  <Issue>
    <IssueID>3613</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>SetUp/TearDown and C# 8 nullability</Title>
    <CreatedDate>03/08/2020</CreatedDate>
    <ClosedDate>12/08/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>3613</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>This issue is more of a question than a bug report.

Do you have a good strategy for C# 8 nullability annotations and tests? Unfortunately, even if we assign all fields in the SetUp method, it is not in a ctor and therefore the compiler thinks that all the fields are potentially null. We have to use the ! operator quite a lot to overcome the issue.

We don't want to ignore the warning either, because in the TearDown method it is actually possible that the fields are still null.

What's your take on this? Is there some feature missing from NUnit to overcome the problem in a "clean code" way?

Best regards,
D.R.</Description>
  </Issue>
  <Issue>
    <IssueID>3608</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>AlekseyMartynov</FixedById>
        <IssueID>3608</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>[Platform] attribute fails with DllNotFoundException in WASM</Title>
    <CreatedDate>29/07/2020</CreatedDate>
    <ClosedDate>01/08/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>3608</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>
Type: Failure 
Message: An exception was thrown while loading the test.
System.DllNotFoundException: libc assembly:&lt;unknown assembly&gt; type:&lt;unknown type&gt; member:(null)
 at (wrapper managed-to-native) NUnit.Framework.Internal.OSPlatform.uname(intptr)
 at NUnit.Framework.Internal.OSPlatform.CheckIfIsMacOSX (System.PlatformID platform) [0x0002b] in C:\projects\nunit\src\NUnitFramework\framework\Internal\OSPlatform.cs:367 
 at NUnit.Framework.Internal.OSPlatform+&lt;&gt;c.&lt;.cctor&gt;b__93_0 () [0x000a0] in C:\projects\nunit\src\NUnitFramework\framework\Internal\OSPlatform.cs:61 
 at System.Lazy`1[T].ViaFactory (System.Threading.LazyThreadSafetyMode mode) &lt;0x370a6a8 + 0x00034&gt; in &lt;filename unknown&gt;:0 
--- End of stack trace from previous location where exception was thrown ---

 at (wrapper managed-to-native) System.MonoCustomAttrs.GetCustomAttributesInternal(System.Reflection.ICustomAttributeProvider,System.Type,bool)
 at System.MonoCustomAttrs.GetCustomAttributesBase (System.Reflection.ICustomAttributeProvider obj, System.Type attributeType, System.Boolean inheritedOnly) &lt;0x31e5248 + 0x00036&gt; in &lt;filename unknown&gt;:0 
 at System.MonoCustomAttrs.GetCustomAttributes (System.Reflection.ICustomAttributeProvider obj, System.Boolean inherit) &lt;0x36bc730 + 0x00026&gt; in &lt;filename unknown&gt;:0 
 at System.Reflection.RuntimeMethodInfo.GetCustomAttributes (System.Boolean inherit) &lt;0x36bc6f8 + 0x00006&gt; in &lt;filename unknown&gt;:0 
 at NUnit.Framework.Internal.AsyncToSyncAdapter.IsAsyncOperation (System.Reflection.MethodInfo method) [0x00001] in C:\projects\nunit\src\NUnitFramework\framework\Internal\AsyncToSyncAdapter.cs:37 
 at NUnit.Framework.Internal.Builders.NUnitTestCaseBuilder.CheckTestMethodSignature (NUnit.Framework.Internal.TestMethod testMethod, NUnit.Framework.Internal.TestCaseParameters parms) [0x000f7] in C:\projects\nunit\src\NUnitFramework\framework\Internal\Builders\NUnitTestCaseBuilder.cs:183 
 at NUnit.Framework.Internal.Builders.NUnitTestCaseBuilder.BuildTestMethod (NUnit.Framework.Interfaces.IMethodInfo method, NUnit.Framework.Internal.Test parentSuite, NUnit.Framework.Internal.TestCaseParameters parms) [0x00022] in C:\projects\nunit\src\NUnitFramework\framework\Internal\Builders\NUnitTestCaseBuilder.cs:63 
 at NUnit.Framework.TestAttribute.BuildFrom (NUnit.Framework.Interfaces.IMethodInfo method, NUnit.Framework.Internal.Test suite) [0x00022] in C:\projects\nunit\src\NUnitFramework\framework\Attributes\TestAttribute.cs:132 
 at NUnit.Framework.Internal.Builders.DefaultTestCaseBuilder.BuildSingleTestMethod (NUnit.Framework.Interfaces.IMethodInfo method, NUnit.Framework.Internal.Test suite) [0x00009] in C:\projects\nunit\src\NUnitFramework\framework\Internal\Builders\DefaultTestCaseBuilder.cs:155 
 at NUnit.Framework.Internal.Builders.DefaultTestCaseBuilder.BuildFrom (NUnit.Framework.Interfaces.IMethodInfo method, NUnit.Framework.Internal.Test parentSuite) [0x000ec] in C:\projects\nunit\src\NUnitFramework\framework\Internal\Builders\DefaultTestCaseBuilder.cs:122 
 at NUnit.Framework.Internal.Builders.NUnitTestFixtureBuilder.BuildTestCase (NUnit.Framework.Interfaces.IMethodInfo method, NUnit.Framework.Internal.TestSuite suite) [0x00001] in C:\projects\nunit\src\NUnitFramework\framework\Internal\Builders\NUnitTestFixtureBuilder.cs:228 
 at NUnit.Framework.Internal.Builders.NUnitTestFixtureBuilder.AddTestCasesToFixture (NUnit.Framework.Internal.TestFixture fixture, NUnit.Framework.Interfaces.IPreFilter filter) [0x0005c] in C:\projects\nunit\src\NUnitFramework\framework\Internal\Builders\NUnitTestFixtureBuilder.cs:201 
 at NUnit.Framework.Internal.Builders.NUnitTestFixtureBuilder.BuildFrom (NUnit.Framework.Interfaces.ITypeInfo typeInfo, NUnit.Framework.Interfaces.IPreFilter filter, NUnit.Framework.Interfaces.ITestFixtureData testFixtureData) [0x002d7] in C:\projects\nunit\src\NUnitFramework\framework\Internal\Builders\NUnitTestFixtureBuilder.cs:173 
 at NUnit.Framework.TestFixtureAttribute+&lt;BuildFrom&gt;d__47.MoveNext () [0x00020] in C:\projects\nunit\src\NUnitFramework\framework\Attributes\TestFixtureAttribute.cs:269 
 at NUnit.Framework.Internal.Builders.DefaultSuiteBuilder.BuildFrom (NUnit.Framework.Interfaces.ITypeInfo typeInfo, NUnit.Framework.Interfaces.IPreFilter filter) [0x0005e] in C:\projects\nunit\src\NUnitFramework\framework\Internal\Builders\DefaultSuiteBuilder.cs:98  
`</Code>
    <Description>Version: `3.13.0-dev-06832`

Steps to reproduce: 
-  [BlazorApp1.zip](
- Load in VS 2019, run in Chrome
- Check browser developer console

``</Description>
  </Issue>
  <Issue>
    <IssueID>3605</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Assert that Directory does not exist?</Title>
    <CreatedDate>27/07/2020</CreatedDate>
    <ClosedDate>12/08/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>confirm</Name>
        <IssueID>3605</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>3605</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>What's the recommended way to do this?

``


For a long time I've used the first approach. But it suddenly fails with "Expected: false, Was: false"....
NUnit3: 3.12.0
NUnit3TestAdapter: 3.14.0
Visual Studio 2019 Pro 16.6.5
</Description>
  </Issue>
  <Issue>
    <IssueID>3601</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Nunit 3.10.1.0 + ReSharper 2020.1.4: Test execution delayed by ~60seconds </Title>
    <CreatedDate>22/07/2020</CreatedDate>
    <ClosedDate>29/07/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:norepro</Name>
        <IssueID>3601</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Hi,

first of all, I'm not sure whether NUnit or Resharper might be the problem. (But problems started after upgrading to latest resharper)

When I start the execution of a test via resharper test runner, the test shows pending for about 60 seconds before even starting the relevant test code. I tracked it down to be a loading/performance issue at **RuntimeFramework.cs** 
`Type monoTouchType = Type.GetType("MonoTouch.UIKit.UIApplicationDelegate,monotouch");`
The call to the above takes about 60 seconds and will then continue normal test execution.

Does anyone know what the problem might be or how I can track it further down?

What I did so far:

- Execution with MS Test and NUnitTestadapter: works fine

- setup a new Solution: no problem of test execution

- When at the above position in debugger -&gt; execute at immediate window (without the "**,monotouch**"):  `Type.GetType("MonoTouch.UIKit.UIApplicationDelegate");` --&gt; returns immediately

</Description>
    <PullRequests />
  </Issue>
  <Issue>
    <IssueID>3596</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>AreAlmostEqualUlps throws OverflowException for -0</Title>
    <CreatedDate>16/07/2020</CreatedDate>
    <ClosedDate>12/08/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>3596</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>
Assert.That(-0d, Is.EqualTo(0d).Within(1).Ulps);


Results in:


System.OverflowException : Negating the minimum value of a twos complement number is invalid.
   at NUnit.Framework.Constraints.FloatingPointNumerics.AreAlmostEqualUlps(Double left, Double right, Int64 maxUlps)
   at NUnit.Framework.Constraints.Numerics.AreEqual(Double expected, Double actual, Tolerance&amp; tolerance)
   at NUnit.Framework.Constraints.Numerics.AreEqual(Object expected, Object actual, Tolerance&amp; tolerance)
   at NUnit.Framework.Constraints.Comparers.NumericsComparer.Equal(Object x, Object y, Tolerance&amp; tolerance, Boolean topLevelComparison)
   at NUnit.Framework.Constraints.NUnitEqualityComparer.AreEqual(Object x, Object y, Tolerance&amp; tolerance, Boolean topLevelComparison)
   at NUnit.Framework.Constraints.EqualConstraint.ApplyTo[TActual](TActual actual)
   at NUnit.Framework.Assert.That[TActual](TActual actual, IResolveConstraint expression, String message, Object[] args)
   at NUnit.Framework.Assert.That[TActual](TActual actual, IResolveConstraint expression)
`</Code>
    <Description>Similar to #1046, the following assertion:

``

Tested against NUnit 3.12.0.</Description>
  </Issue>
  <Issue>
    <IssueID>3595</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>"Test host process crashed : Unhandled exception." when switching to async test methods</Title>
    <CreatedDate>16/07/2020</CreatedDate>
    <ClosedDate>16/07/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>3595</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>c#
public class TestClass : ApiTestFixture
{
    public ApiClient client;
    
    [SetUp]
    public void TestClassSetUp()
    {
        client = new ApiClient(/* Setup parameters */);
    }
 
    [Test]
    public void ApiTest()
    {
        var response = client.ExecuteRequest().Result;
        // Assert stuff about the response
    }
}

which worked fine, but then I read that NUnit 3 supports `async` test methods so I went through an updated a bunch of tests to look like the following:
c#
public class TestClass : ApiTestFixture
{
    public ApiClient client;
    
    [SetUp]
    public void TestClassSetUp()
    {
        client = new ApiClient(/* Setup parameters */);
    }
 
    [Test]
    public async Task ApiTest()
    {
        var response = await client.ExecuteRequest();
        // Assert stuff about the response
    }
}

At first this seemed fine; after updating a small batch of tests, I would run those tests to see that they still worked and then merge the changes. One thing to note is that `client.ExecuteRequest()` throws an exception when the API endpoint it's calling fails for some reason. In the synchronous version of the tests this would just result in a test failure with the exception message printed, but with the asynchronous version I am consistently getting the following when I try to run all of the tests at once:

The active test run was aborted. Reason: Test host process crashed : Unhandled exception. ApiException: api exception message
at ...
at ...
at ApiTests.TestClass.&lt;ApiTest&gt; in C:\src\ApiTests\TestClass.cs
at System.Threading.Tasks.Task.&lt;&gt;c.&lt;ThrowAsync&gt;b__139_1(Object state)
at System.Threading.QueueUserWorkItemCallback.&lt;&gt;c.&lt;.cctor&gt;b__6_0(QueueUserWorkItemCallback quwi)
at System.Threading.ExecutionContext.RunForThreadPoolUnsafe[TState](ExecutionContext executionContext, Action`1 callback, TState&amp; state)
at System.Threading.QueueUserWorkItemCallback.Execute()
at System.Threading.ThreadPoolWorkQueue.Dispatch()
`</Code>
    <Description>I have a suite of tests that make calls to an API. Previously the tests looked something like this:

``
With the `ApiException` being an exception that previously just caused a test failure. I'm not too knowledgable on the inner workings of threads, tasks, and how NUnit handles this stuff so I don't know if this is an issue with NUnit, my code, or something else. Any insight into this would be appreciated. I can provide more info if needed.

Other possibly relevant things:
 - the test assembly has parallelizable scope set to fixture
 - the `async` tests run fine in small batches, although this might be because exceptions are less likely to occur in smaller batches
- the number of tests that run before the process crashes has been anywhere from ~5 tests to almost the entire suite (~couple hundred), and in one instance the entire suite ran successfully (reporting exceptions as failures without crashing).
- This occurs whether I'm executing tests via the command line or in visual studio.

Versions:
 - .NET Core 3.1
 - Microsoft.NET.Test.Sdk 16.6.1
 - NUnit 3.12
 - NUnitTestAdapter 3.16.1</Description>
  </Issue>
  <Issue>
    <IssueID>3591</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Test runner doesn't link my custom property to the &lt;test-case&gt; but adds it to the &lt;test-suite&gt;</Title>
    <CreatedDate>08/07/2020</CreatedDate>
    <ClosedDate>14/07/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>3591</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Hi, 
I'm using NUnit 3 with SpecFlow 3. 
I'm adding a custom property called "ScenarioContent"
Here is an example
Scenario Outline: Calculator 23
  Given I have entered &lt;first&gt; into the calculator
  And I have also entered &lt;second&gt; into the calculator
  When I press add
  Then the result should be &lt;result&gt; on the screen
  
  Examples:
  | first | second | result |
  | 20    | 30     | 50     |
  | 85    | 15     | 100    |

While the code-behind the feature is generated correctly (which looks like this)

`[NUnit.Framework.DescriptionAttribute("Calculator 23")]
        [NUnit.Framework.TestCaseAttribute("20", "30", "50", null, TestName="Calculator 23_20_30_50")]
        [NUnit.Framework.Property("ScenarioContent", @"Scenario Title:
Calculator 23

Context:
In order to avoid silly mistakes
As a math idiot
I want to be told the sum of two numbers

Background:
Given I have few background services to be started

Steps:
Given I have entered 20 into the calculator
And I have also entered 30 into the calculator
When I press add
Then the result should be 50 on the screen


")]
        [NUnit.Framework.TestCaseAttribute("85", "15", "100", null, TestName="Calculator 23_85_15_100")]
        [NUnit.Framework.Property("ScenarioContent", @"Scenario Title:
Calculator 23

Context:
In order to avoid silly mistakes
As a math idiot
I want to be told the sum of two numbers

Background:
Given I have few background services to be started

Steps:
Given I have entered 85 into the calculator
And I have also entered 15 into the calculator
When I press add
Then the result should be 100 on the screen


")]
       `public virtual void Calculator23(string first, string second, string result, string[] exampleTags)
        {
            string[] tagsOfScenario = exampleTags;
            TechTalk.SpecFlow.ScenarioInfo scenarioInfo = new TechTalk.SpecFlow.ScenarioInfo("Calculator 23", null, exampleTags);
#line 386
this.ScenarioInitialize(scenarioInfo);
#line hidden
            bool isScenarioIgnored = default(bool);
            bool isFeatureIgnored = default(bool);
            if ((tagsOfScenario != null))
            {
                isScenarioIgnored = tagsOfScenario.Where(__entry =&gt; __entry != null).Where(__entry =&gt; String.Equals(__entry, "ignore", StringComparison.CurrentCultureIgnoreCase)).Any();
            }
            if ((this._featureTags != null))
            {
                isFeatureIgnored = this._featureTags.Where(__entry =&gt; __entry != null).Where(__entry =&gt; String.Equals(__entry, "ignore", StringComparison.CurrentCultureIgnoreCase)).Any();
            }
            if ((isScenarioIgnored || isFeatureIgnored))
            {
                testRunner.SkipScenario();
            }
            else
            {
                this.ScenarioStart();
#line 12
this.FeatureBackground();
#line hidden
#line 387
  testRunner.Given(string.Format("I have entered {0} into the calculator", first), ((string)(null)), ((TechTalk.SpecFlow.Table)(null)), "Given ");
#line hidden
#line 388
  testRunner.And(string.Format("I have also entered {0} into the calculator", second), ((string)(null)), ((TechTalk.SpecFlow.Table)(null)), "And ");
#line hidden
#line 389
  testRunner.When("I press add", ((string)(null)), ((TechTalk.SpecFlow.Table)(null)), "When ");
#line hidden
#line 390
  testRunner.Then(string.Format("the result should be {0} on the screen", result), ((string)(null)), ((TechTalk.SpecFlow.Table)(null)), "Then ");
#line hidden
            }
            this.ScenarioCleanup();
        }`

But the result file that is generated by the NUnit3 test runner looks this way. 

` &lt;test-suite type="ParameterizedMethod" id="0-1075" name="Calculator23" fullname="Com.Vanderlande.SFP.Tests.CalculatorFeature.Calculator23" classname="Com.Vanderlande.SFP.Tests.CalculatorFeature" runstate="Runnable" testcasecount="2" result="Passed" start-time="2020-07-08 08:09:03Z" end-time="2020-07-08 08:09:03Z" duration="0.005026" total="2" passed="2" failed="0" warnings="0" inconclusive="0" skipped="0" asserts="0"&gt;
                  &lt;properties&gt;
                    &lt;property name="Description" value="Calculator 23" /&gt;
                    &lt;property name="ScenarioContent" value="Scenario Title:&amp;#xD;&amp;#xA;Calculator 23&amp;#xD;&amp;#xA;&amp;#xD;&amp;#xA;Context:&amp;#xD;&amp;#xA;In order to avoid silly mistakes&amp;#xD;&amp;#xA;As a math idiot&amp;#xD;&amp;#xA;I want to be told the sum of two numbers&amp;#xD;&amp;#xA;&amp;#xD;&amp;#xA;Background:&amp;#xD;&amp;#xA;Given I have few background services to be started&amp;#xD;&amp;#xA;&amp;#xD;&amp;#xA;Steps:&amp;#xD;&amp;#xA;Given I have entered 20 into the calculator&amp;#xD;&amp;#xA;And I have also entered 30 into the calculator&amp;#xD;&amp;#xA;When I press add&amp;#xD;&amp;#xA;Then the result should be 50 on the screen&amp;#xD;&amp;#xA;&amp;#xD;&amp;#xA;&amp;#xD;&amp;#xA;" /&gt;
                    &lt;property name="ScenarioContent" value="Scenario Title:&amp;#xD;&amp;#xA;Calculator 23&amp;#xD;&amp;#xA;&amp;#xD;&amp;#xA;Context:&amp;#xD;&amp;#xA;In order to avoid silly mistakes&amp;#xD;&amp;#xA;As a math idiot&amp;#xD;&amp;#xA;I want to be told the sum of two numbers&amp;#xD;&amp;#xA;&amp;#xD;&amp;#xA;Background:&amp;#xD;&amp;#xA;Given I have few background services to be started&amp;#xD;&amp;#xA;&amp;#xD;&amp;#xA;Steps:&amp;#xD;&amp;#xA;Given I have entered 85 into the calculator&amp;#xD;&amp;#xA;And I have also entered 15 into the calculator&amp;#xD;&amp;#xA;When I press add&amp;#xD;&amp;#xA;Then the result should be 100 on the screen&amp;#xD;&amp;#xA;&amp;#xD;&amp;#xA;&amp;#xD;&amp;#xA;" /&gt;
                  &lt;/properties&gt;
                  &lt;test-case id="0-1073" name="Calculator 23_20_30_50" fullname="Com.Vanderlande.SFP.Tests.CalculatorFeature.Calculator 23_20_30_50" methodname="Calculator23" classname="Com.Vanderlande.SFP.Tests.CalculatorFeature" runstate="Runnable" seed="240080650" result="Passed" start-time="2020-07-08 08:09:03Z" end-time="2020-07-08 08:09:03Z" duration="0.002920" asserts="0"&gt;
                    &lt;reason&gt;
                      &lt;message&gt;&lt;![CDATA[A simple background step]]&gt;&lt;/message&gt;
                    &lt;/reason&gt;
                    &lt;output&gt;&lt;![CDATA[Given I have few background services to be started
-&gt; error: A simple background step
Given I have entered 20 into the calculator
-&gt; skipped because of previous errors
And I have also entered 30 into the calculator
-&gt; skipped because of previous errors
When I press add
-&gt; skipped because of previous errors
Then the result should be 50 on the screen
-&gt; skipped because of previous errors
]]&gt;&lt;/output&gt;
                  &lt;/test-case&gt;
                  &lt;test-case id="0-1074" name="Calculator 23_85_15_100" fullname="Com.Vanderlande.SFP.Tests.CalculatorFeature.Calculator 23_85_15_100" methodname="Calculator23" classname="Com.Vanderlande.SFP.Tests.CalculatorFeature" runstate="Runnable" seed="217858778" result="Passed" start-time="2020-07-08 08:09:03Z" end-time="2020-07-08 08:09:03Z" duration="0.001992" asserts="0"&gt;
                    &lt;reason&gt;
                      &lt;message&gt;&lt;![CDATA[A simple background step]]&gt;&lt;/message&gt;
                    &lt;/reason&gt;
                    &lt;output&gt;&lt;![CDATA[Given I have few background services to be started
-&gt; error: A simple background step
Given I have entered 85 into the calculator
-&gt; skipped because of previous errors
And I have also entered 15 into the calculator
-&gt; skipped because of previous errors
When I press add
-&gt; skipped because of previous errors
Then the result should be 100 on the screen
-&gt; skipped because of previous errors
]]&gt;&lt;/output&gt;
                  &lt;/test-case&gt;
                &lt;/test-suite&gt;
              &lt;/test-suite&gt;
              &lt;test-suite type="TestFixture" id="0-1076" name="KeywordRulesFeature" fullname="Com.Vanderlande.SFP.Tests.KeywordRulesFeature" classname="Com.Vanderlande.SFP.Tests.KeywordRulesFeature" runstate="Runnable" testcasecount="1" result="Passed" start-time="2020-07-08 08:09:03Z" end-time="2020-07-08 08:09:03Z" duration="0.042619" total="1" passed="1" failed="0" warnings="0" inconclusive="0" skipped="0" asserts="1"&gt;
                &lt;properties&gt;
                  &lt;property name="Description" value="KeywordRules" /&gt;
                  &lt;property name="qcTestPlanPath" value="TestPlan\in multiple" /&gt;
                  &lt;property name="qcTestLabPath" value="TestLab\in multiple\" /&gt;
                  &lt;property name="qcTestSet" value="KeywordRules" /&gt;
                &lt;/properties&gt;
                &lt;test-case id="0-1077" name="KeywordRules01" fullname="Com.Vanderlande.SFP.Tests.KeywordRulesFeature.KeywordRules01" methodname="KeywordRules01" classname="Com.Vanderlande.SFP.Tests.KeywordRulesFeature" runstate="Runnable" seed="595591960" result="Passed" start-time="2020-07-08 08:09:03Z" end-time="2020-07-08 08:09:03Z" duration="0.041864" asserts="1"&gt;
                  &lt;properties&gt;
                    &lt;property name="TestCaseName" value="FeatureFile Keyword Rules 01" /&gt;
                    &lt;property name="Description" value="KeywordRules 01" /&gt;
                    &lt;property name="ScenarioContent" value="Scenario Title:&amp;#xD;&amp;#xA;KeywordRules 01&amp;#xD;&amp;#xA;&amp;#xD;&amp;#xA;Context:&amp;#xD;&amp;#xA;A Feature file with no TestSet and Testplanpath and labpath in multiple lines&amp;#xD;&amp;#xA;&amp;#xD;&amp;#xA;Objective:&amp;#xD;&amp;#xA;To check if the single line keywords are truncated and&amp;#xD;&amp;#xA;multi line keywords are not truncated&amp;#xD;&amp;#xA;&amp;#xD;&amp;#xA;Steps:&amp;#xD;&amp;#xA;Given I have entered 50 into the calculator&amp;#xD;&amp;#xA;And I have also entered 70 into the calculator&amp;#xD;&amp;#xA;When I press add&amp;#xD;&amp;#xA;Then the result should be 120 on the screen&amp;#xD;&amp;#xA;&amp;#xD;&amp;#xA;&amp;#xD;&amp;#xA;&amp;#xD;&amp;#xA;" /&gt;
                    &lt;property name="Category" value="mytag" /&gt;
                  &lt;/properties&gt;
                  &lt;output&gt;&lt;![CDATA[Given I have entered 50 into the calculator
-&gt; done: CalculatorSteps.GivenIHaveEnteredSomethingIntoTheCalculator(50) (0,0s)
And I have also entered 70 into the calculator
-&gt; done: CalculatorSteps.GivenIHaveAlsoEnteredIntoTheCalculator(70) (0,0s)
When I press add
-&gt; done: CalculatorSteps.WhenIPressAdd() (0,0s)
Then the result should be 120 on the screen
-&gt; done: CalculatorSteps.ThenTheResultShouldBe(120) (0,0s)
]]&gt;&lt;/output&gt;
                &lt;/test-case&gt;`

I'd expect the attribute &lt;ScenarioContent&gt; added to each of the example &lt;test-case&gt; and not all to the &lt;test-suite&gt;.

This looks like an issue. </Description>
  </Issue>
  <Issue>
    <IssueID>3584</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Failed tests are displayed as Error in NUnit Console Runner</Title>
    <CreatedDate>17/06/2020</CreatedDate>
    <ClosedDate>19/06/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:answered</Name>
        <IssueID>3584</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>confirm</Name>
        <IssueID>3584</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I have a test that correctly evaluate a failure but has a result displayed as Error (not Failed as expected). Is it possible there could be some error occured in TearDown method that is causing test result being stated as Error not Failed?   </Description>
  </Issue>
  <Issue>
    <IssueID>3582</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Nunit don't handle custom attribute</Title>
    <CreatedDate>11/06/2020</CreatedDate>
    <ClosedDate>16/06/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>3582</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>confirm</Name>
        <IssueID>3582</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I've created a custom attribute to process retry if an exception was caught. This attribute is a copy of retry attribute except one "if" statement:

``

And I use it in test like this:

`[Test, RetryOnException(2), Category("SmokeTests")]`

In debug mode, I can see that attribute is created, but the "Execute" method isn't called by Nunit</Description>
  </Issue>
  <Issue>
    <IssueID>3578</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>considered dropping support for some older frameworks?</Title>
    <CreatedDate>07/06/2020</CreatedDate>
    <ClosedDate>13/06/2020</ClosedDate>
    <IssueLabels />
    <Description>currently net35, net40, and net45 are supported

 * net35 released in 2007
 * net40 released in 2010
 * net45 released in 2012

there seems to be a reasonable amount of complexity related to supporting them.

Is it time to drop support for any of those? People using them can continue to use older versions</Description>
  </Issue>
  <Issue>
    <IssueID>3576</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>NUnit can't determine the generic type for null argument</Title>
    <CreatedDate>05/06/2020</CreatedDate>
    <ClosedDate>07/06/2020</ClosedDate>
    <IssueLabels />
    <Description>I'm getting error when running generic test with null argument.
`Unable to determine type arguments for method`
Why did NUnit not assume that this is an object?</Description>
  </Issue>
  <Issue>
    <IssueID>3574</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Allow same name for multiple Tests with "TestCaseData / TestCaseSource" via User defined "Test-ID"</Title>
    <CreatedDate>04/06/2020</CreatedDate>
    <ClosedDate>04/06/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:duplicate</Name>
        <IssueID>3574</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>In my application I test several files which might have non unique names, just a unique path.

I would like to use the file name as test name, and the directory-path as category. 

But this results in a strange behaviour in case of duplicates like this:
![grafik](

To reproduce the issue I created / adjusted a simple Testproject:
[Test project](

It would be greate if I could specify a Test-ID (file path).</Description>
  </Issue>
  <Issue>
    <IssueID>3572</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Set TestName to inherited class</Title>
    <CreatedDate>02/06/2020</CreatedDate>
    <ClosedDate>18/06/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:answered</Name>
        <IssueID>3572</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>3572</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>csharp
using NUnit.Framework;
using TestStack.BDDfy;

namespace NUnitTestName
{
    public class Domain{}

    [TestFixture]
    public abstract class ScenarioFor&lt;TSut&gt; where TSut : class
    {
        [Test]
        public void RunTest()
        {
            this.BDDfy();
        }
    }

    public class DomainScenario : ScenarioFor&lt;Domain&gt;
    {
        public void Given(){}
        public void When() { }
        public void Then() { }
    }
}


The only issue is that the TestName is set to "RunTest," which is the name of the test method on the base class. I would like it to be set to the name of the test class - "DomainScenario."

I tried using the TestCase attribute instead, with the class template pattern but this just set the TestName to the name of the base class ScenarioFor`1:

csharp
[TestCase(TestName = "{c}")]
`</Code>
    <Description>I am doing BDD-style tests with a test per class where each test inherits from a base class. Conveniently, I only have to put the Test attribute on the base class and all the tests run for the inheriting classes.

``

Can anyone think of any way that I might achieve this? I have tried a number of other things too and am really open to any suggestion at this stage, no matter how custom.

I am using  NUnit 3.12.0 and NUnit3TestAdapter 3.16.1. The issue occurs in Visual Studio (with ReSharper and Test Explorer) and on Azure DevOps.
</Description>
  </Issue>
  <Issue>
    <IssueID>3569</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Assert.NotNull with C# nullable</Title>
    <CreatedDate>30/05/2020</CreatedDate>
    <ClosedDate>31/05/2020</ClosedDate>
    <IssueLabels />
    <Code>cs
string? x = f();

Assert.NotNull(x);

UseX(x);


void UseX(string x ) { ... }
`</Code>
    <Description>It would be nice to have this code compiling without error.
Is it possible ?

``</Description>
  </Issue>
  <Issue>
    <IssueID>3568</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Build.ps1 -c Debug fails</Title>
    <CreatedDate>30/05/2020</CreatedDate>
    <ClosedDate>31/05/2020</ClosedDate>
    <IssueLabels />
    <Code>
PS C:\Projects\GitHub\nunit&gt; .\build.ps1 -c Debug
Preparing to run build script...
Running build script...

----------------------------------------
Setup
----------------------------------------
Building Debug version 3.13.0-dbg of NUnit.

========================================
NuGetRestore
========================================

Welcome to .NET Core 3.1!
---------------------
SDK Version: 3.1.300

Telemetry
---------
The .NET Core tools collect usage data in order to help us improve your experience. The data is anonymous. It is collected by Microsoft and shared with the community. You can opt-out of telemetry by setting the DOTNET_CLI_TELEMETRY_OPTOUT environment variable to '1' or 'true' using your favorite shell.

Read more about .NET Core CLI Tools telemetry: https://aka.ms/dotnet-cli-telemetry

----------------
Explore documentation: https://aka.ms/dotnet-docs
Report issues and find source on GitHub: https://github.com/dotnet/core
Find out what's new: https://aka.ms/dotnet-whats-new
Learn about the installed HTTPS developer cert: https://aka.ms/aspnet-core-https
Use 'dotnet --help' to see available commands or visit: https://aka.ms/dotnet-cli-docs
Write your first app: https://aka.ms/first-net-core-app
--------------------------------------------------------------------------------------
  Determining projects to restore...
  Restored C:\Projects\GitHub\nunit\src\NUnitFramework\testdata.fsharp\nunit.testdata.fsharp.fsproj (in 388 ms).
  Restored C:\Projects\GitHub\nunit\src\NUnitFramework\slow-tests\slow-nunit-tests.csproj (in 388 ms).
  Restored C:\Projects\GitHub\nunit\src\NUnitFramework\testdata\nunit.testdata.csproj (in 388 ms).
  Restored C:\Projects\GitHub\nunit\src\NUnitFramework\nunitlite.tests\nunitlite.tests.csproj (in 388 ms).
  Restored C:\Projects\GitHub\nunit\src\NUnitFramework\nunitlite-runner\nunitlite-runner.csproj (in 388 ms).
  Restored C:\Projects\GitHub\nunit\src\NUnitFramework\framework\nunit.framework.csproj (in 388 ms).
  Restored C:\Projects\GitHub\nunit\src\NUnitFramework\nunitlite\nunitlite.csproj (in 388 ms).
  Restored C:\Projects\GitHub\nunit\src\NUnitFramework\mock-assembly\mock-assembly.csproj (in 19 ms).
  Restored C:\Projects\GitHub\nunit\src\NUnitFramework\tests\nunit.framework.tests.csproj (in 711 ms).

========================================
Build
========================================
Building using MSBuild at C:/Development (x86)/Microsoft Visual Studio/2019/Enterprise/MSBuild/Current/Bin/MSBuild.exe
Microsoft (R) Build Engine version 16.6.0+5ff7b0c9e for .NET Framework
Copyright (C) Microsoft Corporation. All rights reserved.

CSC : error CS0016: Could not write to output file 'C:\Projects\GitHub\nunit\src\NUnitFramework\framework\obj\Debug\net
35\nunit.framework.xml' -- 'The requested operation cannot be performed on a file with a user-mapped section open. [C:\
Projects\GitHub\nunit\src\NUnitFramework\framework\nunit.framework.csproj]
CSC : error CS0016: Could not write to output file 'C:\Projects\GitHub\nunit\src\NUnitFramework\framework\obj\Debug\net
40\nunit.framework.xml' -- 'The requested operation cannot be performed on a file with a user-mapped section open. [C:\
Projects\GitHub\nunit\src\NUnitFramework\framework\nunit.framework.csproj]
CSC : error CS0016: Could not write to output file 'C:\Projects\GitHub\nunit\src\NUnitFramework\framework\obj\Debug\net
45\nunit.framework.xml' -- 'The requested operation cannot be performed on a file with a user-mapped section open. [C:\
Projects\GitHub\nunit\src\NUnitFramework\framework\nunit.framework.csproj]
CSC : error CS0016: Could not write to output file 'C:\Projects\GitHub\nunit\src\NUnitFramework\framework\obj\Debug\net
standard2.0\nunit.framework.xml' -- 'The requested operation cannot be performed on a file with a user-mapped section o
pen. [C:\Projects\GitHub\nunit\src\NUnitFramework\framework\nunit.framework.csproj]
An error occurred when executing task 'Build'.

----------------------------------------
Teardown
----------------------------------------
Error: One or more errors occurred.
        MSBuild: Process returned an error (exit code 1).
PS C:\Projects\GitHub\nunit&gt;
`</Code>
    <Description>Maybe I missed a step?
``
</Description>
  </Issue>
  <Issue>
    <IssueID>3565</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>jnm2</FixedById>
        <IssueID>3565</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>.NET 5 issue with PlatformAttribute</Title>
    <CreatedDate>29/05/2020</CreatedDate>
    <ClosedDate>11/07/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>3565</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>
An exception was thrown while loading the test.
System.ArgumentException: Unknown framework version 5.5 (Parameter 'version')
   at NUnit.Framework.Internal.RuntimeFramework.ThrowInvalidFrameworkVersion(Version version) in D:\a\1\s\src\NUnitFramework\framework\Internal\RuntimeFramework.cs:line 235
   at NUnit.Framework.Internal.RuntimeFramework.InitFromFrameworkVersion(Version version) in D:\a\1\s\src\NUnitFramework\framework\Internal\RuntimeFramework.cs:line 226
   at NUnit.Framework.Internal.RuntimeFramework..ctor(RuntimeType runtime, Version version) in D:\a\1\s\src\NUnitFramework\framework\Internal\RuntimeFramework.cs:line 177
   at NUnit.Framework.Internal.RuntimeFramework.&lt;&gt;c.&lt;.cctor&gt;b__33_0() in D:\a\1\s\src\NUnitFramework\framework\Internal\RuntimeFramework.cs:line 145
   at System.Lazy`1.ViaFactory(LazyThreadSafetyMode mode)--- End of stack trace from previous location
---
   at System.Lazy`1.CreateValue()   at System.Lazy`1.get_Value()
   at NUnit.Framework.Internal.RuntimeFramework.get_CurrentFramework() in D:\a\1\s\src\NUnitFramework\framework\Internal\RuntimeFramework.cs:line 261
   at NUnit.Framework.Internal.PlatformHelper..ctor() in D:\a\1\s\src\NUnitFramework\framework\Internal\PlatformHelper.cs:line 66
   at NUnit.Framework.PlatformAttribute..ctor(String platforms) in D:\a\1\s\src\NUnitFramework\framework\Attributes\PlatformAttribute.cs:line 37
`</Code>
    <Description>On .NET 5 Preview 4 exception occurred when using PlatformAttribute.

``</Description>
  </Issue>
  <Issue>
    <IssueID>3564</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Nunit 3.12 failed to load the dll in VS 2017 with adapter 3.16.1</Title>
    <CreatedDate>27/05/2020</CreatedDate>
    <ClosedDate>28/05/2020</ClosedDate>
    <IssueLabels />
    <Description>I am using VS 2017 Professional. Nunit 3.12 Nunit Adapter 3.16.1.
[27-05-2020 21:56:23 Informational] ------ Discover test started ------
[27-05-2020 21:56:24 Informational] NUnit Adapter 3.16.1.0: Test discovery starting
[27-05-2020 21:56:39 Informational] NUnit failed to load D:\UiTest.NUnitAdaption.dll
[27-05-2020 21:56:40 Informational] NUnit Adapter 3.16.1.0: Test discovery complete
[27-05-2020 21:56:40 Warning] No test is available in Web..dll. Make sure that test discoverer &amp; executors are registered and platform &amp; framework version settings are appropriate and try again.
[27-05-2020 21:56:40 Informational] ========== Discover test finished: 0 found (0:00:17.346137) ==========
With same Settings it's working fine with 3.2.1</Description>
  </Issue>
  <Issue>
    <IssueID>3562</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Question: is there a way to get parallel assembly execution with dotnet core?</Title>
    <CreatedDate>23/05/2020</CreatedDate>
    <ClosedDate>24/05/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:answered</Name>
        <IssueID>3562</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>3562</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Typically, I've used nunit-console to run tests, however, I'd like to be able to run tests on !windows, so I have an optional dotnet core test strategy, which works, but takes a lot longer, primarily because tests are run in series.

I've had a look at  -- this looks like it deals with parallelisation _within_ the same test assembly. Is there a way to emulate the nunit-console parallel assembly test option from `dotnet test`?

I have some assemblies which run quickly, and others (eg tempdb, which spins up mysql instances, or simple http server, which takes a second to spin up) which take a little longer per-test. Ideally, I'd like to run these test assemblies in parallel.

I could figure out custom parallelization by spawning `dotnet test` per assembly, throttled, from my build pipeline, but I'd really like to know if there's a better way (: </Description>
    <PullRequests />
  </Issue>
  <Issue>
    <IssueID>3560</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>[Question] Is it possible to create TestFixtureSource with generic?? (Like At Picture)</Title>
    <CreatedDate>21/05/2020</CreatedDate>
    <ClosedDate>24/05/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:answered</Name>
        <IssueID>3560</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>3560</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>![Capture1](
</Description>
    <PullRequests />
  </Issue>
  <Issue>
    <IssueID>3556</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>WinUI 3 support</Title>
    <CreatedDate>21/05/2020</CreatedDate>
    <ClosedDate>07/06/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>3556</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>As you may know, Microsoft just releases WinUI 3 Preview 1 

Do you have any plans to support it? If so, letting us know timeframe will be very helpful.</Description>
  </Issue>
  <Issue>
    <IssueID>3552</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>jnm2</FixedById>
        <IssueID>3552</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>MessagePumpStrategy does not work for WPF on netcoreapp3.0 and upwards</Title>
    <CreatedDate>19/05/2020</CreatedDate>
    <ClosedDate>24/05/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>3552</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>3552</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I am trying port our applications to netcoreapp3.1.
During this i also tried to run our unit tests for that target framework.
To my surprise the tests deadlocked as soon as they use async or things like `Assert.CatchAsync`.
The issue boils down to `MessagePumpStrategy` which had special cases for windows forms and WPF on net framework 4.

Is there a reason why there are no special cases for netcoreapp3.0 and upwards or was it just an oversight and those should be there?</Description>
  </Issue>
  <Issue>
    <IssueID>3549</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>String Comparisons are not culture-safe</Title>
    <CreatedDate>15/05/2020</CreatedDate>
    <ClosedDate>15/05/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>3549</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>csharp
[Test, SetCulture("de-DE")]
        public void CultureAware()
        {
            string x = "ss";
            string y = "ß";

            Assert.IsTrue(string.Equals(x, y, StringComparison.CurrentCulture));  // passes
            Assert.AreEqual(x, y);   // fails
        }


There's also issues with case-insensitive comparisons (the following should pass):

csharp
[Test, SetCulture("de-DE")]
        public void CultureAwareStringEquals([Values]bool ignoreCase)
        {
            Assert.That("ss", Is.EqualTo("ß"));

            if (ignoreCase)
                Assert.That("SS", Is.EqualTo("ß").IgnoreCase);
        }
`</Code>
    <Description>The following comparison should probably pass, but doesn't currently

``

This is because, in many places, NUnit uses the following rules for string comparisons:
- Case-insensitive comparisons are `Ordinal` ("s1".Equal("s2"))
- Case-sensitive comparisons invoke `ToLower()` and then perform an ordinal comparison

Most comparisons are done via `StringComparer`, but some constraints duplicate the logic (ex: UniqueItemsConstraint) so changes may be a little more widespread. </Description>
  </Issue>
  <Issue>
    <IssueID>3547</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>DelayedConstraint constrains does not preserve original result additional information</Title>
    <CreatedDate>13/05/2020</CreatedDate>
    <ClosedDate>14/05/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>3547</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>3547</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Assertion without delayed constraint:
`Assert.That(() =&gt; new[] { 1, 2 }, Is.EquivalentTo(new[] { 2, 3 }));`
leads to failure:
``

Expected result: DelayedConstraint should preserve additional information from original constraint result.</Description>
  </Issue>
  <Issue>
    <IssueID>3546</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>ApplyTo&lt;TActual&gt; behavior for Is.Not.Null constraint</Title>
    <CreatedDate>13/05/2020</CreatedDate>
    <ClosedDate>13/05/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>3546</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Hello.
Not sure if it's a bug or a question.

Please consider the following code example (looks like it's working as expected):
`Assert.That&lt;string&gt;((string)null, Is.Not.Null)`

![image](

The question is about the next code example:
`NUnit.Framework.Is.Not.Null.ApplyTo&lt;string&gt;((string)null)`

![image](

Why the second code example returns `Success` ConstraintStatus?

Thank you</Description>
  </Issue>
  <Issue>
    <IssueID>3545</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>[Order] Attribute missing in NUnit 3.12</Title>
    <CreatedDate>11/05/2020</CreatedDate>
    <ClosedDate>17/05/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>3545</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>confirm</Name>
        <IssueID>3545</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Was it removed accidently? It is still available in NUnit 3.11.

For reference I am downloading the "NUnit" package via nuget.org, through Visual Studio 2019, for a .Net Framework 4.7.1 Unit Test Project.</Description>
  </Issue>
  <Issue>
    <IssueID>3542</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Update NuGet Package Icons</Title>
    <CreatedDate>10/05/2020</CreatedDate>
    <ClosedDate>24/05/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>good first issue</Name>
        <IssueID>3542</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:build</Name>
        <IssueID>3542</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>3542</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>The way we include the package icon in the NuGet packages is now deprecated.

WARNING: NU5048: The 'PackageIconUrl'/'iconUrl' element is deprecated. Consider using the 'PackageIcon'/'icon' element instead. Learn more at </Description>
  </Issue>
  <Issue>
    <IssueID>3534</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Selenium C# / NUnit 3.12.0 is not running tests in parallel</Title>
    <CreatedDate>07/05/2020</CreatedDate>
    <ClosedDate>05/09/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>confirm</Name>
        <IssueID>3534</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I am executing my tests in Visual Studio Enterprise 2019 version 16.3.9 / Test Explorer window. My architecture is Intel(R) Core(TM) i7-7600 CPU @ 2.80Ghz (4 CPUs), ~2.9Ghz  
Here is my pseudo Selenium C# code below:

    [TestFixture]
    internal class TestClass{
    
        [OneTimeSetUp]
        public void OneTimeSetUp()
        {
           initializeExtentReport()
        }
    
        [SetUp]
        public void Setup()
        {
           initializeChromebBrowser();
        }
    
        [Test]
        public void NavigatoToGmail()
        {
            bool isGmailAccessible = GoToUrl("
            Assert.True(isGmailAccessible);
        }
    
        [Test]
        public void NavigatoToMicrosoft()
        {
            bool isMicrosoftAccessible = GoToUrl("
            Assert.True(isMicrosoftAccessible);
        }
    
    
        [Test]
        public void NavigatoToYahoo()
        {
            bool isYahooAccessible = GoToUrl("
            Assert.True(isYahooAccessible);
        }
    
        [TearDown]
        public void TearDOwn()
        {
            CloseBrowser();
        }
    
        [OneTimeTearDown]
        public void OneTimeTearDown()
        {
            FinishExtentReport();
        }

So here is what I tried already and it didn't work

1. Adding `[Parallelizable(ParallelScope.Children)]` to the class and `[Parallelizable(ParallelScope.Self)]` attributes to every test method. The result - 3 browser instances open with no other actions. No URL navigating, nothing.

2. Adding `[Parallelizable(ParallelScope.All)]` to class and `[Parallelizable(ParallelScope.Self)]` to every test method. The result - 3 browser instances open. Only the last test (NavigatoToYahoo) is executed and provides the result. The first 2 - no other action happens and the browser windows are not closed, meaning TearDown() method is not executed. 

3. Just adding `[Parallelizable(ParallelScope.Self)]` to every test method. The result - 3 browser instances open with no other actions. No URL navigating, nothing.

4. Adding `[Parallelizable(ParallelScope.Self)]` to the class and `[Parallelizable(ParallelScope.Self)]` attributes to every test method. The result - 3 browser instances open. The second test (NavigateToMicrosoft) gets executed, the rest 2 - no other action, no URL navigating, nothing.

5. Adding `[Parallelizable(ParallelScope.Self)]` to the class and `[Parallelizable(ParallelScope.All)]` attributes to every test method. The result - getting error message `May not specify ParallelScope.Children on a non-parameterized test method` - honestly have no idea why

I have gone through the documentation here  but I feel like there is no actual way to execute unit tests in parallel using NUnit framework. 

I simply want to run those 3 tests (in my actual scenario there are about 100 of them) in parallel independent of each other.</Description>
  </Issue>
  <Issue>
    <IssueID>3529</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Constraints syntax with nullability</Title>
    <CreatedDate>29/04/2020</CreatedDate>
    <ClosedDate>30/04/2020</ClosedDate>
    <IssueLabels />
    <Code>csharp
#nullable enable
public void Auth(string userName, string password) {  }

And we have test for it, where we read secrets from some source (const or config, doesn't matter) and Assert, that they will not be null or empty.
csharp
#nullable enable
[Test]
public void ServiceAuthTest()
{
    Assert.That(Secrets.Test.UserName, Is.Not.Null &amp; Is.Not.Empty, "Test UserName is missed");
    Assert.That(Secrets.Test.Password, Is.Not.Null &amp; Is.Not.Empty, "Test Password is missed");

    var testedService = new Service();
    // Compiler Warning CS8604 Possible null reference argument for parameter 'userName'
    testedService.Auth(Secrets.Test.UserName, Secrets.Test.Password);

    // ...
}
`</Code>
    <Description>Hello!
Right now it isn't possible to use constraints syntax with enabled C#8 nullable feature.

Let's image some auth Service, which doesn't allow null arguments
``
We can understand, that UserName and Password will never be null, but compiler doesn't.

Workarounds:
1. Use '!' operator to ignore warning
2. Ignore CS8604 warning in source with "pragma warning disable"

It isn't critical, but it would be nice to have working code without workarounds.
Also it seems like problem is in Roslyn and there no way to fix it at least right now.

With Assert.IsNotNull(nullable) it should be possible though with [NotNullAttribute] on nullable argument.</Description>
  </Issue>
  <Issue>
    <IssueID>3526</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Add .NET Core 2.1 build of Framework</Title>
    <CreatedDate>26/04/2020</CreatedDate>
    <ClosedDate>07/06/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>3526</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>3526</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>3526</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>There's currently a problem with running tests on .NET Core, that they can only be run successfully if the test assembly and runner are located in the same directory. This hasn't been too much of a problem yet, as for the adapter that's always the case, but it is a problem for users of the engine  ( and will be for the .NET Core Console.

We currently have some reflection-based code which attempts to access .NET Core specific functionality from .NET Standard to correctly load the assemblies - although it's not working for the engine's case, due to the above assumption. It's also tricky in terms of maintenance - and at this point, I suggest we should just add a .NET Core build and remove the reflection.



I'm suggesting this as an additional build rather than a replacement for .NET Standard 2.0, to continue supporting our Xamarin users. I'm suggesting .NET Core 2.1 as the oldest current LTS version that I think the required AssemblyLoadContext APIs are available on.

This is a bit of a blocker for the console, so I'm happy to try and look at it. (Although anyone else who'd like to take this on would be very welcome! 😄)</Description>
  </Issue>
  <Issue>
    <IssueID>3525</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Not able to acheive parallel execution in Nunit while having all the initialization methods and excel methods are there in another project library</Title>
    <CreatedDate>14/04/2020</CreatedDate>
    <ClosedDate>09/05/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>3525</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Do we have any sample project with this reference where the initialization methods and excel, launching browsers are in different project and tests are in different project? Any help would be appreciated Thanks</Description>
  </Issue>
  <Issue>
    <IssueID>3524</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Test discovery fails with generic arrays</Title>
    <CreatedDate>14/04/2020</CreatedDate>
    <ClosedDate>14/04/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:duplicate</Name>
        <IssueID>3524</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>The following works as expected:  three tests are discovered and they all pass.

``
Uncommenting Test4() prevents the tests from being discovered.  I tried this on both Visual Studio 2017 and Visual Studio 2019 with a Net Core 2.2 project and NUnit 3.11, NUnit3TestAdapter 3.11, and Microsoft.NET.Test.Sdk 15.9.0.

While I can work around it by having an IEnumerable&lt;T&gt; parameter instead of an array, I am wondering if this is a known issue and if it is, then if it is documented and I just missed it.

**Note**:  After posting my original message I realized that I had created my test project with the "NUnit Test Project (.NET Core)" template and that I probably needed to update the project's Nuget packages.  Indeed the packages needed updating, I updated them to NUnit 3.12.0, NUnit3TestAdapter 3.16.1, and Microsoft.NET.Test.Sdk 16.5.0.  Unfortunately updating the Nuget packages did not solve the issue I encountered:  Uncommenting Test4() still prevents the tests from being discovered.</Description>
  </Issue>
  <Issue>
    <IssueID>3521</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>TestCaseSource fails to match signature for strings which are not constants</Title>
    <CreatedDate>08/04/2020</CreatedDate>
    <ClosedDate>09/05/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>confirm</Name>
        <IssueID>3521</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>c#
private static IEnumerable&lt;TestCaseData&gt; MyTestCaseData()
{
    var usingVariable = "whatever";

    // Test Case 1
    yield return new TestCaseData(
        new List&lt;Guid&gt;() { },
        $"{usingVariable}");

     // Test Case 2
    yield return new TestCaseData(
        new List&lt;Guid&gt;() { },
        "thisIsAStringLiteralConstant");
}


C#
// Caller 1
// Only one test case is run
[Test]
[TestCaseSource(nameof(MyTestCaseData))]
public async Task MyTest(List&lt;Guid&gt; guids, string words)
{
}


C#
// Caller 2
// Both test cases are run
[Test]
[TestCaseSource(nameof(MyTestCaseData))]
public async Task MyTest(List&lt;Guid&gt; guids, object words)
{
}
`</Code>
    <Description>NUnit Version: 3.12.0
NUnit3TestAdapter Version: 3.16.1

I noticed an issue when using the TestCaseSource attribute in method format. When a string value is not a constant (Test Case 1), it will not match a signature that should otherwise match (Caller 1). However, changing the test parameter from a string (caller 1) to an object (caller 2) and converting it back to a string inside the method seems to work fine and both test cases run.

This behavior seems odd. It feels like a bug that the string value is not recognized properly, but if this behavior is expected, the docs should be updated to reflect this. With no error it is hard to figure out that this is why the test isn't running.

``</Description>
  </Issue>
  <Issue>
    <IssueID>3520</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Package 'NUnit.ConsoleRunner.3.11.1' is not found on source</Title>
    <CreatedDate>06/04/2020</CreatedDate>
    <ClosedDate>06/04/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:answered</Name>
        <IssueID>3520</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>3520</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>We use a build server to build our applications and we are getting the following error; "Package 'NUnit.ConsoleRunner.3.11.1' is not found on source"

We have verified that the directory it is looking for is present. we also added it to the 3.10.0 directory structure.
so in our repository of nuget packages where it is looking we have
NUnit.ConsoleRunner.3.11.1
and
nunit.consolerunner
     3.10.0
     3.11.1

I would have expected the the first to work, but we get the error, and the second one is not woking either.  3.10.0 does compile with no errors.
can the 3.10 and 3.11 be together?  I could remove 3.10, but I hate to remove it until I know how to get 3.11.1 to work.</Description>
  </Issue>
  <Issue>
    <IssueID>3519</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>I wanted to get the data that can be passed as an argument to Test case source from OneTimeSetUp Attribute</Title>
    <CreatedDate>02/04/2020</CreatedDate>
    <ClosedDate>09/05/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>3519</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I wanted to get the data that can be passed as an argument to Test case source from OneTimeSetUp Attribute

I wanted to read test data for all the test cases from the fixture in One Timesetup so that with the help of test case source the data can be passed to the test cases. Is it possibe  , if yes , let me know how ?</Description>
  </Issue>
  <Issue>
    <IssueID>3518</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>How to create an attribute to run logic BEFORE each test is run and AFTER each test is run</Title>
    <CreatedDate>02/04/2020</CreatedDate>
    <ClosedDate>03/04/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:answered</Name>
        <IssueID>3518</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>3518</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Hello,

What is the recommended way to be able to mark tests with an Attribute to run code BEFORE the test starts and AFTER the test finishes?  For Example, I'm wanting to do something like this

``</Description>
  </Issue>
  <Issue>
    <IssueID>3515</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Is it possible to call Assert.Ignore() using reflection?</Title>
    <CreatedDate>27/03/2020</CreatedDate>
    <ClosedDate>31/03/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:answered</Name>
        <IssueID>3515</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>3515</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>We have a test framework which often uses NUnit as the test runner (but not always) and we're looking for a way to ignore tests under certain circumstances (for example where tests are run on iOS devices but the test targets Android).

If I add the following line to a test it works as expected:

``

Is there any way I we can use reflection to call the `Ignore` method so we can keep the framework agnostic?</Description>
  </Issue>
  <Issue>
    <IssueID>3514</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>TryValidateModel throws System.NullReferenceException: 'Object reference not set to an instance of an object.'</Title>
    <CreatedDate>27/03/2020</CreatedDate>
    <ClosedDate>05/09/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>confirm</Name>
        <IssueID>3514</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I am trying to validate a model in a controller method, using TryValidateModel method from ControllerBase class. When I am manually testing the controller method using Swagger, it works and the model is validated. When I'm trying to unit test it tho, it fails at TryValidateModel(myModel) with the following exception: System.NullReferenceException: 'Object reference not set to an instance of an object.'

The object I am passing to TryValidateModel has the same values as the one I am passing via Swagger, and the model makes use of DataAnnotations to ensure that two properties are required, this being the reason why I am using the TryValidateModel method.
I am using NUnit (3.12.0), NSubstitute (4.2.1).

Can you please check if this is a framework related issue?
Thank you.
</Description>
  </Issue>
  <Issue>
    <IssueID>3512</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Specify upper limit with Assert.Multiple</Title>
    <CreatedDate>24/03/2020</CreatedDate>
    <ClosedDate>18/05/2020</ClosedDate>
    <IssueLabels />
    <Description>When using Assert.Multiple with a loop, I want to limit the maximum number of failed assertions. This limits the time lost in doing the assertions and yields a manageable number of failures.
``
Please consider introducing such an API.</Description>
  </Issue>
  <Issue>
    <IssueID>3511</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>No result xml found even if I set --results-directory value</Title>
    <CreatedDate>23/03/2020</CreatedDate>
    <ClosedDate>31/03/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>3511</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I am using .Net core and NUnit console runner with version "3.11.1"

I set --results-directory value -&gt; I see directory is generated
But I dont see any xml files in it.</Description>
  </Issue>
  <Issue>
    <IssueID>3508</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Randomizer in NUnitTestCaseBuilder is always initialized with InitialSeed set to 0</Title>
    <CreatedDate>20/03/2020</CreatedDate>
    <ClosedDate>21/04/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>3508</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Hi,

I found an issue where TestContext.CurrentContext.Random is not random between each session (always same list of numbers returned).
I investigated the issue and found that the Seed is always the same.
Here is my analysis:

When doing var runner =  new NUnitTestAssemblyRunner(new DefaultTestAssemblyBuilder());
runner.Load(assemblyPath, new ListDictionary());

Then TestContext.CurrentContext.Random is always giving the same list of numbers because same seed is used.
This is due because creation of object DefaultTestAssemblyBuilder is creating the NUnitTestCaseBuilder._randomizer before the InitialSeed being set

callstack of the randomizer creation:
NUnit.Framework.Internal.Randomizer.SeedGenerator : 69
NUnit.Framework.Internal.Randomizer.CreateRandomizer()
NUnit.Framework.Internal.Builders.NUnitTestCaseBuilder.NUnitTestCaseBuilder()
NUnit.Framework.Internal.Builders.DefaultTestCaseBuilder.DefaultTestCaseBuilder() 
NUnit.Framework.Internal.Builders.NUnitTestFixtureBuilder.NUnitTestFixtureBuilder() 
NUnit.Framework.Internal.Builders.DefaultSuiteBuilder.DefaultSuiteBuilder() 
NUnit.Framework.Api.DefaultTestAssemblyBuilder.DefaultTestAssemblyBuilder() 

So InitialSeed used is always 0

The InitialSeed is only set when doing the runner.Load with the InitialSeed possibly available in the settings.

I propose to only create the NUnitTestCaseBuilder._randomizer only when necessary : in NUnitTestCaseBuilder.BuildTestMethod

This way Load has been called first and InitialSeed has been set before building the test tree


</Description>
  </Issue>
  <Issue>
    <IssueID>3504</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Support explicit generic type arguments for Tests/Fixtures</Title>
    <CreatedDate>14/03/2020</CreatedDate>
    <ClosedDate>22/03/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:answered</Name>
        <IssueID>3504</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>3504</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>csharp
using System;
using BenchmarkDotNet.Attributes;

namespace BenchmarkDotNet.Samples
{
    [GenericTypeArguments(typeof(int))]
    [GenericTypeArguments(typeof(char))]
    public class IntroGenericTypeArguments&lt;T&gt;
    {
        [Benchmark] public T Create() =&gt; Activator.CreateInstance&lt;T&gt;();
    }
}
`</Code>
    <Description>When looking into how NUnit supports generic in tests there is something left to be desired.

Namely, what I think is missing the most, is the ability to specific generic type arguments explicitly at the fixture or the individual test level.

Here is a sample of how this is done in BenchmarkDotNet:


``

I think that the ability to provide type arguments in the way is invaluable, and intorduces a clean way the enables developers to write simpler code when testing for generic classes

I think that providing a direct type argument like this for NUnit is desirable.</Description>
  </Issue>
  <Issue>
    <IssueID>3499</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>NUnit fails to match TestCase/TestCaseSource with generic test methods</Title>
    <CreatedDate>12/03/2020</CreatedDate>
    <ClosedDate>12/03/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:duplicate</Name>
        <IssueID>3499</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>bash
dotnet test
Test run for /tmp/gn/bin/Debug/netcoreapp3.1/gn.dll(.NETCoreApp,Version=v3.1)
Microsoft (R) Test Execution Command Line Tool Version 16.3.0
Copyright (c) Microsoft Corporation.  All rights reserved.

Starting test execution, please wait...

A total of 1 test files matched the specified pattern.
SetUp failed for test fixture gn.GenericTests
An exception was thrown while loading the test.
System.IndexOutOfRangeException: Index was outside the bounds of the array.
   at NUnit.Framework.Internal.GenericMethodHelper.TryApplyArgType(Type parmType, Type argType)
   at NUnit.Framework.Internal.GenericMethodHelper.TryGetTypeArguments(Object[] argList, Type[]&amp; typeArguments)
   at NUnit.Framework.Internal.Builders.NUnitTestCaseBuilder.CheckTestMethodSignature(TestMethod testMethod, TestCaseParameters parms)
   at NUnit.Framework.Internal.Builders.NUnitTestCaseBuilder.BuildTestMethod(IMethodInfo method, Test parentSuite, TestCaseParameters parms)
   at NUnit.Framework.TestCaseAttribute.BuildFrom(IMethodInfo method, Test suite)+MoveNext()
   at NUnit.Framework.Internal.Builders.DefaultTestCaseBuilder.BuildFrom(IMethodInfo method, Test parentSuite)
   at NUnit.Framework.Internal.Builders.NUnitTestFixtureBuilder.AddTestCasesToFixture(TestFixture fixture, IPreFilter filter)
   at NUnit.Framework.Internal.Builders.NUnitTestFixtureBuilder.BuildFrom(ITypeInfo typeInfo, IPreFilter filter)
   at NUnit.Framework.Internal.Builders.DefaultSuiteBuilder.BuildFrom(ITypeInfo typeInfo, IPreFilter filter)
No test is available in /tmp/gn/bin/Debug/netcoreapp3.1/gn.dll. Make sure that test discoverer &amp; executors are registered and platform &amp; framework version settings are appropriate and try again.

Additionally, path to test adapters can be specified using /TestAdapterPath command. Example  /TestAdapterPath:&lt;pathToCustomAdapters&gt;.




What this boild down to is that Nunit is b0rked by even the following construct:

csharp
[TestCase(new[] { 1 })]
public void GenericArrayShouldWork&lt;T&gt;(T[] data) { }
`</Code>
    <Description>Hi,
I could not find indication if this sort of this is supposed to be supported and/if how, so I'm opening this issue for what seems almost a trivial case that is not supported by NUnit with respect to generic types. This might not be high on the list of stuff to support, but should at least be explicitly detected and reported, rather than lead to a crash, which is what is happenning now.

I've created a repro project where a few generic constructs clearly fail NUnit:


Here's the sort of exception I'm encountering:
``

As well as more advanced constructs involving a `TestCaseSource` generating generic array, tuples with generic types, tuples with generic array, or generic classes.</Description>
  </Issue>
  <Issue>
    <IssueID>3491</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Does.Not.Contain() is string only</Title>
    <CreatedDate>04/03/2020</CreatedDate>
    <ClosedDate>04/03/2020</ClosedDate>
    <IssueLabels />
    <Description>`Does.Not.Contains()` is grammatically incorrect, however it comes with the necessary `object` overload to make it work on any type that's not `string`. I think I'm running 3.5.</Description>
  </Issue>
  <Issue>
    <IssueID>3485</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Should we make MultipleAssertException.TestResult maybe-null or obsolete two constructors?</Title>
    <CreatedDate>28/02/2020</CreatedDate>
    <ClosedDate>03/03/2020</ClosedDate>
    <IssueLabels />
    <Description>@nunit/framework-team 

### Option 1

``

</Description>
  </Issue>
  <Issue>
    <IssueID>3480</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>how to attain TestResults.XML file when running tests via NUnit.Engine c# project?</Title>
    <CreatedDate>27/02/2020</CreatedDate>
    <ClosedDate>28/02/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>3480</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Hi, 

I have a C# API project and have some GET/POST methods utilising the NUnit.Engine to Explore and Run my Nunit tests, the code is working fine however i am struggling to attain the results output in the format that the GUI or Console provides? i am using;

``
but the content of these output cannot be parsed into Living Reports through PicklesCommandLine like i am able to do when the test is executed via Console or GUI.

sorry if i have incorrectly placed this query, its my first time here. 

any help greatly appreciated.

thanks &amp; Regards </Description>
  </Issue>
  <Issue>
    <IssueID>3479</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Q: Dev efficient setup of path</Title>
    <CreatedDate>26/02/2020</CreatedDate>
    <ClosedDate>27/02/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:answered</Name>
        <IssueID>3479</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>3479</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Hi, we've just upgraded to NUnit3 and faced the breaking change where environmental path is no longer set. Now the path may afaik be prefixed on each respective place, or in a fixture setup, or using the special test class that sets it for the whole project (though this is brittle as this would execute only when running the whole project and not individual test, right?). And we still have maybe even hundreds of test projects here. Is there a better / easier / more global way?
The change may have made it cleaner, but so far it seems like a hit to practicality.
Thank you for help</Description>
  </Issue>
  <Issue>
    <IssueID>3478</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Running tests in parallel</Title>
    <CreatedDate>25/02/2020</CreatedDate>
    <ClosedDate>28/02/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>3478</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I couldn't find anywhere a detailed explanation regarding the different scopes of parallel test execution.

If I mark a test class as **Parallelizable** on the **children level**, what does it mean exactly?
Do the tests run in a different process or just on different threads?
Will the **'oneTimeSetup'** methods run once, and when it's over the execution will commence?
Do the tests run on different instances of the class?

I need to understand all of these in order to plan my project's parallel execution.

Regards,

Asaf.</Description>
  </Issue>
  <Issue>
    <IssueID>3477</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Data-driven tests using data created in the [SetUp] method</Title>
    <CreatedDate>25/02/2020</CreatedDate>
    <ClosedDate>26/02/2020</ClosedDate>
    <IssueLabels />
    <Description>I have data generated in my setup method:
``

How can I achieve this without using delegates (which result in less readable code)?</Description>
  </Issue>
  <Issue>
    <IssueID>3475</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>IrisClasson</FixedById>
        <IssueID>3475</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Our XML comments are using &lt;code&gt; (block element) instead of &lt;c&gt; (inline element)</Title>
    <CreatedDate>20/02/2020</CreatedDate>
    <ClosedDate>17/05/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>good first issue</Name>
        <IssueID>3475</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>3475</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>3475</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Example:



Visual Studio has recently begun taking the XML comment formatting tags seriously, so it may make a difference.

I would recommend that we add the design-time tool  to our Directory.Build.props and follow all its prompts. It's been awesome in every project where I've seen it. I know it catches this particular case.</Description>
  </Issue>
  <Issue>
    <IssueID>3473</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Assert.NotNull should have a ValidatedNotNullAttribute on the anObject parameter</Title>
    <CreatedDate>19/02/2020</CreatedDate>
    <ClosedDate>29/02/2020</ClosedDate>
    <IssueLabels />
    <Description>Take the following example:

``

Static code analyzers like Sonar will generate a warning on the `model.WhatEver` call, arguing that model could be `null`. Since the early days of FxCop the `[ValidatedNotNullAttribute]` was introduced to help with the analysis, saying: if a parameter was decorated with that, it could be safely assumed that no null reference exception could occur on later references to it.

It would be nice if `Assert.IsNotNull`  and `Assert.NotNull` would have such an attribute on the `object AnObject` parameter.</Description>
    <PullRequests>
      <PullRequest>
        <RepoID>nunitWebScrap</RepoID>
        <IssueID>3473</IssueID>
        <PullRequestID>3450</PullRequestID>
        <Title>Nullability annotations for the Assert class</Title>
        <Description>Contributes to 

Annotating any more than a class at a time will be overwhelming to review. I'm starting with the most-seen types.

The intent with all annotations is to reflect current behavior. If `null` is tolerated, I'm marking the parameter as nullable. If it causes ArgumentNullException, NullReferenceException, etc, I'm marking as non-nullable.</Description>
        <CreatedDate>27/12/2019</CreatedDate>
        <ClosedDate>28/02/2020</ClosedDate>
        <PullRequestLabels>
          <PullRequestLabel>
            <Name>awaiting:review</Name>
            <IssueID>3473</IssueID>
            <PullRequestID>3450</PullRequestID>
            <RepoID>nunitWebScrap</RepoID>
          </PullRequestLabel>
        </PullRequestLabels>
        <PullRequestAssignees />
      </PullRequest>
      <PullRequest>
        <RepoID>nunitWebScrap</RepoID>
        <IssueID>3473</IssueID>
        <PullRequestID>3474</PullRequestID>
        <Title>Added ValidatedNotNullAttribute to Assert.NotNull methods to satisfy static code analyzers on null-checking</Title>
        <Description>See #3473

Should be simple to add. Not sure if we want a automated test for this, and how that should look like.
</Description>
        <CreatedDate>19/02/2020</CreatedDate>
        <ClosedDate>29/02/2020</ClosedDate>
        <PullRequestLabels>
          <PullRequestLabel>
            <Name>awaiting:discussion</Name>
            <IssueID>3473</IssueID>
            <PullRequestID>3474</PullRequestID>
            <RepoID>nunitWebScrap</RepoID>
          </PullRequestLabel>
        </PullRequestLabels>
        <PullRequestAssignees />
      </PullRequest>
    </PullRequests>
  </Issue>
  <Issue>
    <IssueID>3470</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Assertion for key-value-pair</Title>
    <CreatedDate>14/02/2020</CreatedDate>
    <ClosedDate>07/05/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>3470</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>cs
public void Merge_NoConflicts()
{
    var mainDict = new Dictionary&lt;string, int&gt;
    {
        { "Test", 1 }
    };
    var otherDict = new Dictionary&lt;string, int&gt;
    {
        { "Test2", 42 }
    };

    var result = mainDict.Merge(otherDict);

    // --- Variant 1 (full checks, ugly to read) ---
    Assert.That(result, Contains.Key("Test"));
    Assert.That(result["Test"], Is.EqualTo(1));
    Assert.That(result, Contains.Key("Test2"));
    Assert.That(result["Test2"], Is.EqualTo(42));

    // --- Variant 2 (better but throws KeyNotFoundException, would like outlike like SomeItemsConstraint) ---
    Assert.That(result["Test"], Is.EqualTo(1));
    Assert.That(result["Test2"], Is.EqualTo(42));

    // --- Variant 3 (works, better than 1 but but uglier to read than 2) ---
    Assert.That(result, Contains.Item(new KeyValuePair&lt;string, int&gt;("Test", 1)));
    Assert.That(result, Contains.Item(new KeyValuePair&lt;string, int&gt;("Test2", 42)));

    // --- Variant 4 (looks correct, but ContainValue is called on result, so no relation to the pair) ---
    Assert.That(result, Contains.Key("Test").And.ContainValue(1));
    Assert.That(result, Contains.Key("Test2").And.ContainValue(42));

    // --- Variant 5 (some API I would prefer but can't find) ---
    Assert.That(result, Contains.Key("Test").WithValue(1));
    Assert.That(result, Contains.Key("Test2").WithValue(42));
}
`</Code>
    <Description>I was looking for a good way to check key-value-pairs. I know about `DictionaryContainsKeyConstraint` and `DictionaryContainsValueConstraint`, but have not found any option to combine them on the same item. Chaining it with `And` will also operate on the asserted value and not on the item identified by the key.

``

It would be pretty easy to implement an `DictionaryContainsKeyValueConstraint` that implements the `Matches` method using `TryGet`. It's also easy to add the `WithValue` method to `DictionaryContainsKeyConstraint` and have it work with all notations (`Contains.Key`, `Does.ContainKey`, ...). But before doing a PR, I wanted to know if there already is a good way of doing it and just not finding it.</Description>
  </Issue>
  <Issue>
    <IssueID>3469</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>EquatablesComparer can return true when default Equals method returns false</Title>
    <CreatedDate>13/02/2020</CreatedDate>
    <ClosedDate>29/02/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:wontfix</Name>
        <IssueID>3469</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>In switching some of our assemblies to use Nunit 3.12. I have a few new test failures that are the result of changes in the way Nunit implements AreEqual/AreNotEqual. In the underlying implementation, it goes through a long list of comparers, one of which is EquatablesComparer. We have some objects that implement IEquatable&lt;IPalasoDataObjectProperty&gt;. We have an abstract class
`public abstract class CloneableTests&lt;T, TClone&gt; where T : ICloneable&lt;TClone&gt;`
For the concrete case of
`ClonableTests&lt;IPalasoDataObjectProperty, IPalasoDataObjectProperty&gt;`
one of the text cases has Assert.AreNotEqual(a, b), where a and b are both of type IPalasoDataObjectProperty.
Stepping through the implementation of AreNotEqual, I see that eventually it gets to the list of comparers and when it asks the EquatablesComparar if the two objects are equal, it returns true. This is because it explicitly invokes an implementation of Equals based on the two objects being IEquatable&lt;IPalasoDataObjectProperty&gt;. However, IPalasoDataObjectProperty implements Equals in such a way that it returns false for these two objects.
I can't tell if this is a bug in NUnit or a deficiency in our code. In one sense, it seems it could be argued that any version of Equals that can validly apply to two objects should return the same result. On the other hand, it also seems fair to say NUnit should use the same version of Equals that would normally be applied to two objects, rather than using reflection to select a different version of Equals.
For now, I have worked around this by changing the test to
`Assert.IsFalse(a.Equals(b));`
If you think the current behavior of NUnit is correct, I will kick this issue back to the developers who know these classes better on our end to see if they can improve them so that the Equals implementation based on the IEquatable interface can see the distinction that our Equals method detects. Otherwise, if you think this may be a deficiency in NUnit, I can try to boil things down to a concrete example.</Description>
  </Issue>
  <Issue>
    <IssueID>3463</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Test passes despite exception when passed assertion is recorded in teardown</Title>
    <CreatedDate>29/01/2020</CreatedDate>
    <ClosedDate>05/03/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:wontfix</Name>
        <IssueID>3463</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>csharp
[Test]
public void Test1()
{
    throw new Exception();
}

[Test]
public void Test2()
{
    Assert.Fail();
}

[TearDown]
public void TearDown()
{
    TestExecutionContext.CurrentContext.CurrentResult.RecordAssertion(AssertionStatus.Passed, "A");
}
`</Code>
    <Description>From the two tests below, `Test` passes and `Test2` fails. I would expect both tests to fail as both end with exception.

``</Description>
  </Issue>
  <Issue>
    <IssueID>3460</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>How to customize NUnit TimeOut message : 'Test exceeded Timeout value of.....' (in C#)</Title>
    <CreatedDate>21/01/2020</CreatedDate>
    <ClosedDate>29/02/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>3460</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>On Timeout we get message like "Test exceeded Timeout value of....."
There is a lot of value knowing at which point Time Out happened.
Makes it easier to get to the origin of the failure.
Please let me know if there is a way to do this.
----------------------------------------------------
**I am looking for a way where either N Unit does this or allows me to customize this message**
</Description>
  </Issue>
  <Issue>
    <IssueID>3459</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Is.GreaterThanOrEqualTo is incorrect for hyphenated strings.</Title>
    <CreatedDate>17/01/2020</CreatedDate>
    <ClosedDate>17/01/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>3459</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>The following assertions fail when they should pass:
``</Description>
  </Issue>
  <Issue>
    <IssueID>3152</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Custom test grouping and naming</Title>
    <CreatedDate>01/02/2019</CreatedDate>
    <ClosedDate>03/02/2019</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>3152</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>csharp
[TestCaseSource("Mul_TestCases")]
public void Mul(double expected, double a, double b) {
    Assert.AreEqual(expected, a * b);
}

public IEnumerable Mul_TestCases {
    get {
        yield return new TestCaseData(4, 2, 2);
        yield return new TestCaseDate(6, 2, 3);
    }
}


By default, NUnit generates a test group (_a test suite_?) name from a method, and test names - by combining a method name and arguments. So I get the following test structure:

text
Tests
└ Mul
  ├ Mul(4,2,2)
  └ Mul(6,2,3)


**My question is**, is it possible to override the names of both the test group and test cases and still retain the structure? I.e. what I'd like to get:

text
Tests
└ 🌈 Multiplication 🌈
  ├  2 × 2 is 4
  └  2 × 3 is 6
`</Code>
    <Description>Sorry, I didn't find relevant information about this. Suppose I have a test like follows:

``</Description>
  </Issue>
  <Issue>
    <IssueID>3150</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>StackTrace is not available in "test-case" xml node in case of FixtureOneTimeSetUp fails</Title>
    <CreatedDate>30/01/2019</CreatedDate>
    <ClosedDate>31/01/2019</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>3150</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>3150</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>csharp
public class FailedClass
    {
        [OneTimeSetUp]
        public void Init()
        {
            throw new Exception("Here is OneTimeSetup exception.");
        }

        [Test]
        public void Test1()
        {
        }
    }



And test result is:
xml
&lt;test-suite type="SetUpFixture" id="0-1032" name="InnerFolder" fullname="Example.Tests.InnerFolder.ClassFixtureSetup" classname="Example.Tests.InnerFolder.ClassFixtureSetup" runstate="Runnable" testcasecount="2" result="Failed" label="Error" site="SetUp" start-time="2019-01-30 18:40:16Z" end-time="2019-01-30 18:40:16Z" duration="0.000569" total="2" passed="0" failed="2" warnings="0" inconclusive="0" skipped="0" asserts="0"&gt;
          &lt;failure&gt;
            &lt;message&gt;&lt;![CDATA[System.Exception : Assembly SetUpFixture exception.]]&gt;&lt;/message&gt;
            &lt;stack-trace&gt;&lt;![CDATA[   at Example.Tests.InnerFolder.ClassFixtureSetup.OneTimeSetUp() in C:\Projects\ReportPortal\example-net-nunit\src\Example\Tests\InnerFolder\ClassFixtureSetup.cs:line 19]]&gt;&lt;/stack-trace&gt;
          &lt;/failure&gt;
          &lt;test-suite type="TestFixture" id="0-1029" name="Class1" fullname="Example.Tests.InnerFolder.Class1" classname="Example.Tests.InnerFolder.Class1" runstate="Runnable" testcasecount="2" result="Failed" label="Error" site="Parent" start-time="0001-01-01 00:00:00Z" end-time="0001-01-01 00:00:00Z" duration="0.000000" total="0" passed="0" failed="0" warnings="0" inconclusive="0" skipped="0" asserts="0"&gt;
            &lt;failure&gt;
              &lt;message&gt;&lt;![CDATA[OneTimeSetUp: System.Exception : Assembly SetUpFixture exception.]]&gt;&lt;/message&gt;
            &lt;/failure&gt;
          &lt;/test-suite&gt;
          &lt;test-case id="0-1030" name="Test1" fullname="Example.Tests.InnerFolder.Class1.Test1" methodname="Test1" classname="Example.Tests.InnerFolder.Class1" runstate="Runnable" seed="841445099" result="Failed" label="Error" site="Parent" start-time="0001-01-01 00:00:00Z" end-time="0001-01-01 00:00:00Z" duration="0.000000" asserts="0"&gt;
            &lt;failure&gt;
              &lt;message&gt;&lt;![CDATA[OneTimeSetUp: System.Exception : Assembly SetUpFixture exception.]]&gt;&lt;/message&gt;
            &lt;/failure&gt;
          &lt;/test-case&gt;
        &lt;/test-suite&gt;
`</Code>
    <Description>``

We see that `stack-trace` node is missing in 'test-case' node, and available only in `test-suite` node. It's confusing because of the situation is different for `message` node.

Is it expected? This is minor issue, just clarify whether it;s a bug or is by design.</Description>
  </Issue>
  <Issue>
    <IssueID>3146</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Default timeouts for uap10.0 tests</Title>
    <CreatedDate>28/01/2019</CreatedDate>
    <ClosedDate>18/05/2020</ClosedDate>
    <IssueLabels />
    <Description>Hi,

My organization has a requirement that we run tests on uap10.0, we are currently doing this using NUnitLite.

We'd like to set default timeouts on tests so that if one hangs, it will fail.  It looks like this is supported if the nunitlite.dll that's being used was built with the #PARALLEL constant defined:
![image](

I'm seeing that in older versions of the nunitlite nuget package (3.6.1), uap10.0 would link against a portable class library that did have this defined, however in the newer version (3.11.0), it links against .NET Standard 1.4, which doesn't.  I believe we're stuck using the newer 3.11.0 version, which poses a problem for getting test timeouts.

Ideas/suggestions/advice?  Thanks so much!</Description>
    <PullRequests />
  </Issue>
  <Issue>
    <IssueID>3145</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Capture additional exception details in the test output</Title>
    <CreatedDate>27/01/2019</CreatedDate>
    <ClosedDate>21/04/2019</ClosedDate>
    <IssueLabels />
    <Description>When our applications throw exceptions, we capture additional context in the .Data property of the exceptions. We would like to include this context in the NUnit output to reduce the time spent combing through logs and stepping through the debugger.

I've created two options for capturing additional information from exceptions.  

&gt; 1) Capture the exception in a new ExceptionResult.Exception property.
Pros:
    * A straightforward change. 
    * It can be inspected by components for different purposes.  
Con: 
    * Including the exception in the output of tests is more complicated, requiring an additional wrapper.  The output will not be included as part of the default NUnit error message

&gt; 2) .  Register a static delegate with ExceptionHelper.GetAdditionalDetails
Pros:
    * A straightforward change. 
    * Very simple to use
    * Context is included with the exception message, making it easier to correlate.
Cons:
    * Doesn't fit with NUnit pattern of providing extensibility points via interfaces
    * Global to the app domain.  Cannot be enabled only for select fixtures.  This isn't an issue for our use case but I assume there are cases where this may be an issue.

Would either of these be acceptable solutions?  If not, do you have recommendations for how you'd like to see it?</Description>
    <PullRequests>
      <PullRequest>
        <RepoID>nunitWebScrap</RepoID>
        <IssueID>3145</IssueID>
        <PullRequestID>3184</PullRequestID>
        <Title>Include ex.Data values in failure message (#3145)</Title>
        <Description>Capture exception in ExceptionResult, enabling
extensions to perform more in-depth analysis &amp;
reporting for failures

When value is null, replace with "&lt;null&gt;"

Closes #3145</Description>
        <CreatedDate>09/03/2019</CreatedDate>
        <ClosedDate>21/04/2019</ClosedDate>
        <PullRequestLabels>
          <PullRequestLabel>
            <Name>awaiting:review</Name>
            <IssueID>3145</IssueID>
            <PullRequestID>3184</PullRequestID>
            <RepoID>nunitWebScrap</RepoID>
          </PullRequestLabel>
        </PullRequestLabels>
        <PullRequestAssignees />
      </PullRequest>
    </PullRequests>
  </Issue>
  <Issue>
    <IssueID>3144</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Retry attribute should not derive from PropertyAttribute</Title>
    <CreatedDate>25/01/2019</CreatedDate>
    <ClosedDate>30/01/2019</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>3144</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>good first issue</Name>
        <IssueID>3144</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>help wanted</Name>
        <IssueID>3144</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>3144</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:low</Name>
        <IssueID>3144</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>The `RetryAttribute` derives from `PropertyAttribute` and passes the retry count to the base as the property to set which is never used. This sets unneeded properties on the test and will end up creating odd categories in test runners like Visual Studio.

``

This attribute should probably just derive from `NUnitAttribute`</Description>
  </Issue>
  <Issue>
    <IssueID>3138</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>jnm2</FixedById>
        <IssueID>3138</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Assert.Ignore breaks when a Task is returned w/o using async/await</Title>
    <CreatedDate>11/01/2019</CreatedDate>
    <ClosedDate>08/02/2019</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>3138</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>3138</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>3138</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>
NUnit.Framework.Internal.NUnitException : Rethrown
  ----&gt; NUnit.Framework.IgnoreException : should not run
   at NUnit.Framework.Internal.Reflect.InvokeMethod(MethodInfo method, Object fixture, Object[] args) in C:\src\nunit\nunit\src\NUnitFramework\framework\Internal\Reflect.cs:line 281
   at NUnit.Framework.Internal.AsyncToSyncAdapter.Await(Func`1 invoke) in C:\src\nunit\nunit\src\NUnitFramework\framework\Internal\AsyncToSyncAdapter.cs:line 77
   at NUnit.Framework.Internal.Commands.TestMethodCommand.RunTestMethod(TestExecutionContext context) in C:\src\nunit\nunit\src\NUnitFramework\framework\Internal\Commands\TestMethodCommand.cs:line 84
--IgnoreException
   at NUnit.Framework.Assert.Ignore(String message, Object[] args) in C:\src\nunit\nunit\src\NUnitFramework\framework\Assert.cs:line 214
   at TestNUnit.Class1.Failing() in C:\Users\Sean\Desktop\TestNUnit\TestNUnit\Class1.cs:line 16

&lt;/details&gt;
&lt;br&gt;

The failing test looks as the following:

c#
        [Test]
        public Task Failing()
        {
            Assert.Ignore("should not run");

            return Task.FromResult(1);
        }


Changing the test to include the `async` keyword with `await` fixes this test:

c#
        [Test]
        public async Task Working()
        {
            Assert.Ignore("should not run");

            await Task.FromResult(1);
        }
`</Code>
    <Description>Writing a test that invokes `Assert.Ignore()` and it fails with the following exception:

&lt;details&gt;&lt;summary&gt;Stacktrace&lt;/summary&gt;

``

This fails with NUnit 3.11.0, but works with earlier versions.
Tested with .NET Framework 4.5.2

</Description>
    <PullRequests>
      <PullRequest>
        <RepoID>nunitWebScrap</RepoID>
        <IssueID>3138</IssueID>
        <PullRequestID>3095</PullRequestID>
        <Title>Support custom awaitables</Title>
        <Code>cs
[Test]
public async ValueTask Test1()
{
    await Task.Yield();
}

[Test]
public ValueTask Test2() =&gt; Test1();


Awaitable objects (consumable via the `await` keyword since C# 5) go beyond tasklike objects (produceable via the `async` keyword since C# 7). It doesn't matter whether you can use a type as an `async` method builder return type; it only matters whether you can `await` it:

cs
[Test]
public System.Runtime.CompilerServices.YieldAwaitable Test3() =&gt; Task.Yield();


#### Behavioral changes

`Assert.That` now treats all delegates that return an awaitable type the same way it has treated delegates returning Task, by waiting for the result:

cs
Assert.That(() =&gt; foo.ValueTaskReturningMethod(), Throws.InstanceOf&lt;FooException&gt;());


### No new APIs

This PR does not add new APIs. Therefore, `Assert.ThrowsAsync` still requires our `AsyncTestDelegate` type to be passed which requires the delegate to return `Task`. 

If we wanted to support this, we would have to add an `Assert.ThrowsAsync(Func&lt;object&gt;)` overload. This is as specific as you can be in C# while still allowing custom awaitable return types. We would have to error at runtime (and via analyzer) if the returned value was not in fact awaitable.

Folks using ValueTask have reasonably easy ways to handle this already which work in all versions of NUnit:

c#
[Test]
public void Test4() =&gt; Assert.ThrowsAsync(() =&gt; foo.ValueTaskReturningMethod().AsTask());

[Test]
public void Test5() =&gt; Assert.ThrowsAsync(async () =&gt; await foo.ValueTaskReturningMethod());


As well as constraint syntax as of NUnit 3.12, as mentioned above:

c#
[Test]
public void Test7() =&gt; Assert.That(foo.ValueTaskReturningMethod, Throws.Exception);
`</Code>
        <Description>Closes #2286, #3023, #3093.
Fixes #2168 and properly fixes #3222.

### New features

This enables test and setup methods (and any other methods in user code which NUnit directly invokes) to return objects other than Task which the C# language knows how to await, according to the awaitable expressions section of the C# 5 spec which has not been changed as of 7.3.

It does not matter whether the `async` keyword is used, so both of these will work:

``

### Codebase changes

Because awaitability is pattern-based rather than type-based, I was able to delete almost all occurrences of `#if ASYNC` (there are only five places left in the framework). Async behavior is now automatically effective in all builds, including `net20` and `net35`.

The remaining occurrences have less to do with async behavior and more to do with whether the .NET 4.0 Task Parallel Library framework types are available. For example, whether we define `AsyncTestDelegate` which has a return value of `Task`.
In an [earlier discussion]( we decided on changing `ASYNC` to `TASK_PARALLEL_LIBRARY_API`.</Description>
        <CreatedDate>24/11/2018</CreatedDate>
        <ClosedDate>12/05/2019</ClosedDate>
        <PullRequestLabels>
          <PullRequestLabel>
            <Name>awaiting:review</Name>
            <IssueID>3138</IssueID>
            <PullRequestID>3095</PullRequestID>
            <RepoID>nunitWebScrap</RepoID>
          </PullRequestLabel>
        </PullRequestLabels>
        <PullRequestAssignees />
      </PullRequest>
      <PullRequest>
        <RepoID>nunitWebScrap</RepoID>
        <IssueID>3138</IssueID>
        <PullRequestID>3036</PullRequestID>
        <Title>Apartment state can't be used for .NET Standard 2.0 tests</Title>
        <Description>Closes #3035.

Enables apartment state for .NET Standard 2.0 builds. All tests pass under Windows, Unix may have some failing tests, but I think I've added platform includes in all the places they might.</Description>
        <CreatedDate>30/09/2018</CreatedDate>
        <ClosedDate>24/04/2019</ClosedDate>
        <PullRequestLabels>
          <PullRequestLabel>
            <Name>closed:done</Name>
            <IssueID>3138</IssueID>
            <PullRequestID>3036</PullRequestID>
            <RepoID>nunitWebScrap</RepoID>
          </PullRequestLabel>
        </PullRequestLabels>
        <PullRequestAssignees />
      </PullRequest>
      <PullRequest>
        <RepoID>nunitWebScrap</RepoID>
        <IssueID>3138</IssueID>
        <PullRequestID>3216</PullRequestID>
        <Title>Restore full assembly paths in test XML</Title>
        <Description>Fixes #3085.

/cc @CharliePoole </Description>
        <CreatedDate>24/04/2019</CreatedDate>
        <ClosedDate>24/04/2019</ClosedDate>
        <PullRequestLabels>
          <PullRequestLabel>
            <Name>awaiting:review</Name>
            <IssueID>3138</IssueID>
            <PullRequestID>3216</PullRequestID>
            <RepoID>nunitWebScrap</RepoID>
          </PullRequestLabel>
        </PullRequestLabels>
        <PullRequestAssignees />
      </PullRequest>
      <PullRequest>
        <RepoID>nunitWebScrap</RepoID>
        <IssueID>3138</IssueID>
        <PullRequestID>3098</PullRequestID>
        <Title>3053 - Conversion from TestCase string parameter to DateTimeOffset</Title>
        <Description>Fixes 

Updates `TestCaseAttribute` to convert `String` parameter to `DateTimeOffset`
I noticed the existing type conversion logic wasn't applied to params arrays, so I expanded it to work there too (I added a test for the existing TimeSpan logic for that too).

### Added Dependencies
#### NET Standard 1.4
- `System.ComponentModel.TypeConverter`

### Scope Creep
I also noticed that the `ValuesAttribute` handles most type conversions the `TestCaseAttribute` does, so I added this `string -&gt; DateTimeOffset` conversion for it too. I also consolidated some of the type conversion logic between them (`TestCaseAttribute` now uses `ParamAttributeTypeConversions` too). In the process, I had to update `ParamAttributeTypeConversions` to map values to nullable primitives, it looks like previously we only mapped null to nullable primitives.

One potential change to existing behaviour is that `TestCaseAttribute` previously called `TimeSpan.Parse()` without providing a culture, whereas it looked like most other conversions used `CultureInfo.InvariantCulture` (including when `ValuesAttribute` converts a string to a `TimeSpan`. So in the process of centralizing the type conversion logic, `TestCaseAttribute` now also uses `CultureInfo.InvariantCulture` when converting a string to a `TimeSpan`.

In keeping with comment  `TimeSpan` now also gets converted using `TypeConverter` instead of `Convert`, as it does not implemement `IConvertible`.

Since this is a bit more than just "Conversion from TestCase string parameter to DateTimeOffset" covered in this PR, let me know if a second GH issue and/or PR should be required for the broader changes.</Description>
        <CreatedDate>26/11/2018</CreatedDate>
        <ClosedDate>28/04/2019</ClosedDate>
        <PullRequestLabels>
          <PullRequestLabel>
            <Name>awaiting:review</Name>
            <IssueID>3138</IssueID>
            <PullRequestID>3098</PullRequestID>
            <RepoID>nunitWebScrap</RepoID>
          </PullRequestLabel>
        </PullRequestLabels>
        <PullRequestAssignees />
      </PullRequest>
      <PullRequest>
        <RepoID>nunitWebScrap</RepoID>
        <IssueID>3138</IssueID>
        <PullRequestID>3205</PullRequestID>
        <Title>Added TestCaseData.Combinatorial() method</Title>
        <Description>When generating test cases, it is extremely convenient to be able to use the Combinatorial strategy for parameterized tests.

Unfortunately, this concept was not available when using TestCaseSource / TestCaseData.  This change is meant to make this functionality available in that situation.

I originally rolled out my own Combinatorial method, not thinking about how the logic already exists elsewhere.  I eventually modified that logic to be re-usable, and just re-implemented it for TestCaseSource / TestCaseData.</Description>
        <CreatedDate>09/04/2019</CreatedDate>
        <ClosedDate>
        </ClosedDate>
        <PullRequestLabels>
          <PullRequestLabel>
            <Name>awaiting:contributor</Name>
            <IssueID>3138</IssueID>
            <PullRequestID>3205</PullRequestID>
            <RepoID>nunitWebScrap</RepoID>
          </PullRequestLabel>
        </PullRequestLabels>
        <PullRequestAssignees />
      </PullRequest>
    </PullRequests>
  </Issue>
  <Issue>
    <IssueID>3136</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Add "result properties"</Title>
    <CreatedDate>02/01/2019</CreatedDate>
    <ClosedDate>18/05/2020</ClosedDate>
    <IssueLabels />
    <Description>**Overview**

Today, NUnit supports the notion of test properties which can be used to associate static metadata with a test.

Similarly, it would be beneficial to be able to associate potentially-dynamic metadata with a test result for the purpose of providing additional diagnostic information after-the-fact. Examples of this include:
* If the test uses an external resource (e. g. a database), recording which instance of the resource was used
* Associating additional diagnostic information (e. g. a test which uses the Selenium API to automate a browser might wish to capture screenshots on failure and associate those files with the test result).
* Logging performance information

This was suggested in #3118.

**Potential API**

Ultimately, the API would look like adding to a dictionary, something like:

``

**Current workarounds**

Today, this can be simulated by using test properties; you can add test properties at runtime via `TestExecutionContext.CurrentContext.CurrentTest.Properties.Add` or (less conviently) by implementing `ITestAction` and modifying `ITest.Properties` in `AfterTest`. However, according to #3118, this functionality is not intentional and may be removed in the future.</Description>
  </Issue>
  <Issue>
    <IssueID>3135</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>TestCaseAttribute special type conversions don't work with param array</Title>
    <CreatedDate>01/01/2019</CreatedDate>
    <ClosedDate>25/01/2019</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:wontfix</Name>
        <IssueID>3135</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>csharp
[TestCase(1, 2, 3)]
        public void CanConvertStringToDateTimeAsParamArray(int a, int b, int c) {}

[TestCase(1, 2, 3)]
        public void CanConvertStringToDateTimeAsParamArray(params int[] values) {}

[TestCase("1942-10-12", "1942-10-12")]
        public void CanConvertStringToDateTimeAsParamArray(DateTime a, DateTime b) {}


This does not:
csharp
[TestCase("1942-10-12", "1942-10-12")]
        public void CanConvertStringToDateTimeAsParamArray(params DateTime[] dt) {}
`</Code>
    <Description>I noticed this while working on #3053

It looks like in the `TestCaseAttribute`, while we support passing primitives to a primitives param array and the passing of strings as values to single `DateTime`/`TimeSpan` values, we don't support the passing of strings to a param array of `DateTime`s or `TimeSpan`s.

So while these work:

``</Description>
  </Issue>
  <Issue>
    <IssueID>2879</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Higher precision for ITestResult DateTime fields</Title>
    <CreatedDate>31/05/2018</CreatedDate>
    <ClosedDate>01/06/2018</ClosedDate>
    <IssueLabels />
    <Description>Hello!

This is not an issue but a feature request.
If possible I want to be able to use test result Start and End DateTimes with higher precision. At the moment when I run tests I am getting such `.xml` results:
``

As you can see both `start-time` and `end-time` have format `yyyy-MM-dd HH:mm:ss`.
Is it possible to increase time precision up to microseconds (start using format `yyyy-MM-dd HH:mm:ss.ffffff`)?
At the moment we don't know when exactly test started, so this enhancement will help me to build framework extensions with correct data.

Initially changes for using start and end datetimes were implemented in this pull request:  
This can give an idea of the amount of changes required to do this enhancement.

Thank you</Description>
    <PullRequests />
  </Issue>
  <Issue>
    <IssueID>2877</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>TestCaseSource is created when unrelated test is debugged</Title>
    <CreatedDate>30/05/2018</CreatedDate>
    <ClosedDate>07/08/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2877</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>2877</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Hello. 
I apologize in advance if there is a documentation for this problem or a similar issue, but I could not find anything.

I do not know how to explain our problem without example so I will use a simplified example:

Lets say that in Test project we have two test classes: GoodTestClass and NaughtyTestClass. They are in different files and folders and have nothing in common. Both classes have TestFixture property. 
GoodTestClass has following code:
``

What is happening is that when we debug GoodTest, NaughtyTestCases are created also and data is written in database. TearDown from NaughtyTestCase is not called and data remains in database. 
Of course, this isn't behavior we would like. 

Why is NaughtyTestClass affected by something that is happening to GoodTestClass? What is the connection between them? How do we stop this behavior so that NaughtyTestClass is only created when tests from that class are run or debug? 

We use NUnit 2.6.4.

If you need any more explanations, let me know. 

Thanks :) </Description>
  </Issue>
  <Issue>
    <IssueID>2876</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>2876</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Implement Discovery-time filtering for NUnitLite</Title>
    <CreatedDate>29/05/2018</CreatedDate>
    <ClosedDate>09/07/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2876</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:feature</Name>
        <IssueID>2876</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>2876</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Issue #2867 asks for us to avoid running TestCaseSource code when the generated tests would be excluded by the filter that has been provided.

As a start on this, this issue will make changes to the framework and implement discover-time filtering that is available when running NUnitLite. This is a handy way to work since the framework and nunitlite are all part of the same repository and solution.</Description>
  </Issue>
  <Issue>
    <IssueID>2875</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Questions about custom attributes and SetUp/TearDown</Title>
    <CreatedDate>29/05/2018</CreatedDate>
    <ClosedDate>30/05/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2875</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>2875</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>csharp
    class Sample
    {
        [Test]
        [My]
        public void Test()
        {
            Console.WriteLine("!!! I'm just a test");
        }

        [SetUp]
        public void SetUp()
        {
            Console.WriteLine("I'm SetUp");
        }

        [TearDown]
        public void TearDown()
        {
            Console.WriteLine("I'm TearDown");
        }

        [OneTimeSetUp]
        public void OneTimeSetup()
        {
            Console.WriteLine("I'm OneTimeSetUp");
        }

        [OneTimeTearDown]
        public void OneTimeTearDown()
        {
            Console.WriteLine("I'm OneTimeTearDown");
        }
    }


    public class MyAttribute : Attribute, ITestAction
    {
        public void BeforeTest(ITest test)
        {
            Console.WriteLine("MyAttribute before test");
        }

        public void AfterTest(ITest test)
        {
            Console.WriteLine("MyAttribute after test");
            var method = (TestMethod) test;
            var fixture = (TestFixture) test.Parent;
            Console.WriteLine($"Setup count = {method.SetUpMethods.Length}\n" +
                              $"Teardown count = {method.TearDownMethods.Length}\n" +
                              $"OnetimeSetup count = {fixture.OneTimeSetUpMethods.Length}\n" +
                              $"OneTimeTearDown count = {fixture.OneTimeTearDownMethods.Length}");
        }

        public ActionTargets Targets =&gt; ActionTargets.Test;
    }
`</Code>
    <Description>I have the following code:
``

When I execute it I get:

&gt; I'm OneTimeSetUp
&gt; I'm SetUp
&gt; MyAttribute before test
&gt; !!! I'm just a test
&gt; MyAttribute after test
&gt; **Setup count = 0**
&gt; **Teardown count = 0**
&gt; **OnetimeSetup count = 1**
&gt; **OneTimeTearDown count = 1**
&gt; I'm TearDown
&gt; I'm OneTimeTearDown

So the question are:

1. Why SetUpMethods and TearDownMethods count is equal to 0 now?
2. Is there a way to execute SetUp/TearDown in BeforeTest/AfterTest?

Thanks in advance,
Nick</Description>
  </Issue>
  <Issue>
    <IssueID>2874</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>idea: allow anonymous objects instead of object[] for TestCaseSource</Title>
    <CreatedDate>29/05/2018</CreatedDate>
    <ClosedDate>18/05/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>design</Name>
        <IssueID>2874</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:idea</Name>
        <IssueID>2874</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>If we have several test method parameters, and multiple parameters are present, it could be more readable to add names for arguments (without separate class creation). 
So instead of:
``</Description>
  </Issue>
  <Issue>
    <IssueID>2872</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Unsafe to use TestContext.CurrentContext.TestDirectory</Title>
    <CreatedDate>26/05/2018</CreatedDate>
    <ClosedDate>27/05/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>confirm</Name>
        <IssueID>2872</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>2872</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>When using `TestContext.CurrentContext.TestDirectory` several things can happen:

* `CurrentContext` is null
* some regular exception
* `SocketException` is thrown

The first two can be worked around, but the last one cannot be caught in a try/catch when calling `TestDirectory`. I'm not sure why, but my suspicion is that the error is thrown asynchronously. 

I think that generally speaking, property gettors should either return null (if there's reason for such a case) or return a legal value, but they should not raise exceptions. Even more so when they are static, as this leads to hard-to-debug exceptions in static cctors.

This behavior is most apparent when running tests with `nunit3-console.exe`, where tests are loaded through `TestSourceAttribute` which require access to resources relative to the local directory. In such cases it makes sense to use `TestContext.CurrentContext.TestDirectory`, as other methods are unreliable, but unfortunately, the preferred method is unsafe and may crash your whole test-session.

Extra info:

The stacktrace of the `SocketException`, which is often thrown, but not always in the mentioned scenarios, is as follows:

``</Description>
  </Issue>
  <Issue>
    <IssueID>2871</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Start-time and end-time attributes with default time cause TFS failure</Title>
    <CreatedDate>25/05/2018</CreatedDate>
    <ClosedDate>25/05/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:duplicate</Name>
        <IssueID>2871</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>TFS build has a Publish Test Results task which understands the NUnit 3 result format. It fails with the message, “Failed to publish test results: The value for the StartedDate property is not within the permissible values for it.”
I found a similar-looking issue ( and it appears as though TFS chokes on the `start-time="0001-01-01 00:00:00Z" end-time="0001-01-01 00:00:00Z"` for each skipped test. (Skipped, as intended, because the tests are marked `[Explicit]`.)

I just tried a quick-n-dirty XSL transform which removed all start-time or end-time attributes with the value `0001-01-01 00:00:00Z` and TFS's Publish Test Results worked beautifully!

``

So while this is definitely something that could be improved in TFS build, I can't help but wonder how much sense it makes to be outputting `start-time="0001-01-01 00:00:00Z" end-time="0001-01-01 00:00:00Z"` in the first place. Could we change our XML-writing code so that if StartTime and EndTime are default, we do not emit the attributes?

Our [`ITestResult.StartTime` and `EndTime` properties]( are not nullable, so they default to `0001-01-01 00:00:00Z`.

</Description>
  </Issue>
  <Issue>
    <IssueID>2869</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>TestCaseSource breaks when using static classses, AppDomains, and Assemblies</Title>
    <CreatedDate>24/05/2018</CreatedDate>
    <ClosedDate>18/05/2020</ClosedDate>
    <IssueLabels />
    <Description>I currently have a static class which hosts a method to dynamically loads assemblies into the current AppDomain. In these assemblies, there are implimentations of an interface which is defined in a seperate assembly which is referenced by the test project. I would like the TestCaseSource function to generate an Enumerator of objects which are defined in the dynamically loaded assemblies.

The problem is that when I load the assemblies, regardless of TestCaseData being returned by the enumerator ( eg. return yield TestCaseData(12)  ) the tests are not created and no errors are reported.

I think this is potentially a bug in the framework?</Description>
  </Issue>
  <Issue>
    <IssueID>2868</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Behavior-driven development using nunit</Title>
    <CreatedDate>23/05/2018</CreatedDate>
    <ClosedDate>23/05/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:wontfix</Name>
        <IssueID>2868</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Hi guys,

Is there any plan to support Behavior-driven development using nunit, for example supporting Gherkin

language.

Regards,
</Description>
  </Issue>
  <Issue>
    <IssueID>2867</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Skip executing TestCaseSources for tests which are not included in the filter</Title>
    <CreatedDate>22/05/2018</CreatedDate>
    <ClosedDate>11/07/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2867</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:idea</Name>
        <IssueID>2867</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I'm positive we already have an issue tracking this, but I've been looking across the whole org.

A work project has grown to the point where any test run incurs just shy of nine seconds of test discovery time before any tests are actually executed. I profiled and found the nine seconds to be dominated by the execution and iteration of TestCaseSources.
Some of the tests are integration tests using test case sources which query real databases to determine the number and parameters of test cases to generate. My intuition is that we don't incur that cost, so long as we don't run tests in the Integration category.

A workaround may be to split the integration tests into a separate assembly, but the same nine-second wait happens if I want to continually run a single unrelated integration test as part of my inner-loop development. (Think NCrunch, or ReSharper in continuous coverage mode.) So this workaround doesn't alleviate a lot of the problem.</Description>
  </Issue>
  <Issue>
    <IssueID>2866</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Visual Studio Test Explorer displays duplicate (and non-functional) test cases for parameterized tests in certain cases (see description)</Title>
    <CreatedDate>22/05/2018</CreatedDate>
    <ClosedDate>22/05/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:duplicate</Name>
        <IssueID>2866</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I have discovered that, when using a TestCaseSource which returns a collection of arrays of type X, where X contains a ToString override which surrounds its contents (if any) with parentheses, the Visual Studio Test Explorer will display an extra, greyed out test without parameters specified which will not be runnable:
![broken_test_discovery](

I've done my best to distill a repro case:

``
Note that if the test method is changed to take a single parameter (with a 1D array TestCaseSource), the issue will not reproduce.  Note also that by removing either of the parentheses around the SomeDummyObject.ToString method, the issue will not reproduce.

This issue does not appear to manifest when using the console runner.</Description>
  </Issue>
  <Issue>
    <IssueID>2864</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Unable to pass parameters (or GET parameters) based on test case to ValueSource functions</Title>
    <CreatedDate>17/05/2018</CreatedDate>
    <ClosedDate>18/05/2020</ClosedDate>
    <IssueLabels />
    <Description>We would like to be able to write a single function which returns ValueSource IEnumerable data, but takes into account some information (such as a custom attribute) or else just takes a parameter from the test case. 

Example: We have a "valid login" test case, and an "invalid login" test case. Takes types of accounts, and grabs the credentials from an xml document, then tries to log in with username and password. Simple. However, the "valid" login function works with four accounts, and the "invalid" login works with different accounts. We would also like the ability to configure which accounts that tests get run against in the config file. 

So if validLoginTest runs against account types A, B, C, and D, the function would take (pseudocode):

``

Alternatively, the function could pull from a custom attribute above the test, or any other way you see fit for us to grab the variable. But we can not see a way to pass any variable or config setting to these functions on a per test basis. 

Thanks in advance for any guidance.</Description>
  </Issue>
  <Issue>
    <IssueID>2862</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Cannot combine Throws.Something Constraints with And/Or Constraint</Title>
    <CreatedDate>15/05/2018</CreatedDate>
    <ClosedDate>18/05/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:idea</Name>
        <IssueID>2862</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>The following code:
``

Fails with error:
`Message: System.ArgumentNullException : Value cannot be null.
Parameter name: Failure`

I suppose that's because And/Or Constraints don't have `ApplyTo&lt;TActual&gt;(ActualValueDelegate&lt;TActual&gt; del)` overriden.

We could provide overrides in And/Or constraints, but that would lead to delegate being executed twice - for each constraint.
Probably that's not very cool.</Description>
  </Issue>
  <Issue>
    <IssueID>2858</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Provide .NET Standard migration path from Framework 4.6.2</Title>
    <CreatedDate>14/05/2018</CreatedDate>
    <ClosedDate>15/05/2018</ClosedDate>
    <IssueLabels />
    <Description>Although I am displeased with the lack of ``WinForms``/``WPF`` migration path at the moment, I finally decided that it was time to begin migrating to ``.NET Standard``. With either ``2.6.4`` or ``2.6.5``, I get this:

``

This is causing a break in migration to ``.NET Standard 2.x`` and I am unable to move forward with my unit testing.

This will provide the seamless backwards compatible migration path for projects targeting ``Framework 4.6.2`` or better.

Ironically, this might also be an opportune moment for me to reconsider my attitude towards ``Xunit``, ``Combinatorial``, etc.

Anyway, let me know what y'all decide to do re: ``Framework 4.6.2`` and/or ``.NET Standard 2.0`` (recommended).</Description>
  </Issue>
  <Issue>
    <IssueID>2857</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>NUnit documentation incorrect?</Title>
    <CreatedDate>13/05/2018</CreatedDate>
    <ClosedDate>14/05/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2857</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Within the NUnit documentation at  is this paragraph in conflict with the closing of the issue at  and 

_Parallel execution is supported by the NUnit framework on desktop .NET runtimes. It is not supported in our Portable or .NET Standard builds at this time, although the attributes are recognized without error in order to allow use in projects that build against multiple targets._</Description>
  </Issue>
  <Issue>
    <IssueID>2855</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>Dreamescaper</FixedById>
        <IssueID>2855</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Is.Ordered - show item where order breaks in error message</Title>
    <CreatedDate>11/05/2018</CreatedDate>
    <ClosedDate>22/08/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:idea</Name>
        <IssueID>2855</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Currently NUnit only logs actual collection in error message. That's fine if we have 3 items, but not really great for 200, especially due to that only several first items are displayed.
Would be really great to show where order actually breaks somehow:

Something like this, maybe?
``
)</Description>
  </Issue>
  <Issue>
    <IssueID>2854</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>Dreamescaper</FixedById>
        <IssueID>2854</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Has.All.../Has.None... - show non-matching items in error message</Title>
    <CreatedDate>11/05/2018</CreatedDate>
    <ClosedDate>03/06/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2854</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>2854</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Currently NUnit only logs actual collection in error message. That's fine if we have 3 items, but not really great for 200, especially due to that only several first items are displayed.
Would be really great to log non-matching items as well, something like:
``

That would require to traverse through all collection though, even if the first checked item does not match, but I suppose that's OK, considering that it might happen only for failing test.</Description>
  </Issue>
  <Issue>
    <IssueID>2853</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Failure when unit testing code containing code dom compilation.</Title>
    <CreatedDate>11/05/2018</CreatedDate>
    <ClosedDate>18/05/2020</ClosedDate>
    <IssueLabels />
    <Code>csharp
CompilerParameters cp = new CompilerParameters();

cp.GenerateExecutable = false;
cp.GenerateInMemory = true;

cp.TreatWarningsAsErrors = false;
cp.ReferencedAssemblies.Add("Employee.dll");
cp.ReferencedAssemblies.Add("Person.dll");

CompilerResults cr = provider.CompileAssemblyFromSource(cp, "someCode");
if (cr.Errors.Count &gt; 0)
{..}
`</Code>
    <Description>Environment:  Nunit Framework version: 3.9, NUnit GUI: 0.6.0, VS 2017, .NET Framework 4.7.1 Full Version.

Scenario: As part of the logic, the system generates a dynamic assembly as follows.
``

I open the Unit Test Assembly in NUnit-Gui-0.6.0 and test a method which ends up calling the above code as part of the business logic.

Issue: Above Error Count is greater than 0 and has the following messages:

`error CS0006: Metadata file 'Person.dll' could not be found
error CS0006: Metadata file 'Employee.dll' could not be found`

I have verified that these assemblies are present in the bin directory along with the Unit Test DLL. This code works in regular application workflow but not in NUnit 3.9.

Not sure if this is a bug in NUnit 3.* or an application issue.

Regards,

Iftikhar.</Description>
  </Issue>
  <Issue>
    <IssueID>2852</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>NUnit3 Is.EquivalentTo in certain case performs much worse than for NUnit2</Title>
    <CreatedDate>11/05/2018</CreatedDate>
    <ClosedDate>18/05/2020</ClosedDate>
    <IssueLabels />
    <Code>csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Diagnostics;
using NUnit.Framework;

namespace NUnitTest1
{
    [TestFixture]
    public class TestClass1
    {
        [Test]
        public void TestEquivalentToPerformance()
        {
            const int listLength = 20000;
            var expected = Enumerable.Range(0, listLength).Select(i =&gt; $"inte{i}");
            var actual = expected.ToList();
            var sw = Stopwatch.StartNew();
            Assert.That(actual.SequenceEqual(expected));
            sw.Stop();
            Console.WriteLine($"SequenceEqual\t{sw.Elapsed}.");
            sw.Restart();
            Assert.That(expected, Is.EquivalentTo(actual));
            sw.Stop();
            Console.WriteLine($"Is.EquivalentTo\t{sw.Elapsed}.");
            actual = actual.OrderByDescending(e =&gt; e).ToList();
            Assert.False(actual.SequenceEqual(expected));
            sw.Restart();
            Assert.That(new HashSet&lt;string&gt;(actual).SetEquals(expected));
            sw.Stop();
            Console.WriteLine($"SetEquals\t{sw.Elapsed}.");
            sw.Restart();
            Assert.That(expected, Is.EquivalentTo(actual));
            sw.Stop();
            Console.WriteLine($"Is.EquivalentTo reordered\t{sw.Elapsed}.");
        }
    }
}
`</Code>
    <Description>The following testing code being executed for the NUnit 3.10.1 framework 

``

outputs:

SequenceEqual	00:00:00.0076299.
Is.EquivalentTo	00:00:25.4525447.
SetEquals			00:00:00.0096878.
Is.EquivalentTo reordered	00:00:12.4085114.

The same code being executed for the NUnit 2.6 framework outputs:

SequenceEqual	00:00:00.0071261.
Is.EquivalentTo	00:00:00.1143779.
SetEquals	                00:00:00.0104875.
Is.EquivalentTo reordered	00:00:16.7547591.

In my experience a comparison of identical sequences happens quite often. For this case nunit3 implementation for Is.EquivalentTo spends 25.45 sec. to give the expected result versus 0.11 sec. spent by nunit2 framework. For the sequences in reverse order nunit3 performs slightly better ( 12.4 sec vs 16.7 sec ), but IMHO it does not compensate slow performance for the first case.
</Description>
  </Issue>
  <Issue>
    <IssueID>2850</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>For a TestCase setting TestName means the TestCase is ignored in dotnet core</Title>
    <CreatedDate>11/05/2018</CreatedDate>
    <ClosedDate>15/05/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>2850</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>It appears setting a TestCase TestName to a non-null value prevents the TestCase from being evaluated as a test.

I just cloned NUnit3 master, and added this test to TestCaseAttributeTests.cs

``

If all the TestCases have a TestName set, then the test is not picked up at all:
`No test is available`

TBH I'm not sure whether this is an NUnit issue or a problem with dotnet test...</Description>
  </Issue>
  <Issue>
    <IssueID>2848</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Assert.ThrowsAsync and friends do not catch AssertionException</Title>
    <CreatedDate>09/05/2018</CreatedDate>
    <ClosedDate>18/05/2020</ClosedDate>
    <IssueLabels />
    <Code>csharp
Assert.ThrowsAsync&lt;AssertionException&gt;(async () =&gt;Assert.AreEqual(1, 0));


csharp
Assert.That(async () =&gt; Assert.AreEqual(1, 0), Throws.TypeOf&lt;AssertionException&gt;());

csharp
Assert.CatchAsync&lt;AssertionException&gt;(async () =&gt; Assert.AreEqual(1, 0));

But in 3.10 all fail with the internal assertion:

text
  Expected: 1
  But was:  0
`</Code>
    <Description>Following code used to work in 3.9:

``

The equivalent synchronous code works as expected.</Description>
  </Issue>
  <Issue>
    <IssueID>2845</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Underscores for private fields?</Title>
    <CreatedDate>08/05/2018</CreatedDate>
    <ClosedDate>09/05/2018</ClosedDate>
    <IssueLabels />
    <Code>cs
var all = new List&lt;FieldInfo&gt;();
var underscore = new List&lt;FieldInfo&gt;();

foreach (var dll in Directory.GetFiles(@"C:\Users\Joseph\Desktop\net45", "*.dll"))
{
    var a = Assembly.LoadFile(dll);

    foreach (var type in a.DefinedTypes)
    {
        if (type.IsDefined(typeof(CompilerGeneratedAttribute))) continue;
        foreach (var field in type.GetFields(BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.Instance))
        {
            if ((field.Attributes &amp; FieldAttributes.FieldAccessMask) != FieldAttributes.Private) continue;
            if (field.IsDefined(typeof(CompilerGeneratedAttribute))) continue;
            all.Add(field);
            if (field.Name[0] == '_') underscore.Add(field);
        }
    }
}

Console.WriteLine($"{underscore.Count}/{all.Count} ({underscore.Count / (double)all.Count:p1})");
`</Code>
    <Description>Do we like or dislike prefixing with underscores?

Only 376 of the 1106 private, non-compiler-generated fields declared in this repository begin with underscores. That is 34.0%. Our coding standard has been at odds with the majority of what you take in when you look through NUnit source and with the majority of C# code in general.
It's really hard to be consistent while writing and while reviewing. I just saw a field in one of my most recent PRs that is missing the underscore, added right under a field with an underscore, and no one (including me) noticed.

However, we recently decided to loosen the coding standard so that private and internal fields naming is totally up to the preferences of the team of each project. (  This project's team is led by Rob.

My second paragraph may have betrayed my bias, but really I'm happy to go either way and I don't particularly want to influence you. The reason I ask is that I have an .editorconfig and DotSettings ready which generate fields with underscores (without creating any new diagnostics). I could just as easily swap the order of preference around though, so I'd like to solicit your preferences.

&lt;details&gt;

I ran this script on all DLLs in [

``
&lt;/details&gt;</Description>
  </Issue>
  <Issue>
    <IssueID>2844</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Tag a test to have it run but if it fails, but not fail entire test run</Title>
    <CreatedDate>04/05/2018</CreatedDate>
    <ClosedDate>18/05/2020</ClosedDate>
    <IssueLabels />
    <Description>If a test fails due to an issue in the software (an issue that will eventually get fixed) and not an issue with the test, we would like to be able to tag the test to have it still run but not fail the entire test run and log the results somewhere.</Description>
  </Issue>
  <Issue>
    <IssueID>2842</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>jnm2</FixedById>
        <IssueID>2842</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Supporting inheritance of Assert and related classes</Title>
    <CreatedDate>02/05/2018</CreatedDate>
    <ClosedDate>15/05/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2842</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>design</Name>
        <IssueID>2842</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>2842</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>In  the subject came up of allowing `Assert` and other `*Assert` classes to be extended through inheritance the way we do for `Is`, `Iz`, `Does`, `Has`, `Throws`, and `Contains`.

A past team, before NUnit 3, had decided that `Assert` should be inheritable:



@CharliePoole asked for us to reconsider these classes, keeping in mind that, “The current team has never actually **decided** that we want people to be able to do this.”

➡ What do I mean by “supporting inheritance of Assert,” since it is currently inheritable? From my best understanding of  I mean keeping it in the list of classes we test to ensure inheritance which we started in 
</Description>
  </Issue>
  <Issue>
    <IssueID>2840</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>nunit3-console crashes at end of multi-fixture test run</Title>
    <CreatedDate>01/05/2018</CreatedDate>
    <ClosedDate>18/05/2020</ClosedDate>
    <IssueLabels />
    <Description>When a multi-fixture test is run using nunit3-console via the following command, the tests are all executed, but the nunit3-console executable crashes at the end and fails to write out the results of the run.

This does NOT occur when any individual test fixture is run, but ONLY when running them all.

``

Framework versions:

NUnit: 3.7.1
NUnit.ConsoleRunner: 3.7.0/3.8.0
NUnit3TestAdapter: 3.6.0
Selenium.WebDriver.IEDriver: 3.8.0
</Description>
  </Issue>
  <Issue>
    <IssueID>2837</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>DictionaryContainsKeyConstraint behaviour is inconstant with Dictionary.ContainsKey when the dictionary uses a custom Comparer</Title>
    <CreatedDate>30/04/2018</CreatedDate>
    <ClosedDate>29/08/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2837</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>2837</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>2837</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>If you have a dictionary that was created with a custom comparer then the DictionaryContainsKeyConstraint does not work as expected.

``</Description>
  </Issue>
  <Issue>
    <IssueID>2836</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>2836</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>NUnit.Framework.Does cannot be extended</Title>
    <CreatedDate>30/04/2018</CreatedDate>
    <ClosedDate>01/05/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>2836</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>2836</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>The documentation for custom constraints demonstrates incorporating custom constraints into the fluent syntax like this:

&gt; Provide a static class patterned after NUnit's Is class, with properties or methods that construct your custom constructor. If you like, you can even call it Is and extend NUnit's Is, provided you place it in your own namespace and avoid any conflicts.

That works fine for NUnit.Framework.Is, but NUnit.Framework.Does is marked as static, and so cannot be extended in the same way.

Given that it serves basically the same role and is only really there to make the assertion read more nicely, I think it should also be extendable, for the exact same reasons that Is is extendable.</Description>
  </Issue>
  <Issue>
    <IssueID>2832</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>NUnitEngineException : Unable to acquire remote process agent</Title>
    <CreatedDate>27/04/2018</CreatedDate>
    <ClosedDate>27/06/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:duplicate</Name>
        <IssueID>2832</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>confirm</Name>
        <IssueID>2832</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>
Unhandled Exception: NUnit.Engine.NUnitEngineException: Failed to start remote test agent.
   at NUnit.Engine.Services.TestAgency.OnAgentExit(Object sender, EventArgs e)
   at System.Diagnostics.Process.OnExited()
   at System.Diagnostics.Process.RaiseOnExited()
   at System.Threading.ExecutionContext.RunInternal(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state, Boolean preserveSyncCtx)
   at System.Threading._ThreadPoolWaitOrTimerCallback.PerformWaitOrTimerCallback(Object state, Boolean timedOut)


And after a few more seconds this is shown:


1) Error :
NUnit.Engine.NUnitEngineException : Unable to acquire remote process agent
--NUnitEngineException
   at NUnit.Engine.Runners.ProcessRunner.CreateAgentAndRunner()
   at NUnit.Engine.Runners.ProcessRunner.RunTests(ITestEventListener listener, TestFilter filter)
`</Code>
    <Description>I'm trying to start some tests with nunit3-console.exe (v3.8.0) on a virtual machine running Windows 10 (x64) but before any tests get executed NUnit stops. I get the following error messages:

``

I recently added the flag --_x86_ to NUnit and that's when this issue started. I added the flag because I also added an external file (_Microsoft Exression Encoder_) to my test project, and it seems to be x86 only. 
I read (on _Stackoverflow_ I think) that using --_inprocess_ works. I used to have that flag but it is not compatible with --_x86_. So I can't get it to work no matter how I try.

This is the command I use to run NUnit: `nunit3-console.exe C:\...\GUITests.dll --x86 --where "cat == .NIGHTLY" --result="C:\...\Logs\TestResult.xml;format=nunit2"`</Description>
  </Issue>
  <Issue>
    <IssueID>2831</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>jnm2</FixedById>
        <IssueID>2831</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Regular "BusyExecIdle after 200 milliseconds delay" CI failures</Title>
    <CreatedDate>27/04/2018</CreatedDate>
    <ClosedDate>28/04/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:build</Name>
        <IssueID>2831</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>2831</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>
1) Failed : NUnit.Framework.Internal.Execution.TestWorkerTests.BusyExecuteIdleEventsCalledInSequence
  Expected: "BusyExecIdle" after 200 milliseconds delay
  But was:  &lt;string.Empty&gt;
   at NUnit.Framework.Internal.Execution.TestWorkerTests.BusyExecuteIdleEventsCalledInSequence() in C:\projects\nunit\src\NUnitFramework\tests\Internal\TestWorkerTests.cs:line 67
`</Code>
    <Description>This is responsible for the last couple dozen times I read through the AppVeyor logs to figure out why a branch was failing to build. Always seems to be net35.

``

Can we change this to `10_000`? If it succeeds it's instantaneous. If it fails, all we care about is not hanging for minutes on end.</Description>
  </Issue>
  <Issue>
    <IssueID>2829</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>mikkelbu</FixedById>
        <IssueID>2829</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Obsoletion warning for DataAttribute</Title>
    <CreatedDate>26/04/2018</CreatedDate>
    <ClosedDate>26/06/2018</ClosedDate>
    <IssueLabels />
    <Code>cs
[Obsolete("Holdover from NUnit v2. Please inherit from Attribute or PropertyAttribute and " +
          "implement IParameterDataSource.", error: false)]
`</Code>
    <Description>[Quoting Charlie,](


&gt; DataAttribute is a class that was somewhat important in earlier versions of NUnit. Currently, it's a holdover and is not used in the code at all. We left it in the code to avoid needlessly breaking anything.

This seems like a good thing to document in the source. Can we document this using an obsoletion warning so that people who use it become aware?

``
</Description>
  </Issue>
  <Issue>
    <IssueID>2827</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Cannot load 'NUnit.Framework.TimeoutAttribute' when attempting to programmatically run NUnit tests in a ASP.NET Core 2 app</Title>
    <CreatedDate>26/04/2018</CreatedDate>
    <ClosedDate>03/06/2019</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:answered</Name>
        <IssueID>2827</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>2827</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>
public class NUnitRunner
{
	// Using TestEngine class directly because nunit.engine.netstandard doesn't have a TestEngineActivator
	private ITestEngine Engine { get; } = new TestEngine();
	public TestPackage TestPackage { get; }
	public ITestRunner TestRunner { get; }

	public NUnitRunner(string dllPath) {
		TestPackage = new TestPackage(dllPath);
		TestRunner = Engine.GetRunner(TestPackage);
	}

	public XmlNode Run(ITestEventListenerlistener, TestFilter filter)
	{
		return TestRunner.Run(listener, filter);
	}
}


When invoking the Run method I get the following stack trace in the resulting XML:


An exception was thrown while loading the test.&amp;#xD;&amp;#xA;System.TypeLoadException: Could not load type 'NUnit.Framework.TimeoutAttribute' from assembly 'nunit.framework, Version=3.10.1.0, Culture=neutral, PublicKeyToken=2638cd05610744eb'.&amp;#xD;&amp;#xA;
   at System.ModuleHandle.ResolveType(RuntimeModule module, Int32 typeToken, IntPtr* typeInstArgs, Int32 typeInstCount, IntPtr* methodInstArgs, Int32 methodInstCount, ObjectHandleOnStack type)&amp;#xD;&amp;#xA;
   at System.ModuleHandle.ResolveTypeHandleInternal(RuntimeModule module, Int32 typeToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext)&amp;#xD;&amp;#xA;
   at System.Reflection.RuntimeModule.ResolveType(Int32 metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments)&amp;#xD;&amp;#xA;
   at System.Reflection.CustomAttribute.FilterCustomAttributeRecord(CustomAttributeRecord caRecord, MetadataImport scope, Assembly&amp;amp; lastAptcaOkAssembly, RuntimeModule decoratedModule, MetadataToken decoratedToken, RuntimeType attributeFilterType, Boolean mustBeInheritable, Object[] attributes, IList derivedAttributes, RuntimeType&amp;amp; attributeType, IRuntimeMethodInfo&amp;amp; ctor, Boolean&amp;amp; ctorHasParameters, Boolean&amp;amp; isVarArg)&amp;#xD;&amp;#xA;
   at System.Reflection.CustomAttribute.GetCustomAttributes(RuntimeModule decoratedModule, Int32 decoratedMetadataToken, Int32 pcaCount, RuntimeType attributeFilterType, Boolean mustBeInheritable, IList derivedAttributes, Boolean isDecoratedTargetSecurityTransparent)&amp;#xD;&amp;#xA;
   at System.Reflection.CustomAttribute.GetCustomAttributes(RuntimeType type, RuntimeType caType, Boolean inherit)&amp;#xD;&amp;#xA;
   at NUnit.Compatibility.MemberInfoExtensions.GetAttributes[T](MemberInfo info, Boolean inherit) in C:\src\nunit\nunit\src\NUnitFramework\framework\Compatibility\ReflectionExtensions.cs:line 427&amp;#xD;&amp;#xA;
   at NUnit.Framework.Internal.TypeWrapper.GetCustomAttributes[T](Boolean inherit) in C:\src\nunit\nunit\src\NUnitFramework\framework\Internal\TypeWrapper.cs:line 194&amp;#xD;&amp;#xA;
   at NUnit.Framework.Internal.Builders.DefaultSuiteBuilder.GetFixtureBuilderAttributes(ITypeInfo typeInfo) in C:\src\nunit\nunit\src\NUnitFramework\framework\Internal\Builders\DefaultSuiteBuilder.cs:line 135&amp;#xD;&amp;#xA;
   at NUnit.Framework.Internal.Builders.DefaultSuiteBuilder.BuildFrom(ITypeInfo typeInfo) in C:\src\nunit\nunit\src\NUnitFramework\framework\Internal\Builders\DefaultSuiteBuilder.cs:line 77
``</Code>
    <Description>I seem to have stumbled into some trouble trying to run tests programmatically. I have a small class which is designed to handle loading a dll with NUnit tests in it and running those tests when given a filter. Class looks like this: 

``

Here's some info about my environment: 
Target Framework: .NET Core 2.0
NUnit version: 3.10.1
nunit.engine.netstandard version: 3.7.0


I was told to use the `nunit.engine.netstandard` package rather than the `nunit.engine.api` package because it works better with .NET Core.

I feel like this isn't a bug in the NUnit framework code but instead a mis-configured environment. Figured I should make an issue ticket anyways to be safe. </Description>
  </Issue>
  <Issue>
    <IssueID>2826</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Is.EquivalentTo is slow on large ordered collections when running on .NET Framework</Title>
    <CreatedDate>26/04/2018</CreatedDate>
    <ClosedDate>26/04/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:duplicate</Name>
        <IssueID>2826</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>After updating from NUnit 3.9.0 to 3.10.1 the timeout limit on tests of a custom ordered set implementation is broken for larger sets (1000 items). The tests look like this one:

``

It turns out that the Is.EquivalentTo constraint caused delays of more than 100ms when running tests for .NET Framework, whereas they pass when running on .NET Core 2.0.
</Description>
  </Issue>
  <Issue>
    <IssueID>2823</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>SetUp failed for test fixture - Array was not a one-dimensional array.  Issue seems related to byte[,] method parameters</Title>
    <CreatedDate>25/04/2018</CreatedDate>
    <ClosedDate>28/04/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2823</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>
SetUp failed for test fixture MyFixture
An exception was thrown while loading the test.
System.ArgumentException: Array was not a one-dimensional array.
   at System.ThrowHelper.ThrowArgumentException(ExceptionResource resource)
   at System.Array.GetValue(Int32 index)
   at NUnit.Framework.Internal.TestNameGenerator.NameFragment.GetDisplayString(Object arg, Int32 stringMax) in C:\src\nunit\nunit\src\NUnitFramework\framework\Internal\TestNameGenerator.cs:line 241
   at NUnit.Framework.Internal.TestNameGenerator.ArgListFragment.GetText(MethodInfo method, Object[] arglist) in C:\src\nunit\nunit\src\NUnitFramework\framework\Internal\TestNameGenerator.cs:line 558
   at NUnit.Framework.Internal.TestNameGenerator.GetDisplayName(TestMethod testMethod, Object[] args) in C:\src\nunit\nunit\src\NUnitFramework\framework\Internal\TestNameGenerator.cs:line 93
   at NUnit.Framework.Internal.Builders.NUnitTestCaseBuilder.BuildTestMethod(IMethodInfo method, Test parentSuite, TestCaseParameters parms) in C:\src\nunit\nunit\src\NUnitFramework\framework\Internal\Builders\NUnitTestCaseBuilder.cs:line 89
   at NUnit.Framework.TestCaseSourceAttribute.&lt;BuildFrom&gt;d__22.MoveNext() in C:\src\nunit\nunit\src\NUnitFramework\framework\Attributes\TestCaseSourceAttribute.cs:line 142
   at NUnit.Framework.Internal.Builders.DefaultTestCaseBuilder.BuildFrom(IMethodInfo method, Test parentSuite) in C:\src\nunit\nunit\src\NUnitFramework\framework\Internal\Builders\DefaultTestCaseBuilder.cs:line 144
   at NUnit.Framework.Internal.Builders.NUnitTestFixtureBuilder.AddTestCasesToFixture(TestFixture fixture) in C:\src\nunit\nunit\src\NUnitFramework\framework\Internal\Builders\NUnitTestFixtureBuilder.cs:line 183
   at NUnit.Framework.Internal.Builders.NUnitTestFixtureBuilder.BuildFrom(ITypeInfo typeInfo, ITestFixtureData testFixtureData) in C:\src\nunit\nunit\src\NUnitFramework\framework\Internal\Builders\NUnitTestFixtureBuilder.cs:line 158
   at NUnit.Framework.TestFixtureAttribute.&lt;BuildFrom&gt;d__48.MoveNext() in C:\src\nunit\nunit\src\NUnitFramework\framework\Attributes\TestFixtureAttribute.cs:line 227
   at NUnit.Framework.Internal.Builders.DefaultSuiteBuilder.BuildFrom(ITypeInfo typeInfo) in C:\src\nunit\nunit\src\NUnitFramework\framework\Internal\Builders\DefaultSuiteBuilder.cs:line 80


I'm not sure if this modified example will actually have the issue or not, but my fixture looks similar to this:

Edit (simplifying example)

public class FastUnitTest : BaseCategoryAttribute { }

[TestFixture, FastUnitTest]
public class MyFixture
{

    // note my test has no `[SetUp]`, but seems to be referenced in the stacktrace above

        private static object[] testDataByteArray = new object[]
        {
            new object[]
            {
                "test",
                "another deal",
                new byte[] {1, 2, 3, 4}
            }
        };

        // this test passes with both 3.8.1 and 3.10.1
        [Test]
        [TestCaseSource(nameof(testDataByteArray))]
        public void TestThing(string thing, string anotherString, byte[] multiByte)
        {
            Assert.Pass();
        }

        private static object[] testDataMultiDimensionalByteArray = new object[]
        {
            new object[]
            {
                "test",
                "another deal",
                new byte[,] { { 1, 2 }, { 2, 3 } }
            }
        };

        // this test passes only on 3.8.1, it fails (to even set up the fixture) with the stacktrace above of 3.10.1
        [Test]
        [TestCaseSource(nameof(testDataMultiDimensionalByteArray))]
        public void TestThingMultiDimension(string thing, string anotherString, byte[,] multiByte)
        {
            Assert.Pass();
        }
}
`</Code>
    <Description>I'm in the process of updating from `3.8.1` to `3.10.1` and I'm having an issue where testfixtures that pass in 3.8.1, fail to "SetUp" in 3.10.1.

R# test runner refuses to even display the fixture sometimes, and when it does, test results are always "inconclusive, test not run".

I only discovered this issue for this particular fixture because i received the stacktrace (below) when running `dotnet test` from the command line.

Here's the stacktrace:

``

Any thoughts?  </Description>
  </Issue>
  <Issue>
    <IssueID>2822</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>jnm2</FixedById>
        <IssueID>2822</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Setting default static readonly and constant field naming conventions</Title>
    <CreatedDate>24/04/2018</CreatedDate>
    <ClosedDate>03/05/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2822</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:docs</Name>
        <IssueID>2822</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>cs
private static readonly MethodInfo GenericMethodInstantiation;
internal const string Foo = "foo";
`</Code>
    <Description>This repo is configured to not check private or constant fields for style, so VS and ReSharper default to private/internal static readonly fields and constant fields being Pascal-cased. Especially in an age where I use IDEs to generate most of my fields, would we accept PRs which follow these defaults?

``

➡ If either of the answers is no, we should alter our editorconfig and DotSettings so that contributors like me aren't spending their time constantly fixing this.

➡ If either of the answers is yes, we should add an exception to  for `static readonly` or `const` fields because our coding standard is misleading about what we'll really accept in a PR. I lean this way.

Might be worth mentioning that I'm only concerned with this repo and its config files for the time being. Others don't have to follow suit, though they might.</Description>
  </Issue>
  <Issue>
    <IssueID>2821</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>jnm2</FixedById>
        <IssueID>2821</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Save and restore the SynchronizationContext before and after each test case</Title>
    <CreatedDate>23/04/2018</CreatedDate>
    <ClosedDate>20/08/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2821</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>2821</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>2821</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>One of hundreds of tests is causing System.Windows.Forms.Control.CreateHandle() which installs a WindowsFormsSynchronizationContext. When the test worker runs the next and that test happens to be async, the test deadlocks due to the fix for  not being released yet. The problem is, even with the deadlock fix in NUnit, I don't want the next test running with a WindowsFormsSynchronizationContext.

Rather than locating the misbehaving test(s) through trial and error I'd rather have a failure or at least a warning of executing the work item caused an overall change to the thread's SynchronizationContext.Current. That would cause a nice todo list to fall out of my tests.

Or would we prefer to save and restore `SynchronizationContext.Current` with the other global state we save and restore?

Either way, we'd have to make sure that we take the snapshot before any ITestActions and other setups start and only compare or restore after they all tear down.
</Description>
  </Issue>
  <Issue>
    <IssueID>3611</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Properties are shown when --explore:nunit3 is run on entire project, but omitted when using the --where clause</Title>
    <CreatedDate>23/04/2018</CreatedDate>
    <ClosedDate>22/09/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>3611</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>3611</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I am trying to get all the tests that contain a specific category, but I still want to know all the other categories associated to those test fixtures and test cases.

I am using NUnit.ConsoleRunner v3.8.0

If I run 
nunit3-console.exe "C:\Users\SWycoff\Documents\GitHub\myon_qa_suite\myON\myON\bin\Debug\myON.dll" --explore:nunit3

I get test fixtures and test cases with their properties like you see below:

``

This was originally posted in google groups.  Here is the conversation from that.

Charlie said "That seems wrong to me. It looks as if the implementation of the fix for filtered explore output may be using different code from that which creates the output for the unfiltered case. I don't even see the fixture itself (no type="TestFixture")."</Description>
  </Issue>
  <Issue>
    <IssueID>2820</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Throws.ArgumentNullException.With.ParamName("foo")</Title>
    <CreatedDate>23/04/2018</CreatedDate>
    <ClosedDate>23/04/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:wontfix</Name>
        <IssueID>2820</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>2820</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>cs
Assert.That(
    () =&gt; { … },
    Throws.ArgumentNullException.With.Property("ParamName").EqualTo("start"));


What do you think of reducing the typing by leveraging intellisense for this common test?

cs
Assert.That(
    () =&gt; { … },
    Throws.ArgumentNullException.With.ParamName("start"));
`</Code>
    <Description>Rather than writing:

``

And the same for any `Throws.*Exception` where the exception instance is `ArgumentException`?</Description>
  </Issue>
  <Issue>
    <IssueID>2817</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>The active test run was aborted. Reason: &lt;empty&gt;</Title>
    <CreatedDate>20/04/2018</CreatedDate>
    <ClosedDate>26/04/2018</ClosedDate>
    <IssueLabels />
    <Code>
&lt;TargetFramework&gt;netcoreapp2.0&lt;/TargetFramework&gt;
&lt;RuntimeIdentifier&gt;win10-x64&lt;/RuntimeIdentifier&gt;


The command which I run:
`dotnet test --configuration Release`

The output in the Console:

NUnit3TestExecutor converted 1726 of 1726 NUnit test cases
The active test run was aborted. Reason:

Total tests: Unknown. Passed: 323. Failed: 0. Skipped: 0.
Test Run Aborted.
Test execution time: 33.8924 Seconds

with d[etailed] output:

       Done executing task "Microsoft.TestPlatform.Build.Tasks.VSTestTask" -- FAILED.
   1:7&gt;Done building target "VSTest" in project "&lt;snip&gt;.Test.csproj" -- FAILED.
   1:7&gt;Done Building Project "C:\src\&lt;snip&gt;.Test.csproj" (VSTest target(s)) -- FAILED.

Build FAILED.
    0 Warning(s)
    0 Error(s)
`</Code>
    <Description>We have a ASP.NET Core Web Application in which the solution also contains a Test project.
I've run into the problem that when creating a Release build and then trying to run the test against the release build; the Microsoft.TestPlatform.Build.Tasks.VSTestTask fails after running some tests.

We have the following settings:
``
There isn't any reason specified and when I try to run it with `dotnet test` it succeeds.</Description>
  </Issue>
  <Issue>
    <IssueID>2813</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>ITestEventListener</Title>
    <CreatedDate>16/04/2018</CreatedDate>
    <ClosedDate>18/05/2020</ClosedDate>
    <IssueLabels />
    <Description>If you please can update documentation regarding ITestEventListener , or make a short tutorial on how to create a custom addin with nunit 3 , because every try is met with failure, i require that to create a custom reporter.Thanks</Description>
  </Issue>
  <Issue>
    <IssueID>2812</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Unclear how ITestFilterService, TestFilterBuilder, SelectWhere and TestFilter should work</Title>
    <CreatedDate>16/04/2018</CreatedDate>
    <ClosedDate>18/05/2020</ClosedDate>
    <IssueLabels />
    <Description>I have been trying to upgrade some old NUnit 2.6 projects that were hard to upgrade previously because of too many errors, new namespaces (NUnit.Core doesn't exist anymore, nor do the default filters like `NameTestFilter`) and the completely revised ways of writing a test runner yourself.

I've been over  a few times, and tried to search, check StackOverflow and other forums, but can't seem to figure out how this is supposed to work.

The docs explain how to run all tests, by using `TestFilter.Empty`. I searched for other test filters, but can't find any. I figured I had to roll one my own, but got stuck at either listing each and every test myself (time consuming and error prone), or by using `TestFilterBuilder.SelectWhere`. The info on `ITestFilterService` states _"Creates properly formed test filters for use by runners"_, but is silent on how to go about it.

But the latter takes a string and I can't find anywhere what would go into that string.

I hit similar walls with the other interfaces, i.e. `ILogger`, `ITestEventListener`, or `IResultService`. From the source code of the services I don't get much further (i.e., the result service says, on the `format` param: _"The name of the format to be used"_, but doesn't say what formats are supported, or where to find them, or how to make them yourself).

Now I understand that documentation is usually not the top priority, but it would help a lot if there's at least some examples around that are useful (meaning: that go beyond the bare minimum). Being able to host a runner yourself is a strong requirement in quite a few scenarios.</Description>
  </Issue>
  <Issue>
    <IssueID>2811</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Incomplete info when NUnit runner throws BadImageFormatException with "Could not load file or assembly 'nunit.framework' ...."</Title>
    <CreatedDate>16/04/2018</CreatedDate>
    <ClosedDate>18/05/2020</ClosedDate>
    <IssueLabels />
    <Description>Quite often I run into issues related to versions of NUnit and/or other assembly loading issues. To investigate such issues, it is important to have some vital information to even start investigating.

Currently, the error is this (probably forwarded from .NET):

&gt; System.BadImageFormatException : Could not load file or assembly 'nunit.framework' or one of its dependencies. This assembly is built by a runtime newer than the currently loaded runtime and cannot be loaded.

Since both .NET and NUnit use terminology of "runtime", it is unclear whether this error is about the runner of NUnit or of .NET. Also, it is unclear whether there's a dependency failure, or whether the main executable or DLL containing the tests has the wrong version.

I propose that NUnit expands on this error by showing:

* The version of the NUnit loader, engine and runner assemblies (in case one of them is out of sync)
* The version of NUnit or other NUnit libraries (like NUnit engine) used from the loaded project
* Whether the error is because of .NET 4.x version .NET 4.y
* Whether the error is because of bitness (64 bit vs 32 bit)
* What the host is (that is, whether it runs in a console executable, or from TeamCity or another host, probably the `GetEntryAssembly` would return this info)

I heard somewhere that in NUnit 3 the runner and engine are decoupled from the NUnit framework and that those versions do not need to be in line anymore. However, since I am receiving this error, this doesn't account for _all_ situations (which is understandable), but even the more reason to improve on this error.</Description>
  </Issue>
  <Issue>
    <IssueID>2810</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Infinite, non-terminating loop in WorkItemQueue.Dequeue</Title>
    <CreatedDate>16/04/2018</CreatedDate>
    <ClosedDate>18/05/2020</ClosedDate>
    <IssueLabels />
    <Description>Our NUnit Agents are sometimes getting stuck chewing CPU. It seems that this happens due to this code in WorkItemQueue:


It seems that the code can get here when there are no items to dequeue and then unsurprisingly it just gets stuck, chewing 100% CPU while it's there.

In case it helps debugging this, in my thread dump I'm seeing:
``
I'm afraid I can't get an actual thread dump to you as it's quite hard to export things like this outside of our firm, but let me know if you'd like any more info.

(I think what you really want here is a `BlockingCollection` for which you could use its `ConsumingEnumerable`, rather than the current `ConcurrentQueue` usage - it would be much easier to manage it all. Suspect that's not compatible with your .NET 2.0 support, though.)</Description>
  </Issue>
  <Issue>
    <IssueID>2809</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Vs2017 with nunit3 cannot be executed in parallel </Title>
    <CreatedDate>16/04/2018</CreatedDate>
    <ClosedDate>18/05/2020</ClosedDate>
    <IssueLabels />
    <Code>
[TestFixture()]
Public class Class1Tests
{
  [Test]
  [Parallelizable]
  Public void test1Test()
  {
    While(true)
    {
      System.Diagnostics.Debug.WriteLine(2);
      Thread.Sleep(1000);
    }
  }
  [Test]
  [Parallelizable]
  Public void test2Test()
  {
    While(true)
    {
      System.Diagnostics.Debug.WriteLine(3);
      Thread.Sleep(1000);
    }
  }
}
`</Code>
    <Description>In vs2017, the nuint project is used for unit testing. The target framework of the nunit project is 4.6.1, and nunit.framework is 3.10.1.0
code show as below:
``
The phenomenon is that the test1Test function has been executed and the output is always 2.
No parallel execution, why the test2Test function is not executed? Is VS2017 also need to configure where?</Description>
  </Issue>
  <Issue>
    <IssueID>2808</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>8</Title>
    <CreatedDate>15/04/2018</CreatedDate>
    <ClosedDate>15/04/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>2808</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
  </Issue>
  <Issue>
    <IssueID>2802</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Testing for Exceptions fails for async methods using Constrains Model</Title>
    <CreatedDate>12/04/2018</CreatedDate>
    <ClosedDate>12/04/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>2802</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>csharp
public async Task MyMethod()
{
    throw new InvalidOperationException();
}


test.cs
csharp
[Test]
public async MyTest()
{
    Assert.That(await MyMethod(), Throws.InvalidOperationException);
}
`</Code>
    <Description>When attempting to use Constrains model (`Assert.That`) to test for thrown exceptions in an `async` method, the test will fail with the exception supposed to be detected. A basic example is below. Nunit v3.10.1 

Method.cs
``

This code fails with the message: `Failed: InvalidOperationException` instead of passing as expected. I looked through the docs, but couldn't see a Constrains Model version of `ThrowsAsync` like in `Assert.ThrowsAsync()` or any special syntax I'm missing.</Description>
  </Issue>
  <Issue>
    <IssueID>2800</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Generic test cases should work for int, double, string data.</Title>
    <CreatedDate>11/04/2018</CreatedDate>
    <ClosedDate>13/04/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>2800</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I am trying to write test case for generic type data. But I am getting error as
Unable to determine type arguments for fixture</Description>
  </Issue>
  <Issue>
    <IssueID>2798</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>TobiasSekan</FixedById>
        <IssueID>2798</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>[Request] Show actual count value when test fail on Has.Exactly(x).Items</Title>
    <CreatedDate>06/04/2018</CreatedDate>
    <ClosedDate>12/07/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2798</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>2798</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>csharp
    /// &lt;summary&gt;
    /// Represents a PCAN filter mode
    /// &lt;/summary&gt;
    public enum PeakCanMode : byte
    {
        /// &lt;summary&gt;
        /// Mode is Standard (11-bit identifier)
        /// &lt;/summary&gt;
        PcanModeStandard = 0x_00,

        /// &lt;summary&gt;
        /// Mode is Extended (29-bit identifier)
        /// &lt;/summary&gt;
        PcanModeExtended = 0x_02
    }


csharp
      ///&lt;summary&gt;
      /// Test that the enumeration have the correct count of elements
      ///&lt;/summary&gt;
      [Test]
      [Description("Test that the enumeration have the correct count of members")]
      public void HaveTheCorrectMemberCount()
          =&gt; Assert.That(Enum.GetNames(typeof(PeakCanMode)), Has.Exactly(3).Items);


When the count is wrong i get
&gt; Meldung:   Expected: exactly 3 items
&gt;   But was:  &lt; "PcanModeStandard", "PcanModeExtended" &gt;

but it would be nicer, when I would get
&gt; Meldung:   Expected: exactly 3 items
&gt;   But was:  actual 2 items &lt; "PcanModeStandard", "PcanModeExtended" &gt;

Yes I know, I can add a extra message as error description with the count, but i think it would be nicer
csharp
      ///&lt;summary&gt;
      /// Test that the enumeration have the correct count of elements
      ///&lt;/summary&gt;
      [Test]
      [Description("Test that the enumeration have the correct count of members")]
      public void HaveTheCorrectMemberCount()
          =&gt; Assert.That(Enum.GetNames(typeof(PeakCanMode)),
                         Has.Exactly(3).Items);
                         $"Actual {Enum.GetNames(typeof(EsaDeviceCommand)).Length} items");

`</Code>
    <Description>When I test that a enumeration have the correct count of members, so it do it with

``</Description>
  </Issue>
  <Issue>
    <IssueID>2795</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Allow Theory to specify the fields/method to use as Datapoint/DatapointSource</Title>
    <CreatedDate>04/04/2018</CreatedDate>
    <ClosedDate>04/04/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2795</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>2795</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I was wondering if there's a reason why `Theory`, `Datapoint` and `DatapointSource` don't work the same way as `Test` and `TestCaseSource`, in the sense that for a particular test, I can specify which field/method to use as its `TestCaseSource` (even field/methods outside of the `TestFixture`). I'd like to be able to do the same for theories.

The situation I ran into is that I'm converting two different tests in the same fixture to theories, they both have the same parameter types, but I want different sets of values passed to each one. Right now if I create two separate properties that return an `IEnumerable&lt;MyType&gt;` (both theories have a parameter of type `MyType`) with the `DatapointSource` attribute on them, both of them would be fed to both theories, which is not what I want to happen.

The workaround for now is to put each theory in its own `TestFixture` with its own `DatapointSource`, but it'd be nicer if we could specify the `DatapointSource` as part of the `Theory` attribute, so it works more like `TestCaseSource`.</Description>
  </Issue>
  <Issue>
    <IssueID>2794</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>TestEngineActivator cannot create new TestEngine instances when executing in a .NET Core 2 environment.</Title>
    <CreatedDate>02/04/2018</CreatedDate>
    <ClosedDate>16/05/2019</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:answered</Name>
        <IssueID>2794</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>2794</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I'm having some trouble using the newer Engine API on an ASP.NET Core 2 application. I'm attempting to load a bunch of nunit fixtures from a different project and make their metadata available through a web API.

The failure occurs when attempting to create a new `NUnit.Engine.TestEngine` instance using the `TestEngineActivator.CreateInstance()` method.

When executed in the .NET Core 2 project the line fails with the following error message: `System.MissingMethodException: 'Method not found: 'System.Object System.AppDomain.CreateInstanceFromAndUnwrap(System.String, System.String)'.'`. When it's executed in the .NET Framework context it works as expected. 

I currently have my solution structured so that the code that interprets and loads the nunit data and the API code are in their own projects.

NunitLoader - Target Framework: .NET Framework 4.7.1, OutputType: Class Library
NunitAPI - Target Framework: .NET Core 2.0, OutputType: Console Application
</Description>
  </Issue>
  <Issue>
    <IssueID>2792</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Running NUnit inside sandbox</Title>
    <CreatedDate>02/04/2018</CreatedDate>
    <ClosedDate>18/05/2020</ClosedDate>
    <IssueLabels />
    <Code>
permSet.AddPermission(new FileIOPermission(FileIOPermissionAccess.Read, assemblyPath));
permSet.AddPermission(new FileIOPermission(FileIOPermissionAccess.PathDiscovery, assemblyPath));
		
/* Permissions for NUnit: see https://github.com/nunit/nunit/blob/master/src/NUnitFramework/tests/Assertions/LowTrustFixture.cs#L166 for details */
.AddPermission(new ReflectionPermission(ReflectionPermissionFlag.MemberAccess));            // Required to instantiate classes that contain test code and to get cross-appdomain communication to work.
.AddPermission(new SecurityPermission(
	SecurityPermissionFlag.Execution |   // Required to execute test code
	SecurityPermissionFlag.SerializationFormatter |   // Required to support cross-appdomain test result formatting by NUnit TestContext
	SecurityPermissionFlag.UnmanagedCode // Added by andgein. Required for NUnit 3.10's System.Console.SetOut() call
));  
`</Code>
    <Description>Hello, I'm trying to run NUnit tests with untrusted code inside sandbox.

Before NUnit v3.5 I used a portable version, which didn't require any special permissions. But there is no portable version now.

I tried to run NUnit 3.10 in the sandbox with following permissions set:
``

Moreover I have to choose version for .NET standard 1.6. In other case some calls are marked with `[SecurityCritical]` which are not allowed inside sandbox. See  for example.

But giving `SecurityPermissionFlag.Execution` and `SecurityPermissionFlag.UnmanagedCode` for untrusted code is a bad idea, I think.

Is any appropriate way to run NUnit 3.10 inside sandbox? May be define some special constant for building sandbox-compatible version of NUnit? As `PORTABLE` which has been removed after v3.5?</Description>
  </Issue>
  <Issue>
    <IssueID>2791</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Extending Nunit framework for custom need?</Title>
    <CreatedDate>02/04/2018</CreatedDate>
    <ClosedDate>03/04/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2791</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>2791</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I need to be able to pass a reference object to a test class constructor and use that inside test initialize methods to use them within test methods. I also need to be able to configure test runner and run from some point of invocation like a console application or from button click in a form application. How to achieve this in NUnit framework? In short I need to pass a variable to test class and use it instead of declaring it inside and I should be able to run test runner from my own application. Is this possible? Any help is appreciated.</Description>
  </Issue>
  <Issue>
    <IssueID>2790</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>jnm2</FixedById>
        <IssueID>2790</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Removing ITypeInfo abstraction</Title>
    <CreatedDate>31/03/2018</CreatedDate>
    <ClosedDate>09/04/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2790</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:refactor</Name>
        <IssueID>2790</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>It appears that both NUnit's code and the ITypeInfo abstraction itself are tightly coupled to `System.Type`.
This does not appear to have the potential to be an area of volatility, so the abstraction appears to be pure overhead. That's definitely the feeling I get each time I've worked with it. It's not useful for cross-platform BCL differences since we use extension methods in namespaces for that.

How bad of a change would it be to remove TypeWrapper and ITypeInfo and run directly against the reflection API?</Description>
  </Issue>
  <Issue>
    <IssueID>2787</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Build fails (nunit 3.10.1)</Title>
    <CreatedDate>29/03/2018</CreatedDate>
    <ClosedDate>29/03/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>2787</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>We've got an build error on our build server.

``
</Description>
  </Issue>
  <Issue>
    <IssueID>2786</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>mikkelbu</FixedById>
        <IssueID>2786</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Timeout value not resetting on Retry of failed test</Title>
    <CreatedDate>28/03/2018</CreatedDate>
    <ClosedDate>06/09/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2786</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>2786</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>2786</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Not sure if this has been raised before, could find a similar issue. 

I have a test with both Retry and Timeout attribute but when a test is retried the timeout isn't being reset to 0.

``

**Expected Result:** Both tests to pass after a retry

**Actual Result** Test1 passes as expected but Test2 fails with message _Test exceeded Timeout value of 3000ms_. 

It looks like the timeout isn't being reset when the test starts the second time, is this the expected result or should a reset be performed for each retry of the tests. 

_**ps** sorry about the code sample, doesn't look to be formatting everything_

_@ChrisMaddock edit: fixed formatting_</Description>
  </Issue>
  <Issue>
    <IssueID>2784</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>[SetUp] not being picked up</Title>
    <CreatedDate>28/03/2018</CreatedDate>
    <ClosedDate>28/03/2018</ClosedDate>
    <IssueLabels />
    <Description>I have installed NUnit 2 Test Adapter on Visual Studio 2017 Community Edition
I have NUnit v2.6.3 installed in the class library

When I run tests it does not reach [SetUp]

I have another project that has the exact same thing but works just fine.</Description>
  </Issue>
  <Issue>
    <IssueID>2782</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>How to raise the tests execution performance (NUnit 3.9)?</Title>
    <CreatedDate>27/03/2018</CreatedDate>
    <ClosedDate>16/12/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>2782</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>2782</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Hi there!

Until recently, we used in our project NUnit 2.6, and a couple of days ago we moved to the NUnit 3.9. However, despite the fact that now the unit tests are performed in parallel and not sequentially as before, we see almost no performance gain. All the builds are done on a separate build server using Teamcity 10. Different settings for agents and workers number don't affect the result. Perhaps we have missed something? Tell me please, what should we try to reduce tests execution time?

Thank you.</Description>
  </Issue>
  <Issue>
    <IssueID>2779</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Add OneTimeTearException and OneTimeTearFailed attributes</Title>
    <CreatedDate>26/03/2018</CreatedDate>
    <ClosedDate>18/05/2020</ClosedDate>
    <IssueLabels />
    <Description>Hello all

When NUnit used as integration tests framework will be nice to have similar to OneTimeTearDown attribute, but executes when something goes wrong (test failed or exception occurred) during testing to clean up resources.

Any thoughts on this?
</Description>
  </Issue>
  <Issue>
    <IssueID>2778</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>File type not supported (.nunit) when using --inprocess</Title>
    <CreatedDate>26/03/2018</CreatedDate>
    <ClosedDate>26/03/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:duplicate</Name>
        <IssueID>2778</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>
1) Invalid : C:\Users\foo\tests.nunit
File type is not supported

* Running `--list-extensions` in both cases tells me (among other output)

Extension Point: /NUnit/Engine/TypeExtensions/IProjectLoader
  Extension: NUnit.Engine.Services.ProjectLoaders.NUnitProjectLoader
    FileExtension: .nunit
  Extension: NUnit.Engine.Services.ProjectLoaders.VisualStudioProjectLoader
    FileExtension: .sln .csproj .vbproj .vjsproj .vcproj .fsproj


### Expected Behaviour
Tests should run in both cases

### tests.nunit content
Here is the content of `tests.nunit`

&lt;NUnitProject&gt;
&lt;Settings activeconfig="active" appbase="C:\dev\Bar\bin"/&gt;
    &lt;Config name="active"&gt;
        &lt;assembly path="C:\dev\Bar\bin\Bar.dll"/&gt;
    &lt;/Config&gt;
&lt;/NUnitProject&gt;
`</Code>
    <Description>### Environment
- `NUnit.ConsoleRunner 3.8.0`
- `NUnit.Extension.NUnitProjectLoader 3.5.0`
- Windows

Note: both packages are `nuget install`'d to the same directory
### Behaviour
* Running `nunit3-console.exe tests.nunit` starts all tests in the test assembly
* Running `nunit3-console.exe tests.nunit --inprocess` gives the error
``

It seems as though the error message is a bit of a red herring given that in both cases the extension is apparently installed.

This might be purely a `nunit-console`\engine issue, in which case feel free to move it!</Description>
  </Issue>
  <Issue>
    <IssueID>2775</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Test case source increased by one after version 3.8.0</Title>
    <CreatedDate>25/03/2018</CreatedDate>
    <ClosedDate>25/03/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:duplicate</Name>
        <IssueID>2775</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Currently i have a test case that is data driven based on an enum which contains only 3 items
after upgrading from 3.7.1 (last working one for me) i got 4 test instances instead of 3

Here's the code.
Test Case
![image](

Enum
![image](

Test Cases
When i upgrade NUnit later than 3.7.1 i got an extra instance without a value and sure it fails as the test case source is not found
![image](



</Description>
  </Issue>
  <Issue>
    <IssueID>2772</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Random failing of parallel test run: Unhandled Exception: System.InvalidOperationException: Stack empty.</Title>
    <CreatedDate>23/03/2018</CreatedDate>
    <ClosedDate>10/02/2019</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2772</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>2772</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>_From @YRudievGP on March 23, 2018 14:16_

Sorry if dublicate, I didn't find the issue.

Random failing of parallel test run. 
More then one hundred tests are in the test run and they are running parallel ([Parallelizable(ParallelScope.Fixtures)]). 
Seems that different threads trying to take next test when they are finished (it occurs in the end of the run).

``

NUnit: 3.10.1
NUnit3testAdapter: 3.10.0
Target framework: netcoreapp2.0
CI: TeamCity 2017.2.1 (build 50732)
OS: Linux Ubuntu

_Copied from original issue: nunit/nunit3-vs-adapter#491_</Description>
  </Issue>
  <Issue>
    <IssueID>2770</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>2770</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Add FQN attribute to tests</Title>
    <CreatedDate>23/03/2018</CreatedDate>
    <ClosedDate>01/11/2019</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:wontfix</Name>
        <IssueID>2770</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>2770</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>2770</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Working with the Visual Studio Test team, the new source based discovery would be much more reliable if we could provide a standardized and predictable fully qualified name to the various test runners. We've met with the maintainers of the other .NET Test frameworks and agreed on a standard. We could recreate this information in the adapter, but we have all of the information required in the framework, so it would be much more efficient to create the FQN here and add it as an attribute to the test's XML node in `Test.PopulateTestNode`.

If @nunit/framework-team members would like to see or comment on the spec, contact @rprouse.</Description>
  </Issue>
  <Issue>
    <IssueID>2769</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>How to send result file after all tests run</Title>
    <CreatedDate>22/03/2018</CreatedDate>
    <ClosedDate>24/03/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2769</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>2769</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Hi,
Is there a way to send a mail with result file (I set this file in console command with option --result)
after running.
The result file was created after OneTimeTearDown function.
If sending an e-mail into OneTimeTearDown function - the result file comes incomplete</Description>
  </Issue>
  <Issue>
    <IssueID>2639</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>2639</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>ValuesAttribute causes ExpectedResult to have no effect</Title>
    <CreatedDate>20/12/2017</CreatedDate>
    <ClosedDate>02/01/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2639</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>2639</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>cs
[Test(ExpectedResult = 4)]
public double? CanConvertIntToNullableDouble([Values(2)] double? x, [Values(2)] double? y)
{
    return x + y;
}
`</Code>
    <Description>As part of fixing #2630, I copied many tests from TestCaseAttributeTests to ValueAttributeTests and had to remove them again because they failed.



When translated to ValuesAttribute:

``

Gives:

&gt; Method has non-void return value, but no result is expected

Looks like a bug to me. Does everyone agree?
</Description>
  </Issue>
  <Issue>
    <IssueID>2636</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Description or AttributeUsage issue</Title>
    <CreatedDate>20/12/2017</CreatedDate>
    <ClosedDate>20/12/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:duplicate</Name>
        <IssueID>2636</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>

Description states that "Attribute used to mark a class that contains one-time SetUp" but AttributeUsage has AttributeTargets.Method value. </Description>
  </Issue>
  <Issue>
    <IssueID>2634</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>NUnit 3 - need guidance for implementation </Title>
    <CreatedDate>19/12/2017</CreatedDate>
    <ClosedDate>02/01/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>2634</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I am using nunit-console v3.6.1 with framework v3.8.1.
I need an advice for how to implement something.
I want that when running tests via nunit-console, the engine will dynamically create directory for the test run, based on command line argument. 
For example if I run from cmd: 'nunit-console.exe Test.dll --work:"C:\Runs"', for each run I want to create directory in "C:\Runs" and I will set the Environment.CurrentDiretory property to the dir created dynamically by engine.

How can I achieve this goal (which NUnit components should I implement)?
Can it be done by writing an engine extension?
</Description>
  </Issue>
  <Issue>
    <IssueID>2632</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>2632</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Parallel tests are loading 100% CPU when nested SetUpFixture exists</Title>
    <CreatedDate>19/12/2017</CreatedDate>
    <ClosedDate>14/01/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2632</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>2632</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Using 3.9.0.0 NUnit framework and adapter,  I have similar to  issue.

We have [SetUpFixture] class in root namespace and [SetUpFixture] class in nested namespace.

Please refer code in 
When tests from namespace NUnitParallels.Some is running it is 100% CPU utilization:
![image](
</Description>
  </Issue>
  <Issue>
    <IssueID>2631</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Possible to have different category depending on combinatorial values?</Title>
    <CreatedDate>19/12/2017</CreatedDate>
    <ClosedDate>21/12/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:wontfix</Name>
        <IssueID>2631</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>For example (very simple example) below this is what I want to achive, but without writing every TestCase
``

Is this possible? If not, what is the correct approach? Not using combinatorial is not an option, we have to many different cases.</Description>
  </Issue>
  <Issue>
    <IssueID>2630</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>jnm2</FixedById>
        <IssueID>2630</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Framework throws NullReferenceException if test parameter is marked with [Values(null)]</Title>
    <CreatedDate>19/12/2017</CreatedDate>
    <ClosedDate>22/12/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2630</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>2630</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>2630</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>csharp
class Foo
{
    [Test]
    public void Bar([Values(null)] int? param)
    {
        Assert.Pass();
    }
}
`</Code>
    <Description>I'm using NUnit 3.9.0, NUnit Console Runner 3.7.0 and NUnit 3 Test Adapter 3.9.0 for Visual Studio Community 2017. 

Exception is seems to be thrown by access to `Array.Length` property in [`ParamAttributeTypeConversions.GetData()`]( `Values(null)` is resolved to [`ValuesAttribute(params object[] args)`]( call. Issue can be reproduced using following code snippet:
``
In Visual Studio test is not discovered during test project build, i.e. it doesn't appear in Test Explorer list of tests. No message is shown in Output window. NUnit Console Runner shows following error message:
&gt; System.NullReferenceException: Object reference not set to an instance of an object. at NUnit.Framework.Internal.ParamAttributeTypeConversions.GetData(Object[] data, Type targetType) at NUnit.Framework.Internal.Builders.ParameterDataSourceProvider.GetDataFor(IParameterInfo parameter) at NUnit.Framework.CombiningStrategyAttribute.BuildFrom(IMethodInfo method, Test suite) at NUnit.Framework.Internal.Builders.DefaultTestCaseBuilder.BuildFrom(IMethodInfo method, Test parentSuite) at NUnit.Framework.Internal.Builders.NUnitTestFixtureBuilder.AddTestCasesToFixture(TestFixture fixture) at NUnit.Framework.Internal.Builders.NUnitTestFixtureBuilder.BuildFrom(ITypeInfo typeInfo) at NUnit.Framework.Internal.Builders.DefaultSuiteBuilder.BuildFrom(ITypeInfo typeInfo)

You can check original use case in [How to pass NULL value to ValuesAttribute of the test method?]( discussion on StackOverflow.</Description>
  </Issue>
  <Issue>
    <IssueID>2629</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>New tests don't show up in TestResult.xml</Title>
    <CreatedDate>19/12/2017</CreatedDate>
    <ClosedDate>21/12/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>confirm</Name>
        <IssueID>2629</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>2629</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>New tests added to the `nunit.framework.tests` project do not appear in the `TestResult.xml` file, when executed using the build Cake script.

When a test fails, the script output does catch them and report, they just don't seem to make their way into the output XML file.

However, using the NUnit Adapter 3.9.0.0 within VS2017 does appear to detect and run them.</Description>
  </Issue>
  <Issue>
    <IssueID>2628</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Error during installing tools when running build script</Title>
    <CreatedDate>19/12/2017</CreatedDate>
    <ClosedDate>30/01/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2628</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>good first issue</Name>
        <IssueID>2628</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:build</Name>
        <IssueID>2628</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:low</Name>
        <IssueID>2628</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>When I ran `.\build.ps1 -t test45`, I saw

&gt; Error finding repository for ' An error occurred while retrieving package metadata for 'NUnit.ConsoleRunner.3.7.0' from source 'NUnit AppVeyor CI'.
  A task was canceled.

CC @jnm2 </Description>
  </Issue>
  <Issue>
    <IssueID>2627</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>mikkelbu</FixedById>
        <IssueID>2627</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Breaking change in CollectionAssert.AllItemsAreUnique with NUnit 3.9</Title>
    <CreatedDate>18/12/2017</CreatedDate>
    <ClosedDate>11/03/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>2627</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>2627</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>After upgrading to NUnit Framework 3.9 we have a failing test that checks if all items of an object collection are unique. Example:
``
A float value of `42f` now is considered to be different to an integer value `42`.
Is this intentional or an undesirable side effect of maybe #2551?</Description>
  </Issue>
  <Issue>
    <IssueID>2626</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>SetUp/TearDown methods are invoked multiple times before/after test in .NET Standard targeted projects</Title>
    <CreatedDate>17/12/2017</CreatedDate>
    <ClosedDate>21/12/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2626</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>2626</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>csharp
[TestFixture]
public class SampleIntegrationTest : SqlServerDatabaseIntegrationTest
{
    private int _setupCounter = 0;

    [Test]
    public void SetUpShouldInvokeOnce()
    {
        Assert.AreEqual(1, _setupCounter);
    }

    // SetUp method runs 3 times before test
    public override void SetUp()
    {
        ++_setupCounter;

        base.SetUp();
        // Additional setup logic
    }
}

public abstract class SqlServerDatabaseIntegrationTest : DatabaseIntegrationTest
{
    public override void SetUp()
    {
        base.SetUp();
        // Additional setup logic
    }
}

public abstract class DatabaseIntegrationTest : BaseIntegrationTest
{
    public override void SetUp()
    {
        base.SetUp();
        // Additional setup logic
    }
}

public abstract class BaseIntegrationTest
{
    [SetUp]
    public virtual void SetUp()
    {
    }
}
`</Code>
    <Description>When I run test that is in test fixture that **inherits** from class containing **virtual method** in base class marked as [SetUp]/[TearDown] AND other derived classes overrides this method, then method **[SetUp] is invoked multiple times** before test execution AND method marked as **[TearDown] is invoked multiple times** after test execution - as many times as method is overriden throughout chain of inheritance. 

This issue occurs **only in .NET Standard** targeted projects.

Platform:
- NUnit 3.9.0
- NUnit 3 TestAdapter 3.9.0
- Visual Studio 2017 (v. 15.5.2)
- .NET Core SDK 2.1.2
- .NET Standard 1.6 targeted project

Sample:

``</Description>
  </Issue>
  <Issue>
    <IssueID>2620</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>NUnit Framework no longer buildable using VS2015</Title>
    <CreatedDate>14/12/2017</CreatedDate>
    <ClosedDate>14/05/2019</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:wontfix</Name>
        <IssueID>2620</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I decided to do a quick check of an issue by writing a test (#2619 if it matters) so I pulled down master, created a branch and opened VS2015.

Turns out none of the projects load any longer. They do load in VS2017 (with errors in my case) and in researching I discovered the `BUILDING.md` file now says VS2017 is required, where previously we were able to build the framework using VS2012 and higher.

I feel this is a real loss and - to be quite frank - displays something of a disdain for those who don't upgrade to the "latest and greatest" when told to do so by the vendor. With some degree of caring for such folks, this could easily have been done in a less painful way or possibly not done at all.

However, if it had to be done, it should not have been slip-streamed but rather given serious visibility. Only those who participated in the details of the change would have a way to know the consequence. There are people who build NUnit from source and every commit to master is a potential source release for them.

If this change can't be mitigated - well, actually won't is the operative word, since it obviously could be done - then we need to have a pretty big notification going out to those users. IMO, it should be accompanied with an apology for springing this on them.

For me personally, this was a rather unpleasant surprise and appears to remove my ability to contribute to our primary project unless I convert to VS2017. 😢 </Description>
  </Issue>
  <Issue>
    <IssueID>2619</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>2619</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>NUnit is retaining the previous 'Failed' value in  TestContext.CurrentContext.Result.Outcome when working with Retry attribute</Title>
    <CreatedDate>14/12/2017</CreatedDate>
    <ClosedDate>16/12/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>2619</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>cs
[TearDown]
public void TearDown()
{
    try
    {
        var currentContext = TestContext.CurrentContext;
        var message = TestContext.CurrentContext.Result.Message;
        var stackTrace = TestContext.CurrentContext.Result.StackTrace;
        if (currentContext.Result.Outcome != ResultState.Success)
        {
            var testName = currentContext.Test.Name;
            string rootPath = AppDomain.CurrentDomain.BaseDirectory;
            String filename = rootPath + "\Report\" + this.GetType().FullName + "." + testName + "_" + DateTime.Now.ToString("yyyy - MM - dd - HH - mm - ss") + ".png";
            Console.WriteLine("filename: " + filename);
            UtilityHelper.TakeScreenshot(_driver, filename);
            if (Global.tempCount &lt;= 1)
                Global.test.Log(Status.Fail, stackTrace + message);
        }
        Log.Info("Teardown test");
        _driver.Quit();
    }
    catch { _driver.Dispose(); }
}
`</Code>
    <Description>Hi @CharliePoole , I am facing a problem with Retry Attribute. NUnit is retaining the previous Failed value in
TestContext.CurrentContext.Result.Outcome and hence my Test Case is Failed even if it is actually Passed in the second attempt. Please see the below code snippet, my code goes inside the First if loop because currentContext.Result.Outcome value is "Failed" in the second attempt as well in the TearDown method(although my Test gets passed during the second attempt):

``</Description>
  </Issue>
  <Issue>
    <IssueID>2618</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Extra Simicolon </Title>
    <CreatedDate>14/12/2017</CreatedDate>
    <ClosedDate>14/12/2017</ClosedDate>
    <IssueLabels />
  </Issue>
  <Issue>
    <IssueID>2617</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Ignored Test causing Suite to be marked as Ignored rather than Pass/Fail/Inconclusive</Title>
    <CreatedDate>13/12/2017</CreatedDate>
    <ClosedDate>16/01/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>2617</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Hello,

We've been looking to migrate from NUnit2 to NUnit3, but have noticed some differences in result output with ignored test cases and how they relate to the overall test suite result.

In NUnit2, we noticed that when a single test case within a suite was ignored, then the suite would still be marked as pass/fail depending on the other test cases within that suite.  If all the test cases within the suite were ignored, then the test suite would be marked as inconclusive.

In NUnit3, we noticed that when a single test case within a suite was ignored, then the suite would be marked as ignored/skipped.  If all the tests cases within the suite were ignored, then the test suite would be marked as ignored/skipped.

Is this expected behavior in NUnit3 when a single test case or all test cases are ignored within a suite?  Or, should the test suites still be marked as pass/fail/inconclusive?

I've attached sample code and the resulting XML.  The runners I used were 2.6.4 against framework 2.6.4 and 3.7.0 against framework 3.9.0.  The commands I used were as follows:

NUnit2:
`'C:\Program Files (x86)\NUnit 2.6.4\bin\nunit-console.exe' .\NUnit2IgnoreAllTests\bin\Debug\NUnit2IgnoreAllTests.dll /labels:All result:".\Results\NUnit2IgnoreAllTest.xml"`

NUnit3:
`.\packages\NUnit.ConsoleRunner.3.7.0\tools\nunit3-console.exe .\NUnit3IgnoreAllTests\
bin\Debug\NUnit3IgnoreAllTests.dll --labels=All --result=".\Results\NUnit3IgnoreAllTest.xml"`

I've attached the code I wrote along with the result XMLs.
[NUnitIgnore.zip](
</Description>
  </Issue>
  <Issue>
    <IssueID>2614</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>ChrisMaddock</FixedById>
        <IssueID>2614</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>TestExecutionContext.CurrentContext is saved in Remoting CallContext between test runs</Title>
    <CreatedDate>11/12/2017</CreatedDate>
    <ClosedDate>18/11/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2614</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>2614</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>2614</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Discovered from 

TestExecutionContext.CurrentContext is currently saved in `Remoting.Messaging.CallContext` as below:

``

It appears that this CallContext is still accessible past the end of a single run, and across app domains. The result of this is that when the Console runs two tests assemblies sequentially (in the same process), the second test suite attempts to access the final TestExecutionContext of the previous assembly, and triggers an `AppDomainUnloadedException`.

I've tested this theory by including the below line at the end of `RunTestsAction` - i.e. as the last thing done by the framework in a test run. This appeared to clear the CallContext, and mean a new TestExecutionContext was created for the second assembly, as we'd want.

`CallContext.FreeNamedDataSlot("NUnit.Framework.TestContext");`

I know absolutely nothing about CallContext's, and the docs seem 'sparse'! From what I can see, `TestExecutionContext` implements `ILogicalThreadAffinative` - which is specifically to allow it to be accessed across AppDomains. What's the purpose of this, is it to permit user-created AppDomains? 

How should we handle this issue? I don't think the framework currently has any sort of 'clean-up' - is that the correct solution here? </Description>
  </Issue>
  <Issue>
    <IssueID>2613</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>"Has no TestFixtures" message executing via nunit3-console.exe </Title>
    <CreatedDate>11/12/2017</CreatedDate>
    <ClosedDate>16/01/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>2613</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I have a simple class with a [TestFixture] and no [Test] methods inside it. I used to have the project reference NUnit 2.6.4 and run them with NUnit 2.6.4 runner. When I upgraded both to 3.7, I am getting this error. I don't want to change my code to get past this, is there a way around on this? Otherwise, I need to downgrade the project(s) to NUnit2 and run them, don't want to do that either 

``

Maybe related to  but my use case is straightforward. 
</Description>
  </Issue>
  <Issue>
    <IssueID>2612</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Assert.Multiple is not very useable from C++</Title>
    <CreatedDate>11/12/2017</CreatedDate>
    <ClosedDate>18/05/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>design</Name>
        <IssueID>2612</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>We purport to support Managed C++ but Assert.Multiple doesn't work in C++ unless the user writes a bunch of shim code.

This is due to the fact that C# and C++ lambda expressions are not compatible, although it's possible to wrap a C++ lambda so it looks like a C# lambda.

I'm marking this issue for discussion and design. As part of the discussion phase, I'd like to here what our users who program in managed C++ do about this, if anything. Of course, it may turn out there are no such users or not many. 😄 

I'm thinking that one possible solution may be to create a header file that has the needed shims to make Assert.Multiple work with native C++ lambdas, but we should investigate whether there is actually a need first. If we go that way, it might be a separate project I would create myself or it could become an NUnit PR.</Description>
  </Issue>
  <Issue>
    <IssueID>2611</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Enable .NET Standard 1.6 tests on non-Windows</Title>
    <CreatedDate>11/12/2017</CreatedDate>
    <ClosedDate>12/03/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2611</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:build</Name>
        <IssueID>2611</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:low</Name>
        <IssueID>2611</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>This will require installing two versions of the .NET Core SDK on Travis which may not be straightforward.
We need both the latest 1.1.x (because our tests target netcoreapp1.1) and the latest 2.0.x. I don't expect any 1.6 tests to fail once  is merged, but since we use preprocessor and a whole different set of BCL libraries, there's always the chance.

The alternative would be to stop targeting netcoreapp1.1 in any test projects, but that would leave us without a way to test the netstandard1.6 NUnit DLL unless we added additional test csproj files which target netcoreapp2.0 and reference the netstandard1.6 framework DLL directly rather than referencing it via the framework project reference.</Description>
  </Issue>
  <Issue>
    <IssueID>2608</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Culture differences on .NET Core on non-Windows causes test failures</Title>
    <CreatedDate>11/12/2017</CreatedDate>
    <ClosedDate>12/12/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2608</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>design</Name>
        <IssueID>2608</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:critical</Name>
        <IssueID>2608</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>(@nunit/framework-team We'll need to take care of this before 3.10 or else pull the .NET Standard 2.0 build.)

These tests are Windows-specific; .NET Core on other operating systems causes them to fail. Mono, however, passes the tests so it seems to produces the Windows behavior with our .NET Framework DLLs on other OSs. Our .NET Standard DLLs on .NET Core are inconsistent with our .NET Framework DLLs on Mono.

 says the date format should be up to the OS by design.
 looks like it'll have the same conclusion for the string comparisons.

 - Should we take the same stance as .NET Core and expect different results on Windows and Ubuntu?

 - Should we take the same stance as (I think) Mono does and try to polyfill the WIndows behavior onto other OSs somehow (though this seems like low ROI)?

 - We haven't yet done the work to enable `PlatformAttribute` on .NET Standard. Should we take the easy out for 3.10 and remove NUnit's culture APIs, or look into adding both platform-detection and culture APIs?

``</Description>
  </Issue>
  <Issue>
    <IssueID>2606</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>.NET Core (.NET Standard) NUnit Parallel Tests</Title>
    <CreatedDate>07/12/2017</CreatedDate>
    <ClosedDate>07/12/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:duplicate</Name>
        <IssueID>2606</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Hello, 

We have started to port code over from .NET Framework to .Net Core which includes our tests. So far I have not found a way to run the nunit tests in parallel like we did using the .NET Framework. Is this not support for the .NET Core Version?</Description>
  </Issue>
  <Issue>
    <IssueID>2604</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Constraint sequence Has.One.Member is accepted but not working as expected</Title>
    <CreatedDate>07/12/2017</CreatedDate>
    <ClosedDate>28/04/2019</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>confirm</Name>
        <IssueID>2604</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>2604</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>2604</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>This issue started as a question on the following issue: 
@ChrisMaddock, @CharliePoole, @mikkelbu: Thanks for the help so far on the above issue!

I am currently using nunit.framework v3.9.0.0 and have problems when using a Has.One.Member(...) constraint:
`class TestElement { }`
``
I would expect that this sequence is either illegal, or when NUnit does allow it I would expect it to mean that the collection contains exactly 1 element and that element is equal to the provided object.

Side note: I encountered this while trying to write a constraint that in hindsight should probably be expressed as:
`Assert.That(new List&lt;TestElement&gt; { element }, Has.One.EqualTo(element));`
or as:
`Assert.That(new List&lt;TestElement&gt; { element, element2 }, Has.Member(element).And.Count.EqualTo(1));`</Description>
  </Issue>
  <Issue>
    <IssueID>2599</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Nunit3 runner can't run combination of Nunit2 and 3 tests?</Title>
    <CreatedDate>06/12/2017</CreatedDate>
    <ClosedDate>09/12/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>2599</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>So I have a mammoth solution full of about 2.5k tests all targetting Nunit 2.6.4. I'm in the process of migrating them to target Nunit3 (3.9). I migrated a bunch of projects, made some changes to overcome the breaking changes. When I run the build and test in TeamCity with Nunit console runner 3.4.1 I don't see any tests getting picked or run. The NUnit step is running for over 30m and no tests are getting identified. The Nunit2.6.4 runner runs all tests in about 8m. 

I also tried adding NUnit.Extension.NUnitV2Driver nuget package but it didn't change anything.

I see this same block getting repeated for each of the projects.

[11:52:17]Starting: C:\NUnit.ConsoleRunner.3.4.1\tools\nunit3-console.exe D:\BuildAgent\temp\buildTmp\pXqRm6ESTWkQ1qWrFNGRrkL3w5uV0xrV.nunit --result=D:\BuildAgent\temp\buildTmp\pXqRm6ESTWkQ1qWrFNGRrkL3w5uV0xrV.nunit.xml --noheader --where cat!=Integration&amp;&amp;cat!=Performance&amp;&amp;cat!=Staging --framework=net-4.0 --explore=D:\BuildAgent\temp\buildTmp\Ejgzmelp2EGVC9x2cNr3AMOaOg6GupWp_all.tests
[11:52:17]in directory: D:\BuildAgent\work\4d26b68a6ce28083\Projects\Services.Account.Web.Tests\bin\Staging
[11:52:17]Runtime Environment
[11:52:17]   OS Version: Microsoft Windows NT 10.0.14393.0
[11:52:17]  CLR Version: 4.0.30319.42000
[11:52:17]
[11:52:17]Test Files
[11:52:17]    D:\BuildAgent\temp\buildTmp\pXqRm6ESTWkQ1qWrFNGRrkL3w5uV0xrV.nunit
[11:52:17]
[11:52:17]Test Filters
[11:52:17]    Where: cat!=Integration&amp;&amp;cat!=Performance&amp;&amp;cat!=Staging
[11:52:17]
[11:52:47]Results (nunit3) saved as D:\BuildAgent\temp\buildTmp\Ejgzmelp2EGVC9x2cNr3AMOaOg6GupWp_all.tests
[11:52:47]Process exited with code 0



[12:00:24]Test Run Summary
[12:00:24]  Overall result: Failed
[12:00:24]  Test Count: 0, Passed: 0, Failed: 0, Inconclusive: 0, Skipped: 0
[12:00:24]  Start time: 2017-12-06 17:59:56Z
[12:00:24]    End time: 2017-12-06 18:00:26Z
[12:00:24]    Duration: 30.108 seconds</Description>
  </Issue>
  <Issue>
    <IssueID>2598</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Is.Not.EquivalentTo is extremely slow</Title>
    <CreatedDate>06/12/2017</CreatedDate>
    <ClosedDate>06/12/2017</ClosedDate>
    <IssueLabels />
    <Description>Just updated my tests from NUnit 2.4.8 to 3.9.0 and noticed that tests have started running too long.
And here is a synthetic test with allows me to reproduce the problem:

&gt; [Test]
&gt; public void TestEquivalent()
&gt; {
&gt; 	byte[] data = new byte[0x80000 + 7];
&gt; 	byte[] encrypted = new byte[0x80000 + 7];
&gt; 	encrypted[0] = 2;
&gt; 	encrypted[1] = 3;
&gt; 
&gt; 	var watch = Stopwatch.StartNew();
&gt; 	Assert.That(encrypted, Is.Not.EquivalentTo(data));
&gt; 	watch.Stop();
&gt; 	Debug.WriteLine($"Takes: {watch.ElapsedMilliseconds} milliseconds");
&gt; }
&gt; 

It used to work fast (with version 2.4.8), but now it takes 123116 milliseconds to run on my computer. In real test when two arrays contain completely different values, it takes about 22 minutes to run. Any idea why is it so?
</Description>
  </Issue>
  <Issue>
    <IssueID>2592</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>jnm2</FixedById>
        <IssueID>2592</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Add .props with ProjectCapability to suppress test project service GUID item</Title>
    <CreatedDate>02/12/2017</CreatedDate>
    <ClosedDate>02/12/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2592</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>2592</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>2592</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>The decision was made that it's the responsibility of the test framework package to tell VS to stop autoinserting this boilerplate in test csprojs:

``

From my perspective it's much nicer to do this in the framework package than the adapter package. The only projects where I use the adapter package are where I need to use `dotnet test`, and one day, I'll be using our future .NET Core console runner. (`dotnet nunit` anyone? =D)

Let me know if you agree and I'll add the file for 3.10.</Description>
  </Issue>
  <Issue>
    <IssueID>2591</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>NUnitEqualityComparer.Default should be replaced with new NUnitEqualityComparer()</Title>
    <CreatedDate>01/12/2017</CreatedDate>
    <ClosedDate>10/03/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2591</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>In  we made the constructor internal ~~and introduced a Default static property which returns a new instance every time~~. I failed to notice this when reviewing that PR. 

Edit: Thanks for the correction @mikkelbu. The Default property has been in NUnitEqualityComparer since v2.5.1!

I believe that static properties should return the same instance every time or at least *semantically be able* to return the same instance every time. If the returned instance is immutable, it should be a static property. If it's mutable, it must create a new instance every time and therefore should be a method. Rather than having a static method delegate to the default constructor, I'd prefer re-exposing the default constructor.

I would like to propose the following:

``

Should we make the obsoletion a warning or error? I prefer error because it helpfully points people to the necessary refactor while flushing out all uses but I could go either way.</Description>
  </Issue>
  <Issue>
    <IssueID>2590</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Parameterized TestFixtureSource</Title>
    <CreatedDate>01/12/2017</CreatedDate>
    <ClosedDate>04/12/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>2590</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Hi,

I'm using NUnit 3.7 Console Runner to run Selenium UI tests from TeamCity.
What I want to do is support cross browser testing by passing a parameter from console command line (--params) to a SetUpFixture, set FixtureArgs static and data drive the tests based on that.

So, my code is roughly:

``
The error I get is "No suitable constructor was found".

I know for a fact that OneTimeSetup is indeed being run and data is parsed and passed from command line parameter to FixtureArgs. What happens after that is something I was unable to debug, since it is within NUnit itself.

Is that scenario supported at all?
Any ideas?

Thanks.</Description>
  </Issue>
  <Issue>
    <IssueID>2589</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Custom attribute that combines Category and Repeat</Title>
    <CreatedDate>30/11/2017</CreatedDate>
    <ClosedDate>30/11/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2589</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>2589</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Short explanation of what I want to achieve:

I want a custom attribute named "CandidateTest" that sets a category name as well as a Repeat attribute for this test, so that I don't have to use the Repeat separately on my test. 

The Reason why I want to do this is that we have a "StressTester" job, that executes all the tests with this category for 50 times each and the test should pass all the 50 executions. 
This helps us figure out flaky tests before removing the attribute and letting them run with our normal test set.

The problem here is, that I can't figure out how to set a category as well as setting the Repeat(50).

How I tried to do it:

``

but it looks like setting the repeat value in BeforeTest is too late for NUnit to be considered. 

I also tried it the other way round = CandidateTest is derived from RepeatAttribute and to set the category, but then the category doesn't seem to be considered when executing tests

**Any suggestions from your side on how to get this done?
Or is there maybe even a possibility to get a kind of StressTester attribute from NUnit in the future?**</Description>
  </Issue>
  <Issue>
    <IssueID>2585</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Nested TestFixtureSource type</Title>
    <CreatedDate>29/11/2017</CreatedDate>
    <ClosedDate>18/05/2020</ClosedDate>
    <IssueLabels />
    <Description>Hello,

I have a use case to run selenium CMS tests based off of configuration files. The idea is they enable which browser to run as and then provide an array of URLs that the CMS provides for. I then would have a IEnumerable for the browses and one for the URLs. I would like the TestFixture to generate a Driver for each enabled browser and then for each url run each of the test methods in the class. 

The setup would generate the webdriver/browser session and then navigate to the current url. 

I have been successful on adding a single IEnumerable in a base class that does all the setup. I then tried to add a second TestFixtureSource to the actual fixture but that doesn't seem to work. 

If was hoping to see if this is even possible and if not are then any other ideas. I would rather not add a TestCaseSource on each method since it would be a lot of duplicate code.</Description>
  </Issue>
  <Issue>
    <IssueID>2579</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>AppVeyor Test Failures under .NET 3.5</Title>
    <CreatedDate>28/11/2017</CreatedDate>
    <ClosedDate>23/04/2019</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2579</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>2579</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:critical</Name>
        <IssueID>2579</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>
1) Failed : NUnit.Framework.Internal.Execution.EventQueueTests+SetWaitHandle_Enqueue_AsynchronousTest.SetWaitHandle_Enqueue_Asynchronous
Test exceeded Timeout value of 1000ms



1) Failed : NUnit.Framework.Internal.Execution.EventQueueTests+DequeueBlocking_StopTest.DequeueBlocking_Stop
Test exceeded Timeout value of 1000ms



7) Cancelled : NUnit.Framework.Internal.Execution.EventQueueTests+SetWaitHandle_Enqueue_AsynchronousTest.SetWaitHandle_Enqueue_Asynchronous
Test cancelled by user
   at NUnit.Framework.Internal.Reflect.InvokeMethod(MethodInfo method, Object fixture, Object[] args) in C:\projects\nunit\src\NUnitFramework\framework\Internal\Reflect.cs:line 232
   at NUnit.Framework.Internal.Commands.TestMethodCommand.RunNonAsyncTestMethod(TestExecutionContext context) in C:\projects\nunit\src\NUnitFramework\framework\Internal\Commands\TestMethodCommand.cs:line 109
   at NUnit.Framework.Internal.Commands.TestMethodCommand.Execute(TestExecutionContext context) in C:\projects\nunit\src\NUnitFramework\framework\Internal\Commands\TestMethodCommand.cs:line 64
   at NUnit.Framework.Internal.Commands.BeforeTestCommand.Execute(TestExecutionContext context) in C:\projects\nunit\src\NUnitFramework\framework\Internal\Commands\BeforeTestCommand.cs:line 50
   at NUnit.Framework.Internal.Commands.BeforeAndAfterTestCommand.Execute(TestExecutionContext context) in C:\projects\nunit\src\NUnitFramework\framework\Internal\Commands\BeforeAndAfterTestCommand.cs:line 59



1) Failed : NUnit.Framework.Assertions.CollectionAssertTest.PerformanceTests(System.Linq.Enumerable+&lt;RangeIterator&gt;d__b1)
Elapsed time of 137.7538ms exceeds maximum of 100ms
`</Code>
    <Description>These test failures under .NET 3.5 are getting consistent enough that we are getting few passing builds and we had [one build time out at 60 minutes]( in the .NET 3.5 tests.

In PR #2380 I am going to `#if net35` and increase the timeout as a temporary workaround, but we should look at this. I am curious why we are having so many .NET 3.5 threading issues, but no other target.

``</Description>
  </Issue>
  <Issue>
    <IssueID>2577</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>2577</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Warning in TearDown is inconsistent with Assertion failure</Title>
    <CreatedDate>26/11/2017</CreatedDate>
    <ClosedDate>16/01/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2577</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>When an Assertion is used in `TearDown` and fails, an error is generated. That is, the result is `Failed:Error` rather than simply `Failed`. Similarly, failure of an Assumption generates an error.

NUnit has worked this way historically because it is generally necessary for the `TearDown` method to complete, in order to clean things up.

As we implemented Warnings, a Warning failure in `TearDown` works differently from Assertion failure. The assertion is counted and a Warning level `AssertionResult` is created, but it has no effect on the overall result of the test. If there are no other warnings or failures, the test passes.

Alternatives:

1. Document that Warnings in TearDown have no effect on the result of the test although they may be reported by some runners. This seems confusing to me. If we are going to report it, then the test should have an overall warning result.

2. Handle Warnings in TearDown by changing the result to Warning if the test passed. This sounds like it could be useful but is still inconsistent with failing Assertions.

3. Generate an error for failed warnings in TearDown just as we do for assertion failures.


A Warning in `TearDown` generally gives seems to be ignored entirely</Description>
  </Issue>
  <Issue>
    <IssueID>2576</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>when using nunit 3 adapter for VS, my engine extensions are not being called</Title>
    <CreatedDate>26/11/2017</CreatedDate>
    <ClosedDate>26/11/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:duplicate</Name>
        <IssueID>2576</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Hi,
I wrote some engine extensions and put them in the addins directory, as documented.
When I run the project with nunit3-console.exe, everything work fine.
I tried to use the "nunit 3 test adapter" for visual studio 2013, and when I run the test it doesn't use my nunit engine extensions.
Is there a way to control how to run the tests, so it would include my nunit engine extensions?</Description>
  </Issue>
  <Issue>
    <IssueID>2573</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Parallel Tests Not Thread-Safe</Title>
    <CreatedDate>24/11/2017</CreatedDate>
    <ClosedDate>24/11/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:duplicate</Name>
        <IssueID>2573</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Given this as a (stupid) example
``
These tests will fail every time.

The behavior i expect from NUnit is that each parallel execution of a test has it's own instance of the test class to ensure thread safety of non static fields.

It would appear (not looked at code, just reverse engineered) that NUnit has a single instance of the class and calls the setup and test on different threads.</Description>
  </Issue>
  <Issue>
    <IssueID>2572</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>No tests discovered in .NET Core project with NUnit &gt;=3.8.1</Title>
    <CreatedDate>23/11/2017</CreatedDate>
    <ClosedDate>23/11/2017</ClosedDate>
    <IssueLabels />
    <Description>Attempted to write a test today using NUnit 3.8.1 for a .NET Core project. No tests discovered when I built the solution and attempted to run all tests from the unit test explorer in VS2017. I updated to the latest versions of both NUnit and the NUnit3TestAdapter but did not experience any improvement. Still no tests discovered.

I made a minimal repo which reproduces the issue. It contains one fresh .NET Standard library project which references the latest versions of NUnit and the adapter, the single test in there is not discovered.

Link to repo: [

Output from the Tests pane in VS2017 (diagnostic mode):

&gt; [23.11.2017 14:46:00 Diagnostic] About to Enqueue operation 'RunAllOperation', hashcode:37660021 
&gt; [23.11.2017 14:46:00 Diagnostic] Enqueue operation 'RunAllOperation', hashcode:37660021 
&gt; [23.11.2017 14:46:00 Diagnostic] Operation left in the the queue: 1
&gt; [23.11.2017 14:46:00 Diagnostic] 	'RunAllOperation', hashcode:37660021
&gt; [23.11.2017 14:46:00 Diagnostic] 
&gt; 
&gt; [23.11.2017 14:46:00 Diagnostic] Processing Queue .....
&gt; [23.11.2017 14:46:00 Diagnostic] Operation Dequeue : 'RunAllOperation'
&gt; [23.11.2017 14:46:00 Diagnostic] VirtualReadOnlyTestDataStore.OperationStateChanged State=OperationSetStarted, operationInProgress=False
&gt; [23.11.2017 14:46:00 Diagnostic] TestDiscoveryStats.OperationStateChanged State=OperationSetStarted, InProgress=False
&gt; [23.11.2017 14:46:00 Diagnostic] VirtualReadOnlyTestDataStore.OperationStateChanged State=ChangeDetectionStarting, operationInProgress=True
&gt; [23.11.2017 14:46:00 Diagnostic] TestDiscoveryStats.OperationStateChanged State=ChangeDetectionStarting, InProgress=False
&gt; [23.11.2017 14:46:00 Diagnostic] We programmatically start the build in TestWindowHost.UpdateContainer... 
&gt; [23.11.2017 14:46:01 Diagnostic] After we await the build that programmatically started in TestWindowHost.UpdateContainer... 
&gt; [23.11.2017 14:46:01 Diagnostic] TestContainer update (build) complete : 380 ms
&gt; [23.11.2017 14:46:01 Diagnostic] VirtualReadOnlyTestDataStore.OperationStateChanged State=OperationSetFinished, operationInProgress=False
&gt; [23.11.2017 14:46:01 Diagnostic] TestDiscoveryStats.OperationStateChanged State=OperationSetFinished, InProgress=False
&gt; [23.11.2017 14:46:01 Diagnostic] test container discoverer executor://vsprojectoutputcontainerdiscoverer/v1, discovered 1 containers
&gt; [23.11.2017 14:46:01 Diagnostic] Containers from 'Microsoft.VisualStudio.TestWindow.VsAdapters.VsProjectOutputContainerDiscoverer' :
&gt; [23.11.2017 14:46:01 Diagnostic] 	c:\users\martin\source\repos\UnableToDiscoverTests\UnableToDiscoverTests\bin\Debug\netstandard1.4\UnableToDiscoverTests.dll:executor://vsprojectoutputcontainerdiscoverer/v1
&gt; [23.11.2017 14:46:01 Diagnostic] test container discoverer executor://testexplorerservicecontainerdiscoverer/v1, discovered 0 containers
&gt; [23.11.2017 14:46:01 Diagnostic] No containers found from 'Microsoft.VisualStudio.TestWindow.Extensibility.TestExplorerServiceContainerDiscoverer' :
&gt; [23.11.2017 14:46:01 Diagnostic] test container discoverer executor://cpsprojectoutputtestcontainerdiscoverer/v2, discovered 0 containers
&gt; [23.11.2017 14:46:01 Diagnostic] No containers found from 'Microsoft.VisualStudio.TestWindow.Extensions.CPSTestContainerDiscoverer' :
&gt; [23.11.2017 14:46:01 Diagnostic] test container discoverer executor://powershelltestexecutor/v1, discovered 0 containers
&gt; [23.11.2017 14:46:01 Diagnostic] No containers found from 'PowerShellTools.TestAdapter.PowerShellTestContainerDiscoverer' :
&gt; [23.11.2017 14:46:01 Diagnostic] test container discoverer executor://nodejstestexecutor/v1, discovered 0 containers
&gt; [23.11.2017 14:46:01 Diagnostic] No containers found from 'Microsoft.NodejsTools.TestAdapter.TestContainerDiscoverer' :
&gt; [23.11.2017 14:46:01 Diagnostic] test container discoverer executor://orderedtestadapter/v1, discovered 0 containers
&gt; [23.11.2017 14:46:01 Diagnostic] No containers found from 'Microsoft.VisualStudio.MSTest.TestWindow.OrderedTestContainerDiscoverer' :
&gt; [23.11.2017 14:46:01 Diagnostic] test container discoverer executor://generictestadapter/v1, discovered 0 containers
&gt; [23.11.2017 14:46:01 Diagnostic] No containers found from 'Microsoft.VisualStudio.MSTest.TestWindow.GenericTestContainerDiscoverer' :
&gt; [23.11.2017 14:46:01 Diagnostic] test container discoverer executor://webtestadapter/v1, discovered 0 containers
&gt; [23.11.2017 14:46:01 Diagnostic] No containers found from 'Microsoft.VisualStudio.MSTest.TestWindow.WebTestContainerDiscoverer' :
&gt; [23.11.2017 14:46:01 Diagnostic] DiscoveryOperation&lt;RunAllOperation&gt; FinishedChangedCotainers, changed container count is 0
&gt; [23.11.2017 14:46:01 Diagnostic] VirtualReadOnlyTestDataStore.OperationStateChanged State=ChangeDetectionFinished, operationInProgress=False
&gt; [23.11.2017 14:46:01 Diagnostic] TestDiscoveryStats.OperationStateChanged State=ChangeDetectionFinished, InProgress=False</Description>
  </Issue>
  <Issue>
    <IssueID>2571</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Suppport for --x86 and .nunit options in nunitlite-runner.exe </Title>
    <CreatedDate>21/11/2017</CreatedDate>
    <ClosedDate>23/11/2017</ClosedDate>
    <IssueLabels />
    <Description>For the latest versions of NUnit the nunitlite-runner.exe is used as the new default to execute tests.
Is there a chance to get support for NUnit project file (*.nunit) and --x86 option for this runner as well?</Description>
  </Issue>
  <Issue>
    <IssueID>2570</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Help - Subscribe to event after TestResult.xml file is created</Title>
    <CreatedDate>18/11/2017</CreatedDate>
    <ClosedDate>18/11/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>2570</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I am extending the nunit framework and need to subscribe to an event that is triggered after TestResult.xml file has already been written.
Is there such thing? How can I do it?

Thanks.</Description>
  </Issue>
  <Issue>
    <IssueID>2569</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Unit test failed to run getting below exception, I am using version nunit version 3.6.1</Title>
    <CreatedDate>18/11/2017</CreatedDate>
    <ClosedDate>30/01/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:norepro</Name>
        <IssueID>2569</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>confirm</Name>
        <IssueID>2569</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>2017.11.17 19:03:04.318   ERROR System.IO.FileNotFoundException: Could not load file or assembly 'nunit.framework' or one of its dependencies. The system cannot find the file specified.
System.IO.FileNotFoundException: Could not load file or assembly 'nunit.framework' or one of its dependencies. The system cannot find the file specified.
File name: 'nunit.framework'
   at System.Reflection.RuntimeAssembly._nLoad(AssemblyName fileName, String codeBase, Evidence assemblySecurity, RuntimeAssembly locationHint, StackCrawlMark&amp; stackMark, IntPtr pPrivHostBinder, Boolean throwOnFileNotFound, Boolean forIntrospection, Boolean suppressSecurityChecks)
   at System.Reflection.RuntimeAssembly.nLoad(AssemblyName fileName, String codeBase, Evidence assemblySecurity, RuntimeAssembly locationHint, StackCrawlMark&amp; stackMark, IntPtr pPrivHostBinder, Boolean throwOnFileNotFound, Boolean forIntrospection, Boolean suppressSecurityChecks)
   at System.Reflection.RuntimeAssembly.InternalLoadAssemblyName(AssemblyName assemblyRef, Evidence assemblySecurity, RuntimeAssembly reqAssembly, StackCrawlMark&amp; stackMark, IntPtr pPrivHostBinder, Boolean throwOnFileNotFound, Boolean forIntrospection, Boolean suppressSecurityChecks)
   at System.Activator.CreateInstance(String assemblyString, String typeName, Boolean ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, Evidence securityInfo, StackCrawlMark&amp; stackMark)
   at System.Activator.CreateInstance(String assemblyName, String typeName, Boolean ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, Evidence securityInfo)
   at System.AppDomain.CreateInstance(String assemblyName, String typeName, Boolean ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, Evidence securityAttributes)
   at System.AppDomain.CreateInstanceAndUnwrap(String assemblyName, String typeName, Boolean ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, Evidence securityAttributes)
   at NUnit.Engine.Drivers.NUnit3FrameworkDriver.Load(String testAssemblyPath, IDictionary`2 settings)
   at NUnit.Engine.Runners.DirectTestRunner.LoadPackage()
   at NUnit.Engine.Runners.AbstractTestRunner.Load()
   at NUnit.Engine.Runners.MasterTestRunner.LoadPackage()
   at NUnit.Engine.Runners.AbstractTestRunner.EnsurePackageIsLoaded()
   at NUnit.Engine.Runners.MasterTestRunner.NUnit.Engine.ITestRunner.Explore(TestFilter filter)
   at JetBrains.ReSharper.UnitTestRunner.nUnit30.BuiltInNUnitRunner.&lt;&gt;c__DisplayClass1.&lt;RunTests&gt;b__0()
   at JetBrains.ReSharper.UnitTestRunner.nUnit30.BuiltInNUnitRunner.WithExtensiveErrorHandling(IRemoteTaskServer server, Action action)</Description>
  </Issue>
  <Issue>
    <IssueID>2566</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>OmicronPersei</FixedById>
        <IssueID>2566</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Refactor `SimpleEnumerableWithIEquatable` test object</Title>
    <CreatedDate>17/11/2017</CreatedDate>
    <ClosedDate>17/11/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2566</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:refactor</Name>
        <IssueID>2566</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:low</Name>
        <IssueID>2566</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>As mentioned in pull request #2528 , the public property `SimpleEnumerableWithIEquatable.Contents` is initialized but is redundant because both class constructors initialize it.  It should be refactored.</Description>
  </Issue>
  <Issue>
    <IssueID>2564</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Add minClientVersion to .nuspec files</Title>
    <CreatedDate>16/11/2017</CreatedDate>
    <ClosedDate>08/12/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2564</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>help wanted</Name>
        <IssueID>2564</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>2564</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>2564</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>We recently discovered ( that our NuGet packages require a NuGet client version of at least 2.12. We should add the `minClientVersion` element to our nuspecs, so users get a better experience for this.

Whoever looks into this should check that 2.12 is actually the correct version, and we're not using any features only added in later versions of the NuGet client. </Description>
  </Issue>
  <Issue>
    <IssueID>2561</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Tests with Test attribute and arguments  show an unexpected behaviour.</Title>
    <CreatedDate>14/11/2017</CreatedDate>
    <ClosedDate>14/11/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>2561</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>del. Wrong issue</Description>
  </Issue>
  <Issue>
    <IssueID>2560</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>There is no `Does.All` for to migrate `Text.All`</Title>
    <CreatedDate>14/11/2017</CreatedDate>
    <ClosedDate>14/11/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2560</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:docs</Name>
        <IssueID>2560</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I'm migrating framework v2 to v3. I read  to see:

&gt; Assertions and Constraints
&gt; Text.All | No longer supported. Use Does.All

In NUnit 3.9.0 there is no `Does.All` which I can use to migrate `Text.All` as I expected.
</Description>
  </Issue>
  <Issue>
    <IssueID>2559</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>failing test due to whitespace</Title>
    <CreatedDate>13/11/2017</CreatedDate>
    <ClosedDate>13/11/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2559</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>2559</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>@LesediM commented on [Mon Nov 13 2017](**Test Cases**

`[TestCase(0, "R 0.00")]`
          `[TestCase(1000, "R 1\u0020000.00")]`
           ` [TestCase(10000, "R 10 000.00")]`
`            public void GivenValueHasValue_ShouldReturnValueAsSouthAfricanCurrency(decimal amount, string expectedValue)`
`            {`
`                var result = PayfastTransactionCommon.FormatAsCurrency(amount);`
`                Assert.That(result, Is.EqualTo(expectedValue));`
`            }`

**Code being tested**
` public static string FormatAsCurrency(decimal? amount)`
        `{`
            `return amount.HasValue`
              `  ? $"R {amount:N}"`
              `  : string.Empty;`
      `  }`

First test case passes but the latter test cases fail. 
Am I missing something or doing something wrong?
Nunit version is 3.8.1.0---@CharliePoole commented on [Mon Nov 13 2017](You filed this as an issue against our documentation. I'm moving it to the proper repository.</Description>
  </Issue>
  <Issue>
    <IssueID>2558</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>TestContext.WriteLine does not properly capture output when called by Process.OutputDataReceived</Title>
    <CreatedDate>11/11/2017</CreatedDate>
    <ClosedDate>12/11/2017</ClosedDate>
    <IssueLabels />
    <Description>I'm seeing a case where NUnit does not properly capture test output and attach it to specific test cases. I think I've found a workaround so I'm creating this issue to mostly figure out if this is the best way and if it's possible for NUnit to handle it itself. I've created a [gist]( demonstrating the issue. I'm using NUnit 3.9 with the VS NUnit3TestAdapater.

The issue I'm having is that when I call TestContext.WriteLine from Process.OutputDataReceived the output is lost and not attached to the specific test case. NUnit generally seems to be able to properly capture output when called from other threads spawned during the test so this caught me by surprise. I'm not sure what's different about the Process.OutputDataReceived event. Note that this is just a simplified version of my actual code where what I'm trying to do is capture all my internal logs (via NLog if that matters) and capture them in the test output.

My work around is to capture the current TestExecutionContext in the setup method and log directly to that. Uncomment the setup/teardown methods in the gist to see it working as intended. I will probably have to write a custom target for NLog in my code, but that's not hard. Is this the best way to do this? Is this something that NUnit could handle automatically? Why is NUnit able to handle other cases where threads are spawned in tests?
</Description>
  </Issue>
  <Issue>
    <IssueID>2557</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Test won't start IIS Express</Title>
    <CreatedDate>11/11/2017</CreatedDate>
    <ClosedDate>12/11/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>2557</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>@martinRocks commented on [Fri Nov 10 2017](I'm using Visual Studio 2017 Professional 15.4.3 with resharper installed.  When I run the Selenium UI tests using the resharper's runner, IIS Express starts.  However, when I run the test with the VS Test Explorer, IIS Express doesn't start.  I have NUnit3TestAdapter 3.9 installed to make the NUnit show up in the test explorer.

I'm starting IIS as a new process in the base class.

I have created a small demo project of exactly what I'm doing.
NUnit: 3.8.1
NUnit3TestAdapter:3.9.0
.net platform 4.7
[NunitDemo.zip](
---@CharliePoole commented on [Sat Nov 11 2017](Issue title confused me, making me think you were using the NUnit Explore API to examine tests, hence the title edit.

Two suggestions:
1. Debug your OneTimeSetUp method to make sure everything works as expected.
2. See if a brief wait for the process to actually start solves the problem.---@martinRocks commented on [Sat Nov 11 2017](Sorry about the confusion. 

I have used the StartIisExpress method in a number of different projects without any problems.  And when I run the test with resharper, IIS starts.  However, when I run it with Visual Studio's test explorer, the process doesn't start.  

I tried adding a Thread.Sleep(5000); before and after the _iisProcessExpress.Start(); without any luck.

Thank you for the suggestions.---@CharliePoole commented on [Sat Nov 11 2017](I'd be curious to know if it works when running under nunit3-console.exe. That would help narrow down the problem quite a bit: if it does work, it's an adapter problem, if not possibly an nunit problem. FYI, the fact that it runs with R# would give us more info, if we actually understood how R# runs NUnit. 😄 ---@martinRocks commented on [Sat Nov 11 2017](I completely understand about R#.  It does a ton of things I wish I understand better :)

I just tried the console runner (NUnit.ConsoleRunner.3.7.0) and it acted just like VS's test explorer.  I.E. the IIS Express process didn't start.  

Also, I just upgraded NUnit to version 3.9.0

Does that mean that this is a problem with NUnit?---@CharliePoole commented on [Sat Nov 11 2017](Most likely it is. I'm moving this to the NUnit repo.</Description>
  </Issue>
  <Issue>
    <IssueID>2555</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>CI timeout: NUnit.Framework.Assertions.CollectionAssertTest.PerformanceTests</Title>
    <CreatedDate>10/11/2017</CreatedDate>
    <ClosedDate>12/12/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2555</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:build</Name>
        <IssueID>2555</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:critical</Name>
        <IssueID>2555</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>It's only .NET Framework 3.5 for most CI errors, it seems.

&gt; 1) Failed : NUnit.Framework.Assertions.CollectionAssertTest.PerformanceTests(System.Linq.Enumerable+&lt;RangeIterator&gt;d__b1)
&gt; Elapsed time of 174.8091ms exceeds maximum of 100ms
&gt; 2) Failed : NUnit.Framework.Assertions.CollectionAssertTest.PerformanceTests(System.Collections.Generic.List`1[System.Double])
&gt; Elapsed time of 201.1894ms exceeds maximum of 100ms



Just need to bump up the timeout, I think.</Description>
  </Issue>
  <Issue>
    <IssueID>2552</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>EqualConstraint.Using&lt;TCollectionType, TMemberType&gt; causes ambiguity</Title>
    <CreatedDate>09/11/2017</CreatedDate>
    <ClosedDate>09/11/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>design</Name>
        <IssueID>2552</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>2552</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>cs
EqualTo(value).Using&lt;int&gt;((a, b) =&gt; a.MyEquals(b));


I'd also like to enable this syntax:
cs
EqualTo(value).Using((int a, int b) =&gt; a.MyEquals(b));
`</Code>
    <Description>We added `EqualConstraint.Using&lt;T&gt;(Func&lt;T, T, bool&gt;)` in  which enables this syntax:

``

The reason why this doesn't already work with the very same overload is that it's ambiguous with this overload which has a different generic arity:



It was added in  and I don't know why. It looks vestigial.
Why would we want to have basically the same thing as the `Using&lt;T&gt;` overload, but with the ability for the parameter types to differ? And why is a `TCollection`-related thing here and not on CollectionItemsEqualConstraint?

Can we remove it so that type arguments can be inferred?</Description>
  </Issue>
  <Issue>
    <IssueID>2551</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>jnm2</FixedById>
        <IssueID>2551</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>CollectionItemsEqualConstraint is missing Using(Func&lt;T, T, bool&gt;)</Title>
    <CreatedDate>09/11/2017</CreatedDate>
    <ClosedDate>10/11/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2551</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>2551</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>2551</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description> added this overload to EqualConstraint but we've gone out of sync with `CollectionItemsEqualConstraint` and someone has already asked for it. Since EqualConstraint's overload is first appearing in 3.9, I'd really like to get this in 3.9.

The implementation spec is to duplicate what @david-proctor did in  but for CollectionItemsEqualConstraint.

Any objections?</Description>
  </Issue>
  <Issue>
    <IssueID>2545</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Dynamic userdefined Compares and EqualityComparers with Using</Title>
    <CreatedDate>08/11/2017</CreatedDate>
    <ClosedDate>09/11/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2545</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>2545</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>if myNumbers is an array of integers, this should work:
`Assert.That(myNumbers, Is.Unique.Using((x,y) =&gt; x % 256 == y % 256));`
`Assert.That(myNumbers, Is.Unique.Using((x, y) =&gt; (x % 256).CompareTo(y % 256)));`

The only thing that works doesn't look quite fine:
`Assert.That(myNumbers, Is.Unique.Using((Comparison&lt;int&gt;)((x, y) =&gt; (x % 256).CompareTo(y % 256))));`

The cast is needed because of the untyped Usings:
`public CollectionItemsEqualConstraint Using(IComparer comparer);`
`public CollectionItemsEqualConstraint Using(IEqualityComparer comparer);`

My suggest is to remove the untyped Usings for compilation for .NET 4.x and to make onother overload:
`public delegate bool EqualityComparison&lt;in T&gt;(T x, T y);`
`public CollectionItemsEqualConstraint Using&lt;T&gt;(EqualityComparison&lt;T&gt; comparer);`</Description>
  </Issue>
  <Issue>
    <IssueID>2543</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>RetryAttribute not support TestFixture/Assembly level, also not support retry in case of exceptions</Title>
    <CreatedDate>08/11/2017</CreatedDate>
    <ClosedDate>09/11/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:duplicate</Name>
        <IssueID>2543</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Current Retry-Attribute:


&gt; RetryAttribute  is used on a test method to specify that it should be rerun if it fails, up to a maximum number of times.
&gt; Notes:
&gt; It is not currently possible to use RetryAttribute on a TestFixture or any other type of test suite. Only single tests may be repeated.
&gt; If a test has an unexpected exception, an error result is returned and it is not retried

My FR is:
1. Assembly level:
**I need this support in assembly level (I use SpecFlow and need global configuration to run each test once again if failed**
2. Retry also if failed for unknown exception, this is meaningless if it only retry just if assertion was failed, I need it to retry for any failure

Clarification:
What I meant by Assembly level is that is should work exactly like it was declared on all methods,
so if 1 test failed - rerun only it, not the entire assembly / fixture</Description>
  </Issue>
  <Issue>
    <IssueID>2542</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>jnm2</FixedById>
        <IssueID>2542</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>NUnit does not support parallelism on .NET Core 2.0</Title>
    <CreatedDate>08/11/2017</CreatedDate>
    <ClosedDate>12/12/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2542</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>2542</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>2542</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>It is known, but very critical issue for those, who use nunit as testframework for .net core 2.0 targer. In some cases it is not possible to use target framework different from .net core.  Parallelism is critical feature and test society need to know should they build they test system for .net core based on nunit or migrate to other test frameworks</Description>
  </Issue>
  <Issue>
    <IssueID>2540</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>2540</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Nunit 3.9 Release</Title>
    <CreatedDate>07/11/2017</CreatedDate>
    <ClosedDate>11/11/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2540</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:build</Name>
        <IssueID>2540</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>2540</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I am planning on releasing 3.9 this week. I still need to scan through the open issues and see if there are other high priority issues that should be included. If anyone has candidates, please add them to the milestone and we can discuss here.</Description>
  </Issue>
  <Issue>
    <IssueID>2539</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Equality assert for Tuple instances does not work when items are arrays</Title>
    <CreatedDate>07/11/2017</CreatedDate>
    <ClosedDate>07/11/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:duplicate</Name>
        <IssueID>2539</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I am using NUnit 3.6.0.0 via Resharper Test Runner in Visual Studio.
The following test A fails:
``
Is there a way to make the last Assert statement in Test A succeed, too? Why does it fail? Test B succeeds without any problem.

I am passing Tuple instances to my test framework which internal just calls 'Assert.That(object1, Is.EqualTo(object2))`, so I cannot just check the Tuple's items individually for equality.</Description>
  </Issue>
  <Issue>
    <IssueID>2536</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>jnm2</FixedById>
        <IssueID>2536</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>SetArgDisplayNames for TestCaseData and TestFixtureData</Title>
    <CreatedDate>07/11/2017</CreatedDate>
    <ClosedDate>10/07/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>2536</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>2536</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>diff
namespace NUnit.Framework
{
    public class TestCaseData
    {
+       public TestCaseData SetArgDisplay(params string[] names);
    }
    public class TestFixtureData
    {
+       public TestFixtureData SetName(string name);
+       public TestFixtureData SetName(params string[] names);
    }
}


Usage example for TestFixtureData: `.SetArgDisplay("Issue-2464")`

NUnit.Framework.Internal.Execution.ParallelExecutionTests(Issue-2464).AllTestsPassed


TestCaseData usage example:

cs
// x = new Person { Name = "Stewart {C} Robertson" }, y = 42
new TestCaseData(x, y, z).SetArgDisplay(x.Name, y)


Resulting test name:

Namespace.FixtureName.MethodName(Stewart {C} Robertson, 42)
`</Code>
    <Description>##### Edit: `TestFixtureData.SetName` is being made public again after we pulled it from 3.9 now that the behavior is consistent with `TestCaseData`

`TestCaseData.SetName` leaves you in an impossible situation explored by  if you are forced to customize parameterized test names and the parameter names contain curlies. To summarize:

&gt; The thing that makes me uncomfortable here is that NUnit forces us to use SetName because otherwise the autogenerated test names collide, which in turn forces us to replace curlies with some other character. Feature holes are fine unless the feature is forced on you.

/cc @stewart-r as promised, who said:

&gt; Maybe I am guilty of seeing the world through the prism of my own recent experience but I have to say am really surprised that it doesn't seem to affect more people. People test edge cases, any strings with curly braces are edge cases for string manipulation code.... where is the tsunami!?? :-p

Also to say nothing of the escaping problems we ran into with curlies, `SetName` is just plain verbose. The style just about everyone wants to use, and I agree with them, is `"{m}(" + string.Join(", ", customParameterNames) + ")"`.

We explored different alternatives and this is the only one that addresses all my concerns, @stewart-r's concerns, and @oznetmaster's concerns with the `SetName` being added to `TestFixtureSource` (

``

`SetArgDisplay` fills a need that no other solution fills. It's urgent for my real world use cases. If I implement it in time for 3.9, it also allows us to remove `TestFixtureData.SetName` until we have a proper discussion about expansions and escaping (and whether we'd even want it). Thus I'm marking this design discussion pri:high.</Description>
  </Issue>
  <Issue>
    <IssueID>2534</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>SetUpFixture causes NUnit to lock with Apartment( STA )</Title>
    <CreatedDate>06/11/2017</CreatedDate>
    <ClosedDate>06/11/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:duplicate</Name>
        <IssueID>2534</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Reproduction:


Having both `[assembly: Apartment( ApartmentState.STA )]` and a type marked as `[SetUpFixture]` in a test project will cause the tests to lock up. Reproductible with both the NUnit console runner and R# test runner.

The Apartment attribute may be defined on either assembly level or type level with the same results.

``</Description>
  </Issue>
  <Issue>
    <IssueID>2533</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>jnm2</FixedById>
        <IssueID>2533</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Matches&lt;T&gt;(Predicate&lt;T&gt;) throws ArgumentException or Fails when actual is null</Title>
    <CreatedDate>06/11/2017</CreatedDate>
    <ClosedDate>09/11/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2533</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>2533</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>2533</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>csharp
[TestFixture]
public class MatchesPredicateTests {

    [Test]
    public void HasAll_Matches_predicate_fails_When_actual_is_null_string() {
        var actuals = new[] {"", null};
        Predicate&lt;String&gt; predicate = o =&gt; (o == null) || (o == String.Empty);

        Assert.That(actuals, Has.All.Null.Or.Empty); // &lt;-- Success
        Assert.That(actuals, Has.All.Matches(predicate)); // &lt;-- Failure
    }

    [Test]
    public void Matches_predicate_fails_When_actual_is_null_string() {
        var actuals = new[] {"", null};
        Predicate&lt;String&gt; predicate = o =&gt; (o == null) || (o == String.Empty);

        foreach (String actual in actuals) {
            Assert.That(actual, Is.Null.Or.Empty); // &lt;-- Success
            Assert.That(actual, Is.TypeOf&lt;String&gt;().And.Matches(predicate)); // &lt;-- Failure
        }
    }

    [Test]
    public void HasAll_Matches_predicate_fails_When_actual_is_null_int() {
        var actuals = new Int32?[] {0, null};
        Predicate&lt;Int32?&gt; predicate = o =&gt; (o == null) || (o == 0);

        Assert.That(actuals, Has.All.Null.Or.Zero); // &lt;-- Success
        Assert.That(actuals, Has.All.Matches(predicate)); // &lt;-- Failure
    }

    [Test]
    public void Matches_predicate_fails_When_actual_is_null_int() {
        var actuals = new Int32?[] {0, null};
        Predicate&lt;Int32?&gt; predicate = o =&gt; (o == null) || (o == 0);

        foreach (Int32? actual in actuals) {
            Assert.That(actual, Is.Null.Or.Zero); // &lt;-- Success
            Assert.That(actual, Is.TypeOf&lt;Int32?&gt;().And.Matches(predicate)); // &lt;-- Failure
        }
    }

}
`</Code>
    <Description>**Class:** `NUnit.Framework.Constraints.ConstraintExpression`
**Method:** `Constraint Matches&lt;TActual&gt;(Predicate&lt;TActual&gt; predicate)`

Hello,
I'm trying to use the Matches constraint that takes a predicate but I'm getting an ArgumentException:

&gt; System.ArgumentException : The actual value is not of type String
&gt; Parameter name: actual

or the test fails:

&gt; Expected: &lt;System.String&gt; and value matching lambda expression
&gt; But was:  null

I would expect the test to succeed/pass without an exception.

The same can be achieved with the Null.Or.Empty constraint, but I need to provide the predicate as parameter to the test method and the parameter cannot depend to the NUnit framework.

I'm assuming that the problem is at the [line 70 of the PredicateConstraint]( but I can be wrong.
It checks if the actual passed to the ApplyTo method is of the type defined in the predicate. Since the actual passed is null, the check fails.

Thank you for your time.

## Test code:
``
</Description>
  </Issue>
  <Issue>
    <IssueID>2419</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>WorkItemQueue (get_IsEmpty) Not Working</Title>
    <CreatedDate>06/09/2017</CreatedDate>
    <ClosedDate>06/09/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:duplicate</Name>
        <IssueID>2419</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Hi,

Please see stack trace below. This happens when I run my tests on our build server.

I think this is related to similar issues around WorkItemQueue.

``

</Description>
  </Issue>
  <Issue>
    <IssueID>2418</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>david-proctor</FixedById>
        <IssueID>2418</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Support equality comparison delegate</Title>
    <CreatedDate>05/09/2017</CreatedDate>
    <ClosedDate>26/09/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2418</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>good first issue</Name>
        <IssueID>2418</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>2418</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:low</Name>
        <IssueID>2418</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>cs
Is.EqualTo(...).Using&lt;Foo&gt;((x, y) =&gt; x.CompareTo(y)))


The delegate returns `int` which allows you to pick one: equal, greater than, or less than. It's a sorting comparison rather than an equality comparison.

I have a similar scenario with objects in a third party library that provide `IsEqual` but do not override `Equals` (:thinking:...). This should work:

cs
Is.EqualTo(...).Using&lt;Foo&gt;((x, y) =&gt; x.IsEqual(y)))


But because it returns `bool` rather than `int`, it does not work. I am forced to arbitrarily convert equal/inequal to either 0/1 (equal/greater than) or 0/-1 (equal/less than). I don't like this because an ordering comparison does not make sense in this context, only a pure equality comparison.

cs
Is.EqualTo(...).Using&lt;Foo&gt;((x, y) =&gt; x.IsEqual(y) ? 0 : 1))


In my opinion, I should be able to return a `bool` directly from any arbitrary delegate and NUnit should use it like it uses `bool IEqualityComparer&lt;&gt;.Equals` similar to the effect of this final workaround:

cs
private sealed class FooEqualityComparer : IEqualityComparer&lt;Foo&gt;
{
    public static FooEqualityComparer Instance { get; } = new FooEqualityComparer();
    private FooEqualityComparer() { }

    public bool Equals(Foo x, Foo y) =&gt; x.IsEqual(y);

    // I don't even want to think about implementing the hash code on this property bag.
    public int GetHashCode(Foo obj) =&gt; 0;
}
`</Code>
    <Description>This is already possible today:

``</Description>
    <PullRequests />
  </Issue>
  <Issue>
    <IssueID>2416</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Question: Using [Parallelizable] with single assembly</Title>
    <CreatedDate>04/09/2017</CreatedDate>
    <ClosedDate>05/09/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2416</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>2416</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>We are using SpecFlow, and have a single test assembly with approx 2000 tests defined. They currently take approx. 14hours to run, so I've been experimenting with running the tests in Parallel using the new [Parallelizable] attribute.

However, it seems that all the parallelization options (--workers, --agents, etc) all rely on a single process being responsible for a test assembly. If I need to run these in parallel, it seems like I am required to separate my test assembly.

Is this correct?

The only other option I can see, is to run nunit-console --explore to get the list of tests to run, then manually start n x nunit-console processes to run the tests. </Description>
  </Issue>
  <Issue>
    <IssueID>2414</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Specflow 2.1 and below attribute dependency</Title>
    <CreatedDate>04/09/2017</CreatedDate>
    <ClosedDate>18/05/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>design</Name>
        <IssueID>2414</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Specflow 2.1 and below are dependent on the TestFixtureSetUpAttribute and TestFixtureTeaeDownAttribute

Whilst these are marked as obsolete in 3.7 and specflow updated not to use them
An nunit 3.8 update forces a specflow update which is not always possible.

Proposal from #2410 was to create issue to re-adding these attributes to allow older specflow to work with newer nunit.

For information, specflow issue  updated their usage of attributes</Description>
  </Issue>
  <Issue>
    <IssueID>2412</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>mikkelbu</FixedById>
        <IssueID>2412</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Using fluent syntax unintentionally removed in 3.8</Title>
    <CreatedDate>04/09/2017</CreatedDate>
    <ClosedDate>05/10/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>2412</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>&gt; From @BlythMeister on 
&gt;  with regard to the example code, we had
&gt; Assert.That(myCollection, Contains.Item(expectedItem).Using(new MyCustomComparer()));
&gt; The .Using fluent method existed in 3.7, but was removed in 3.8.
&gt; I was unable to find an equivalent, so changed to
&gt; Assert.That(myCollection.Contains(expectedItem, new MyCustomComparer()));
&gt; Which was a simple enough change as a 1 off, but we had around 100 usages of that old syntax with different collection names, expected names as comparers (across different projects)

This change was unintentional - the removal of CollectionContainsConstraint wasn't intended to cause any breaking changes. 

@mikkelbu did the below analysis of what happened:

&gt; @BlythMeister This is very unfortunate. Actually, @ChrisMaddock spotted the missing Using in aa19bd1 (see #2239 (comment)), so we added Using to the EqualConstraint in bd2091b. However, the entire PR did contain an error, so Contains.Item was again changed in 15c27e5 to return a ContainsConstraint instead of a EqualConstraint. And currently ContainsConstraint does not have a Using method.

@rprouse - will leave you to decide if this should be critical or not, possibly along with  - I haven't looked into that one.</Description>
    <PullRequests />
  </Issue>
  <Issue>
    <IssueID>2411</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>mikkelbu</FixedById>
        <IssueID>2411</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>And constraint on Has.Member throws</Title>
    <CreatedDate>04/09/2017</CreatedDate>
    <ClosedDate>05/10/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>2411</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>
var donkey = new object();
var mule = new object();
Assert.That(new[] { donkey }, Has.Member(donkey).And.No.Member(mule));

Fails with this exception in 3.8.1


System.ArgumentException : The actual value must be an IEnumerable
Parameter name: actual
   at NUnit.Framework.Constraints.SomeItemsConstraint.ApplyTo[TActual](TActual actual) in D:\git\nunit\src\NUnitFramework\framework\Constraints\SomeItemsConstraint.cs:line 64
   at NUnit.Framework.Constraints.NotConstraint.ApplyTo[TActual](TActual actual) in D:\git\nunit\src\NUnitFramework\framework\Constraints\NotConstraint.cs:line 48
   at NUnit.Framework.Constraints.AndConstraint.ApplyTo[TActual](TActual actual) in D:\git\nunit\src\NUnitFramework\framework\Constraints\AndConstraint.cs:line 64
   at NUnit.Framework.Constraints.SomeItemsConstraint.ApplyTo[TActual](TActual actual) in D:\git\nunit\src\NUnitFramework\framework\Constraints\SomeItemsConstraint.cs:line 65
   at NUnit.Framework.Assert.That[TActual](TActual actual, IResolveConstraint expression, String message, Object[] args) in D:\git\nunit\src\NUnitFramework\framework\Assert.That.cs:line 245
   at NUnit.Framework.Assert.That[TActual](TActual actual, IResolveConstraint expression) in D:\git\nunit\src\NUnitFramework\framework\Assert.That.cs:line 228
   at Granta.Services.FunctionalData.Tests.ParameterValueExtraction.ParameterSingleValuesExtractorDatabaseTests.MethodUsingObjectsFailsInDifferentManner() in D:\git\servicelayer\FunctionalDataTests\ParameterValueExtraction\ParameterSingleValuesExtractorDatabaseTests.cs:line 59
`</Code>
    <Description>An example

``

This is a regression from 3.6 and I suspect was introduced by #2239. 
The right hand constraint of the `And` is getting evaluated against each item of the array instead of against the enumerable. I have tried stepping through and figuring out where things go wrong but without success. 

I *presume* I am using the API correctly - I expected the assertion to check that the array contained `donkey` and did not contain `mule`. If I am wrong, I would appreciate some guidance on how to chain these constraints using the fluent API - or should one write 2 separate assertions?</Description>
    <PullRequests />
  </Issue>
  <Issue>
    <IssueID>2409</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>AbortOrKillThreadWithMessagePump fails on my PC</Title>
    <CreatedDate>02/09/2017</CreatedDate>
    <ClosedDate>02/09/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>2409</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>&gt;Test Name:	AbortOrKillThreadWithMessagePump_StressTest
Test FullName:	NUnit.Framework.Internal.ThreadUtilityTests.AbortOrKillThreadWithMessagePump_StressTest
Test Source:	C:\GitRepos\nunit\src\NUnitFramework\tests\Internal\ThreadUtilityTests.cs : line 75
Test Outcome:	Failed
Test Duration:	0:00:15.123

Running on my PC (Windows 10, intel core i7 dual core), executing using the NUnit test adapter in VS2017.
</Description>
    <PullRequests />
  </Issue>
  <Issue>
    <IssueID>2408</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Enable constraints to return an inconclusive message</Title>
    <CreatedDate>01/09/2017</CreatedDate>
    <ClosedDate>02/09/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:wontfix</Name>
        <IssueID>2408</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:idea</Name>
        <IssueID>2408</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>cs
Assert.That(foo, IsIdenticalCopy.Of(bar))


and have it sometimes return a message and an inconclusive state.
Because that inconclusive part is really important, I'm probably going to have to forgo constraints:

cs
IsIdenticalCopy.Assert(foo, bar);
`</Code>
    <Description>I just ran into a scenario where it would be cool to do:

``

If I had to guess, it doesn't seem like a complex type of thing to implement.
Does this sound interesting?

</Description>
  </Issue>
  <Issue>
    <IssueID>2405</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>ChrisMaddock</FixedById>
        <IssueID>2405</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Improve PropertyConstraint error output</Title>
    <CreatedDate>01/09/2017</CreatedDate>
    <ClosedDate>10/03/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>2405</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>2405</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I normally get far too distracted by interesting but niche things. This is one that bites me almost daily. 

I use PropertyConstraint a lot - this is the error message that's currently shown when the property can't be found on the object.

![image](

I hit this regularly - either because my constraint is not actually on the object I think it is, because I go the property name wrong, or because I'm trying to look at an [explicit interface implementation](

I want to improve this so it provides a proper error message rather than stack trace. What I'm interested in seeing is:

1. The property name I was looking for. (I almost always use `nameof()` here - maybe the string passed in wasn't what I thought)
1. The type of the object I'm looking for the property on.

I'll PR this at some point - any other suggestions before I do? I considered listing all available property names - but decided against it as it could get noisy quickly. </Description>
  </Issue>
  <Issue>
    <IssueID>2404</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>OneTimeSetUp fails requiring undocumented "context" parameter</Title>
    <CreatedDate>01/09/2017</CreatedDate>
    <ClosedDate>01/09/2017</ClosedDate>
    <IssueLabels />
    <Description>Disregard. Please close or delete.</Description>
  </Issue>
  <Issue>
    <IssueID>2403</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>OSX Job on Travis takes forever to start</Title>
    <CreatedDate>01/09/2017</CreatedDate>
    <ClosedDate>01/09/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>2403</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Notice after 41 minutes the job still hasn't started.

![alt](

Refers to [this]( build.</Description>
  </Issue>
  <Issue>
    <IssueID>2402</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>netonjm</FixedById>
        <IssueID>2402</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>--labels=All doesn't show anything in console output executing NUnitLite Console Runner</Title>
    <CreatedDate>31/08/2017</CreatedDate>
    <ClosedDate>10/10/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2402</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>2402</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>2402</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Hello!

Seems I am getting an issue with the --labels=All. Seems this argument is not showing any output while executing the nunitlite console runner (from master 3256c91) over a my test library. 

Doing some debugging over the console runner I realized every result here:


It gets an empty Output value (this is correct?), and because this we never reach _displayBeforeOutput check to show Test.Fullname.

Also @CharliePoole would be fantastic include additional information here like the Duration in the same line, to catch timeout issues or if our runner is killed for some reason and we don't have the result file generated.

Thanks for your hard work guys it's awesome!</Description>
    <PullRequests />
  </Issue>
  <Issue>
    <IssueID>2400</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Linux CI failure</Title>
    <CreatedDate>31/08/2017</CreatedDate>
    <ClosedDate>20/01/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:duplicate</Name>
        <IssueID>2400</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>

``</Description>
  </Issue>
  <Issue>
    <IssueID>2399</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Investigate enabling any framework team member to restart the CI builds</Title>
    <CreatedDate>30/08/2017</CreatedDate>
    <ClosedDate>08/09/2017</ClosedDate>
    <IssueLabels />
    <Description>Right now I think only @CharliePoole and @rprouse can restart builds on these:

 - AppVeyor PR build
 - AppVeyor branch build

All of us can restart builds on these:

 - Travis PR build
 - Travis branch build

In an ideal world I'd say all @nunit/framework-team members and only @nunit/framework-team members should be able to restart each of these four. Do you agree? How close to that can we get?

@CharliePoole Also, AppVeyor lists our builds under your name. Does that have anything to do with it? Should we try a brand new AppVeyor setup?</Description>
  </Issue>
  <Issue>
    <IssueID>2398</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>jnm2</FixedById>
        <IssueID>2398</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>NUnit CI spurious failures, NUnit.Framework.Internal.ThreadUtilityTests.Kill</Title>
    <CreatedDate>30/08/2017</CreatedDate>
    <ClosedDate>31/08/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2398</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>2398</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>2398</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Too frequently I see NUnit's CI fail due to the below failure:
&gt;1) Failed : NUnit.Framework.Internal.ThreadUtilityTests.Kill
  Native message pump was not able to be interrupted to enable a managed thread abort.
  Expected: True
  But was:  False
   at NUnit.Framework.Internal.ThreadUtilityTests.AbortOrKillThreadWithMessagePump(Boolean kill)

as seen [here](</Description>
  </Issue>
  <Issue>
    <IssueID>2396</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Using bindingRedirect with codeBase when running in TeamCity</Title>
    <CreatedDate>29/08/2017</CreatedDate>
    <ClosedDate>28/04/2019</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>confirm</Name>
        <IssueID>2396</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Hi.

I have a unit test project, where I need to test that we are using the correct versions of Newtonsoft.Json in different parts of our code.

In order to do that, I need to include multiple version of Newtonsoft.Json.dll in the project. I do that with the following app.config:

    &lt;?xml version="1.0" encoding="utf-8"?&gt;
    &lt;configuration&gt;
      &lt;appSettings&gt;
        &lt;add key="mytest" value="itshere"/&gt;
      &lt;/appSettings&gt;
      &lt;runtime&gt;
        &lt;assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1"&gt;
          &lt;dependentAssembly&gt;
            &lt;assemblyIdentity name="Newtonsoft.Json" publicKeyToken="30AD4FE6B2A6AEED" culture="neutral" /&gt;
            &lt;bindingRedirect oldVersion="0.0.0.0-6.0.0.0" newVersion="6.0.0.0" /&gt;
            &lt;bindingRedirect oldVersion="7.0.0.0-10.0.0.0" newVersion="10.0.0.0" /&gt;
            &lt;codeBase version="6.0.0.0" href="Newtonsoft.Json.6.0.8/Newtonsoft.Json.dll" /&gt;
            &lt;codeBase version="10.0.0.0" href="Newtonsoft.Json.10.0.0.3/Newtonsoft.Json.dll" /&gt;
          &lt;/dependentAssembly&gt;
        &lt;/assemblyBinding&gt;
      &lt;/runtime&gt;
    &lt;/configuration&gt;

I have included the two dll's in my project, and set them to "Copy always", so they are placed in the `/bin/Debug/` folder.

I use the ConsoleRunner to execute the test, and if I do this they pass:

`packages\NUnit.ConsoleRunner.3.7.0\tools\nunit3-console.exe src\Website.Tests\bin\Debug\Website.Tests.dll`

However, TeamCity will run the tests as a nunit project file, so if I create a `test.nunit` project file like this:

    &lt;NUnitProject&gt;
        &lt;Settings activeconfig="active" appbase="C:\Projects\MyProject"/&gt;
        &lt;Config name="active"&gt;
            &lt;assembly path="src\Website.Tests\bin\Debug\Website.Tests.dll"/&gt;
        &lt;/Config&gt;
    &lt;/NUnitProject&gt;

And run the tests with this command:

`packages\NUnit.ConsoleRunner.3.7.0\tools\nunit3-console.exe test.nunit`

The the tests fail, and I get the exception:

`System.IO.FileNotFoundException : Could not load file or assembly 'Newtonsoft.Json, Version=6.0.0.0, Culture=neutral, PublicKeyToken=30ad4fe6b2a6aeed' or one of its dependencies. The system cannot find the file specified.`

I assume that this is because the path to the dll's supplied in my app.config file no longer match the working directory of the process.

Is there a way to get this working?

Either by getting teamcity to not use a project for testing, or by setting the workingdirectory in a way so my assembly redirects will work?

As a note, I have confirmed that the app.config is available, by reading the "mytest" app setting, and that works.</Description>
  </Issue>
  <Issue>
    <IssueID>2395</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>2395</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>NUnit 3.8+ does not finish running tests</Title>
    <CreatedDate>29/08/2017</CreatedDate>
    <ClosedDate>01/11/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>2395</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:critical</Name>
        <IssueID>2395</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>There seems to be some kind of deadlock going on since NUnit 3.8.0 (I have tried 3.8.1 as well). My tests run fine but when all tests are done NUnit never completes the test run and one CPU remains maxed out until the process is killed.

I am experiencing the same problem with both the console runner and the runner in CodeRush for Roslyn.

I attached a debugger to nunit-agent.exe and this is how my threads look like while this is happening, thread 6488 in my screenshot is the one using all the CPU.

![image](</Description>
  </Issue>
  <Issue>
    <IssueID>2392</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Snapshot Testing ala Jest</Title>
    <CreatedDate>28/08/2017</CreatedDate>
    <ClosedDate>18/05/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:idea</Name>
        <IssueID>2392</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Hello,
I was wondering if there was any desire from the community to introduce a new feature to NUnit - Snapshot Testing. This type of testing had gained traction from the Jest framework and you can read about it [here](  Essentially whatver blob you want to ensure does not change as part of a unit test you can take a "snapshot" of through some manner of serialization.  This snapshot is then added to your source code.  When the underlying blob changes the snapshot test fails and you have the option to update the snapshot or fix whatever broke.  One of the main advantages to this is a nice visual diff when something in the blob changes, as it is part of source control.  Thoughts?</Description>
  </Issue>
  <Issue>
    <IssueID>2390</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>2390</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Missing value attribute in test parameters setting causes NullReferenceException in console</Title>
    <CreatedDate>28/08/2017</CreatedDate>
    <ClosedDate>29/08/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2390</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>2390</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:critical</Name>
        <IssueID>2390</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>c#
Run Settings
    DisposeRunners: True
    WorkDirectory: [redacted]
    TestParametersDictionary: System.NullReferenceException: Object reference not set to an instance of an object.
   at NUnit.ConsoleRunner.ColorConsoleWriter.WriteLabel(String label, Object option, ColorStyle valueStyle)
   at NUnit.ConsoleRunner.ColorConsoleWriter.WriteLabelLine(String label, Object option, ColorStyle valueStyle)
   at NUnit.ConsoleRunner.ResultReporter.WriteRunSettingsReport()
   at NUnit.ConsoleRunner.ResultReporter.ReportResults()
   at NUnit.ConsoleRunner.ConsoleRunner.RunTests(TestPackage package, TestFilter filter)
   at NUnit.ConsoleRunner.Program.Main(String[] args)
`</Code>
    <Description>@jnm2 commented on [Mon Aug 28 2017](I've gotten this 7 times out of the last 9 builds on the build server at work. &lt;s&gt;The only thing that should have changed from last night is that there's a lot more parallelization going on.&lt;/s&gt; Oh, also I updated to NUnit Framework 3.8.0, duh...

``

Fails with error -100.---@jnm2 commented on [Mon Aug 28 2017](This looks like the only line that could possibly be causing the NRE:  We should either write nothing or add an ArgumentNullException check to start with.---@jnm2 commented on [Mon Aug 28 2017](And here is the root problem:  needs to be updated in concert with  We have a compatibility issue now that none of us thought of. Due to NUnit Console's NRE, NUnit Framework 3.8.0 is incompatible with NUnit Console 3.7.0 and earlier. Even without the NRE, there's no fallback so it would look like there are no test parameters and that may be a compat concern in itself.

Can we tag this issue `integration test wishlist`? ... 😟

/cc @ChrisMaddock @rprouse @CharliePoole 

---@rprouse commented on [Mon Aug 28 2017](Well, damn. @CharliePoole was worried that removing the value attribute and moving it into the items might cause problems for transforms. None of us thought to check our own code and our own tests don't cause this to happen.

I think this warrants an emergency hotfix which I can do tonight. I think we have two options,

1. Back out #2382
2. Rework #2382 so that it is backwards compatible by including the dictionary settings as a single string and also include the individual elements for updated runners.
3. Rework #2382 removing the child elements and just add the value.

My preference is for the second option. I can make the changes starting in about an hour.

@jnm2 will you be available this evening for code reviews?---@ChrisMaddock commented on [Mon Aug 28 2017](2 sounds good to me too.

Is it worth investigation  before doing a hotfix? That also sounds potentially critical.---@rprouse commented on [Mon Aug 28 2017](@ChrisMaddock I agree, nunit/nunit#2386 also looks serious, we should track both. I will comment there.---@rprouse commented on [Mon Aug 28 2017](I am also going to copy this issue to the framework repo for the backwards compatible fix. We should also address this in the next release of the framework to display the child elements if available, so I will leave this open in this repo.</Description>
  </Issue>
  <Issue>
    <IssueID>2389</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Idea: named nonparallelizable scopes</Title>
    <CreatedDate>28/08/2017</CreatedDate>
    <ClosedDate>28/08/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:duplicate</Name>
        <IssueID>2389</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:idea</Name>
        <IssueID>2389</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>c#
[assembly: Parallelizable(ParallelScope.Children)]

static class MyNonParallelizableScopes
{
    /// &lt;summary&gt;Tests in this scope may call &lt;see cref="SynchronizationContext.SetSynchronizationContext"/&gt;.&lt;/summary&gt;
    public const string SetsSynchronizationContext = nameof(SetsSynchronizationContext);
}

class MostCommonKindOfTests
{
    // Runs in parallel with self
    // Runs in parallel with TestsThatNeedSynchronizationContextToNotChangeDuringAsyncTests
    // Runs in parallel with TestsThatSetSynchronizationContext
}

[NotParallelizableWithOthers(MyNonParallelizableScopes.SetsSynchronizationContext)]
class TestsThatNeedSynchronizationContextToNotChangeDuringAsyncTests
{
    // Runs in parallel with MostCommonKindOfTests
    // Runs in parallel with self
    // Does not run in parallel with TestsThatSetSynchronizationContext
}

[NotParallelizable(MyNonParallelizableScopes.SetsSynchronizationContext)]
class TestsThatSetSynchronizationContext
{
    // Runs in parallel with MostCommonKindOfTests
    // Does not run in parallel with TestsThatNeedSynchronizationContextToNotChangeDuringAsyncTests
    // Does not run in parallel with self
}
`</Code>
    <Description>The only tests I have that are non-parallelizable are so because they either read `SynchronizationContext.Current` or read and write `SynchronizationContext.SetSynchronizationContext`. They can run in parallel with almost any test- just not other tests that take a dependency on the same very particular global state.

Right now I document each occurrence of `[NonParallelizable]` with a comment explaining the scopes, but I'm a fan of self-documenting code and also a fan of having the parallelizable tests run while the non-parallelizable tests take their time.

What if we could do this:

``

A test could have any combination of `NotParallelizableWithOthers` and `NotParallelizable` attributes.

I keep thinking about this, so here it is. Probably not high demand. 😛 
</Description>
  </Issue>
  <Issue>
    <IssueID>2388</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Parallelization causes test cases to stop respecting fixture's apartment state</Title>
    <CreatedDate>28/08/2017</CreatedDate>
    <ClosedDate>07/11/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2388</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>2388</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>2388</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>c#
[assembly: Parallelizable(ParallelScope.Children)]

[Apartment(ApartmentState.STA)]
public class StaFixture
{
    [TestCase(1)]
    [TestCase(2)]
    public void Test_cases_should_inherit_apartment_from_fixture(int n)
    {
        Assert.That(Thread.CurrentThread.GetApartmentState(), Is.EqualTo(ApartmentState.STA));
    }
}


Also fails if `[Parallelizable(ParallelScope.Children)]` is specified on the fixture or the method.

Does not fail if nothing is parallelizable.

Does not fail if the apartment is specified on the method:
c#
[assembly: Parallelizable(ParallelScope.Children)]

public class StaFixture
{
    [TestCase(1)]
    [TestCase(2)]
    [Apartment(ApartmentState.STA)]
    public void Test_cases_should_inherit_apartment_from_fixture(int n)
    {
        Assert.That(Thread.CurrentThread.GetApartmentState(), Is.EqualTo(ApartmentState.STA));
    }
}
`</Code>
    <Description>Affected versions: 3.7.0–3.8.0

Fails:

``

Does not fail for non-parameterized test methods.</Description>
  </Issue>
  <Issue>
    <IssueID>2386</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>2386</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Contains.Item() fails for collections in NUnit 3.8</Title>
    <CreatedDate>28/08/2017</CreatedDate>
    <ClosedDate>29/08/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2386</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>2386</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>2386</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Hi,

just updated from NUnit 3.7.1 to 3.8.0.
Now, a test starts to fail consistently which succeeded in the past.

Repro:

``


Best regards,
Ralf Koban</Description>
  </Issue>
  <Issue>
    <IssueID>2377</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>NUnit3: An exception occured in the driver while loading tests...   bei NUnit.Engine.Runners.ProcessRunner.RunTests(ITestEventListener listener, TestFilter filter)</Title>
    <CreatedDate>22/08/2017</CreatedDate>
    <ClosedDate>24/08/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>confirm</Name>
        <IssueID>2377</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>
[TestResult.zip](


Hi guys!
When I try to run tests, I get alway an exception very early.
I went through the internet and also here and saw similiar "issues". 
I tried to add --inprocess, --trace:Debug 
but didnt get more information about the root issue.

The dll is working fine with NUnit Version 2.6.x, but unfortunately I have to pass parameters to the tests and found no suitable solution with 2.6.

Pls. find attached the console output as png, furthermore the ResultFile as Zip.
If there is something missing to analyse this issue, I would be happy to add more information.


Thanks for help in advance.

BR
 Klaus

![console output](
![packages_config](</Description>
  </Issue>
  <Issue>
    <IssueID>2376</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>2376</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Prepare for 3.8 Release</Title>
    <CreatedDate>22/08/2017</CreatedDate>
    <ClosedDate>28/08/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:build</Name>
        <IssueID>2376</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>2376</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>@nunit/core-team and @nunit/framework-team I plan on releasing 3.8 this weekend or early next week depending on the backlog. If you feel any issues or PRs should be included in the release, please add the issues to the 3.8 milestone so we can track them. If PRs are not close to ready I will need reasons to justify delaying the release, so please update the PRs or issues accordingly. Thanks.</Description>
  </Issue>
  <Issue>
    <IssueID>2374</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Grouping fixtures for parallel running</Title>
    <CreatedDate>21/08/2017</CreatedDate>
    <ClosedDate>21/08/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2374</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>2374</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Hi,
Is there a way to make some sort of configurable parallelization in the nunit according to the following example.

I have 8 test fixtures that are running in parallel using ParallelScope.Fixtures.
Also I have 2 fixtures that I want to run sequentially, but be parallel to those 8 fixtures.
Currently as I see if I use NonParallelizable attribute for these 2, they will start only after those 8 would finish. It is ok for me in general but influence total execution time.

In my particular case those tests in 2 fixtures I run sequentially modify several Windows registry settings, and as each test modify the settings for itself such work cannot be parallelized.</Description>
  </Issue>
  <Issue>
    <IssueID>2373</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Collect testresult.xml when executing restart/logout OS in test methods</Title>
    <CreatedDate>21/08/2017</CreatedDate>
    <ClosedDate>22/08/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>2373</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Hi,

I have a requirement to execute the below test scenarios?. I tried it ,but the result.xml does not contains the full testsuite details due to the logout happening inside the testmethod.

1. do the one registry modification
2. logout the user

for the above purpose, I wrote a test method and include the above things. Then execute the nunit console, the testrsult doesnot contains the testsuite tags.

Have any suggestion to resolve it?

Regards,
George</Description>
  </Issue>
  <Issue>
    <IssueID>2372</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>OmicronPersei</FixedById>
        <IssueID>2372</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Create testing for compounded ConstraintFilters</Title>
    <CreatedDate>20/08/2017</CreatedDate>
    <ClosedDate>31/08/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2372</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:low</Name>
        <IssueID>2372</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Per conversation on #2226 , I think we should add some tests around `TestFilter`s, as individual filters aren't really tested in combination with others.

I'm perfectly happy to pick this one up!  😄 </Description>
  </Issue>
  <Issue>
    <IssueID>2370</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>TestCaseAttribute can't convert int to nullable long</Title>
    <CreatedDate>17/08/2017</CreatedDate>
    <ClosedDate>17/08/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2370</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>2370</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>csharp
[TestCase(0)]
public void Test1(long? x)
{
    ...
}


And it threw the error:

System.ArgumentException : Object of type 'System.Int32' cannot be converted to type 'System.Nullable`1[System.Int64]'.
   at System.RuntimeType.TryChangeType(Object value, Binder binder, CultureInfo culture, Boolean needsSpecialCast)
   at System.Reflection.MethodBase.CheckArguments(Object[] parameters, Binder binder, BindingFlags invokeAttr, CultureInfo culture, Signature sig)
   at System.Reflection.RuntimeMethodInfo.InvokeArgumentsCheck(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)
   at System.Reflection.RuntimeMethodInfo.Invoke(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)
   at NUnit.Framework.Internal.Reflect.InvokeMethod(MethodInfo method, Object fixture, Object[] args)
`</Code>
    <Description>I've tried to run the test:
``</Description>
  </Issue>
  <Issue>
    <IssueID>2369</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>ChrisMaddock</FixedById>
        <IssueID>2369</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>NuGet package does not install in Visual Studio 2012 or older</Title>
    <CreatedDate>17/08/2017</CreatedDate>
    <ClosedDate>09/10/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:wontfix</Name>
        <IssueID>2369</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>2369</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I received a report from a user, "I have Nuget 2.8.6 installed on my visual studio 2010. I am trying to download Nunit in one of my projects and it gives me an error 'NUnit' already has a dependency defined for 'NETStandard.Library'.. Any help on this will be appreciated."

Doing some research, I found this,  which seems to indicate that NuGet 2.12 or newer is required for any NuGet packages that include .NET Standard packages. That also states that 2.12+ is only available for Visual Studio 2013 or newer.

**Workarounds**

- use the ZIP package of NUnit, or
- use NUnit 3.5 or newer, or 
- upgrade Visual Studio

**Possible fixes?** release a version of the nuget package without .NET Standard?

This isn't really our bug, what do people think we should do? I am also surprised we don't see it reported more often. Has everyone upgraded Visual Studio?

</Description>
  </Issue>
  <Issue>
    <IssueID>2368</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Combine existing testresult.xml file</Title>
    <CreatedDate>17/08/2017</CreatedDate>
    <ClosedDate>17/08/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:duplicate</Name>
        <IssueID>2368</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Hi,

Have any option to combine the test results.xml with existing test results xml file.

Regards,
George</Description>
  </Issue>
  <Issue>
    <IssueID>2367</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Exception thrown in async void EventHandler is not caught by Nunit</Title>
    <CreatedDate>17/08/2017</CreatedDate>
    <ClosedDate>22/08/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>2367</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>
The active test run was aborted. Reason: Unhandled Exception: System.Exception: Exception of type 'System.Exception' was thrown.
   at NunitTest.MyEventClass.&lt;&gt;c.&lt;&lt;-ctor&gt;b__1_0&gt;d.MoveNext() in c:\users\nzsma\documents\visual studio 2017\Projects\NunitTest\NunitTest\Program.cs:line 16
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at System.Threading.ExecutionContext.Run(ExecutionContext executionContext, ContextCallback callback, Object state)
   at System.Threading.QueueUserWorkItemCallback.System.Threading.IThreadPoolWorkItem.ExecuteWorkItem()
   at System.Threading.ThreadPoolWorkQueue.Dispatch()


The following example is built with .Net Core 1.1

C#
using System;
using System.Threading.Tasks;
using NUnit.Framework;

namespace NunitTest
{
    public class MyEventClass
    {
        public EventHandler MyEvent;

        public MyEventClass()
        {
            MyEvent += async (s, a) =&gt;
            {
                await Task.Yield();
                throw new Exception();
            };
        }

        public void TriggerEvent()
        {
            MyEvent(this, new EventArgs());
        }
    }

    [TestFixture]
    public class TestMyClass
    {
        [Test]
        public void Test1() // This test on it's own, will pass
        {
            Assert.That(async () =&gt;
            {
                await Task.Yield();
                throw new Exception();
            }, Throws.TypeOf&lt;Exception&gt;());
        }

        [Test]
        public void Test2() // When this test runs, ALL RESULTs are inconclusive
        {
            Assert.That(() =&gt;
            {
                var myEvent = new MyEventClass();

                myEvent.TriggerEvent();
            }, Throws.TypeOf&lt;Exception&gt;());
        }
    }
}
`</Code>
    <Description>When exceptions are thrown from within an async EventHandler invocation, the exception is not caught by Nunit, Visual Studio 2017.3 shows this in the Tests output window

``</Description>
  </Issue>
  <Issue>
    <IssueID>2366</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Lazy TestCaseSourceAttribute</Title>
    <CreatedDate>16/08/2017</CreatedDate>
    <ClosedDate>16/08/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:duplicate</Name>
        <IssueID>2366</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I noticed that a if you decorate a test with the attribute in the title, the source method gets invoked for ANY test running in the entire project. So if I run TestFixtureX.Test and TestFixutureY.Test has the attribute, the test cases method will be executed also for TestFixtureX.Test.

This causes a significant overhead in big test projects with many sources; to run a single simple test, we have to wait a minute for all the test cases to be loaded.

Is this a bug or by design? Is there a way to avoid this or, even better, to make the test cases lazy and be evaluated only when the test requiring it is executed? If not, can you please consider adding this feature?

Thank you</Description>
  </Issue>
  <Issue>
    <IssueID>2364</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>2364</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Parallelizable attribute not invalidating invalid parallel scope combinations</Title>
    <CreatedDate>15/08/2017</CreatedDate>
    <ClosedDate>01/11/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2364</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>2364</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I was looking through the ParallelizableAttribute.cs, and the changes made with  I noticed that there is the functionality to invalidate tests with invalid parallel combinations in the ApplyToTest() method, but it does not appear to be actually invalidating them. Is this intentional? 

Using 3.7.1, 
I tested and was able to reproduce the hanging found in  by placing [NonParallelizable] on the test fixture, and [Parallelizable(ParallelScope.Self)] on the test method. 

I placed [Parallelizable(ParallelScope.Fixture)] on a test method with no parallelization on the fixture, and the tests ran and passed normally without any parallelization.

Instead of invalidating the setting, it could potentially be useful. What are your thoughts on allowing ParallelScope.Fixtures for methods? It would be useful in the case where you would only like to run one particular test one at a time at the fixture level, but run the rest of the tests in the fixture at ParallelScope.Self. It allows for the specific test in the fixture to be isolated without affecting other fixtures in the way ParallelScope.None does.</Description>
  </Issue>
  <Issue>
    <IssueID>2362</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Ignored classes are not working as expected</Title>
    <CreatedDate>14/08/2017</CreatedDate>
    <ClosedDate>24/08/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>2362</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Hello,

I'm using NUnit 3.7.1 - running tests through Resharper's test runner (although investigating this issue with nunit-console and some other code which calls the NUnit framework directly).

We have a class with the Ignore attribute containing 2 tests (one ignored explicitly and one which I'd expect to be ignored based on the Class attribute):

``

However the `NotIgnoredMethod` gives the following XML output:
`&lt;test-case id="0-1858" name="NotIgnoredMethod" fullname="Xamarin.UITest.Tests.AssemblyAnalysis.AnalysisTests+MyIgnoredClass.NotIgnoredMethod" methodname="NotIgnoredMethod" classname="Xamarin.UITest.Tests.AssemblyAnalysis.AnalysisTests+MyIgnoredClass" runstate="Runnable" seed="704490897" /&gt;`

[Reading the Wiki]( - I would expect both of these tests to return "Ignored" as the runstate.

Thanks,

Owen
</Description>
  </Issue>
  <Issue>
    <IssueID>2361</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>2361</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>NUnit Parallelizable and OneTimeSetUp with no namespace results in single-threaded test execution</Title>
    <CreatedDate>14/08/2017</CreatedDate>
    <ClosedDate>22/08/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2361</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>2361</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>2361</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I set `[assembly: Parallelizable(ParallelScope.Fixtures)]`
I have the following OneTimeSetUp:
``
_Expected:_ The tests should be executed **multi-threaded**.
_Actual:_ The tests are executed **single-threaded**.

_Additional observation:_
If I put the `OneTimeSetUp` class in a namespace (corresponding to one of the test suites), then tests are executed multi-threaded. However only that namespace is initialized with `SetUp()`. 
If I use this workaround then I have to specify `OneTimeSetUp` for every namespace in the assembly which is error-prone (have to keep it in sync manually). I have many sub-namespaces in the assembly because that's how SpecFlow generates them.

</Description>
  </Issue>
  <Issue>
    <IssueID>2360</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>mikkelbu</FixedById>
        <IssueID>2360</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Obsolete CollectionContainsConstraint Constructors</Title>
    <CreatedDate>13/08/2017</CreatedDate>
    <ClosedDate>26/08/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2360</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:refactor</Name>
        <IssueID>2360</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>2360</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>At some point,  is going to be merged and remove CollectionContainsConstraint. The only breaking change should be where anyone is explicitly using the code `new CollectionContainsConstraint()` - all the other methods will be changed internally to use a SomeItemsConstraint instead.

I think it would be good if we can obsolete the CollectionContainsConstraint constructor in v3.8, and then merge the actual constraint removal in v3.9. It should only be the constructor itself that is obsoleted - any other public methods which make use of the class will be refactored. The obsoletion message should state that `SomeItemsConstraint` is the appropriate replacement.</Description>
  </Issue>
  <Issue>
    <IssueID>2358</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>2358</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Get framework to build under Mono 5.0</Title>
    <CreatedDate>11/08/2017</CreatedDate>
    <ClosedDate>13/08/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2358</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>2358</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:build</Name>
        <IssueID>2358</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>2358</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Tests have been failing for some months now under Mono 5.0. We need to get this working correctly and then remove mono latest from the Allowed Failures.</Description>
  </Issue>
  <Issue>
    <IssueID>2353</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>2353</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Provide additional Result information through TestContext</Title>
    <CreatedDate>08/08/2017</CreatedDate>
    <ClosedDate>09/08/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>2353</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>2353</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Issue #2347 mentions the desirability of adding the current Assert count to the information returned by `TestContext.CurrentContext.Result`. We should review other information that is not available to the test and consider adding that as well.

Initially, I propose we add  `AssertCount` and `Assertions`.

The latter would return a list of items representing the pending AssertionResults, i.e. warnings and deferred failures in a multiple assertion block.

Users would, of course, need to understand that they were not seeing the __final__ result of the test, which is not available until all control returns to NUnit.

</Description>
  </Issue>
  <Issue>
    <IssueID>2348</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>2348</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Can't use Assert.Multiple with async code</Title>
    <CreatedDate>04/08/2017</CreatedDate>
    <ClosedDate>08/08/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2348</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>2348</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>
namespace app
{
    [TestFixture]
    public class Tests
    {
        [Test]
        public void TestMultipleSync()
        {
            Assert.Multiple(() =&gt;
            {
                Thread.Sleep(TimeSpan.FromSeconds(5));
                Assert.Fail();
            });
        }

        [Test]
        public void TestMultipleAsync()
        {
            Assert.Multiple(async () =&gt;
            {
                await Task.Delay(TimeSpan.FromSeconds(5));
                Assert.Fail();
            });
        }
    }
}


I would intuitively expect both these tests to take 5 seconds to run before then failing. However, only TestMultipleSync fails; TestMultipleAsync passes successfully in less than a second. Output from console runner:


PS C:\dev\scratch\test&gt; .\packages\NUnit.ConsoleRunner.3.7.0\tools\nunit3-console.exe .\app\bin\Debug\app.exe
NUnit Console Runner 3.7.0
Copyright (c) 2017 Charlie Poole, Rob Prouse

Runtime Environment
   OS Version: Microsoft Windows NT 10.0.15063.0
  CLR Version: 4.0.30319.42000

Test Files
    .\app\bin\Debug\app.exe


Errors, Failures and Warnings

1) Failed : app.Tests.TestMultipleSync
at app.Tests.&lt;&gt;c.&lt;TestMultipleSync&gt;b__0_0() in C:\dev\scratch\test\app\Tests.cs:line 17
at NUnit.Framework.Assert.Multiple(TestDelegate testDelegate)
at app.Tests.TestMultipleSync() in C:\dev\scratch\test\app\Tests.cs:line 14

Run Settings
    DisposeRunners: True
    WorkDirectory: C:\dev\scratch\test
    ImageRuntimeVersion: 4.0.30319
    ImageTargetFrameworkName: .NETFramework,Version=v4.5
    ImageRequiresX86: True
    RunAsX86: True
    ImageRequiresDefaultAppDomainAssemblyResolver: False
    NumberOfTestWorkers: 8

Test Run Summary
  Overall result: Failed
  Test Count: 2, Passed: 1, Failed: 1, Warnings: 0, Inconclusive: 0, Skipped: 0
    Failed Tests - Failures: 1, Errors: 0, Invalid: 0
  Start time: 2017-08-04 10:23:02Z
    End time: 2017-08-04 10:23:08Z
    Duration: 5.504 seconds
`</Code>
    <Description>Passing an async lambda into Assert.Multiple compiles fine with no warnings but always passes instantaneously, even if the code inside the lambda should fail.

Sample test code:

``

I guess the lambda is being interpreted as an "async void" rather than an "async Task" and so its results end up ignored? There doesn't seem to be any obvious other way of doing an async multiple assert though - most of the other Assert methods that take a TestDelegate have an equivalent AsyncTestDelegate method (Catch/CatchAsync, DoesNotThrow/DoesNotThrowAsync), but there's no MultipleAsync method.

There's also nothing on the documentation page for Multiple Asserts ( which calls out that you can't use it with async code - on the contrary, it says the assert block "may contain any arbitrary code".

Using NUnit 3.7.1, console runner 3.7.0.</Description>
  </Issue>
  <Issue>
    <IssueID>2347</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Feature request for configuring tests to require Asserts - Explicit pass/fail/inconclusive</Title>
    <CreatedDate>03/08/2017</CreatedDate>
    <ClosedDate>08/08/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:wontfix</Name>
        <IssueID>2347</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:idea</Name>
        <IssueID>2347</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I have testing framework built around NUnit that a large group of users writes their Selenium tests in. Need the ability to configure an explicit pass/fail in that if no assertions are present in a test then the default status is Inconclusive until an assert passes or fails the test. If 0 assertions were executed in a test then the final status would be inconclusive pending no other exceptions thrown. Alternatively, if that is not possible, then be able to access the Asserts count within NUnit API like TestContext.CurrentContext.Result.Asserts which would allow me to check the number of asserts in my TearDown() method and throw Assert.Inconclusive("No Assertions Executed"). I have seen when running from the console runner, that the XML output includes an "asserts" counter attribute on the &lt;test-case&gt; elements so all we would need is this counter accessible via the API.</Description>
  </Issue>
  <Issue>
    <IssueID>2346</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Missing reference to nunit.framework with NUnit NuGet package</Title>
    <CreatedDate>03/08/2017</CreatedDate>
    <ClosedDate>08/08/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>2346</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>![image](


![image](
</Description>
  </Issue>
  <Issue>
    <IssueID>2345</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Supported .Net Framework and Visual Studio versions </Title>
    <CreatedDate>02/08/2017</CreatedDate>
    <ClosedDate>02/08/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>2345</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I need to know what versions of Visual Studio and .Net Framework are supported by each, if not majority of the releases of NUnit. 

Any help is appreciated. </Description>
  </Issue>
  <Issue>
    <IssueID>2344</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Remove dependency on System.Web.UI.ICallbackEventHandler</Title>
    <CreatedDate>02/08/2017</CreatedDate>
    <ClosedDate>18/05/2020</ClosedDate>
    <IssueLabels />
    <Description>Due to the dependency on `System.Web.UI.ICallbackEventHandler`, the type from `System.Web,dll`, which does not exist in .netstandard, nunit.framework.dll compiled for .netstandard is incompatible with the nunit console runner. This is awkward since references to .netstandard libraries from projects targeting full .NET framework are completed valid.</Description>
  </Issue>
  <Issue>
    <IssueID>2343</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>No tests or proper test driver found when using nunit3-console 3.7.0 in CLI</Title>
    <CreatedDate>02/08/2017</CreatedDate>
    <ClosedDate>03/08/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>confirm</Name>
        <IssueID>2343</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>.\nunit3-console ..\..\..\BDD\BDD.csproj from within .\NUnit.ConsoleRunner.3.7.0\tools and got this output:


Runtime Environment
   OS Version: Microsoft Windows NT 10.0.14393.0
  CLR Version: 4.0.30319.42000

Test Files
    ..\..\..\BDD\BDD.csproj

Errors, Failures and Warnings

1) Invalid : C:\nunit-page-objects\BDD\bin\Debug\BDD.dll
No suitable tests found in 'C:\nunit-page-objects\BDD\bin\Debug\BDD.dll'.
Either assembly contains no tests or proper test driver has not been found.

Test Run Summary
  Overall result: Failed
  Test Count: 0, Passed: 0, Failed: 0, Warnings: 0, Inconclusive: 0, Skipped: 0
  Start time: 2017-08-02 07:49:02Z
    End time: 2017-08-02 07:49:05Z
    Duration: 2.902 seconds


Repo: https://github.com/alexandlazaris/nunit-pageobjects
Packages:

  &lt;package id="MSTest.TestAdapter" version="1.1.18" targetFramework="net452" /&gt;
  &lt;package id="MSTest.TestFramework" version="1.1.18" targetFramework="net452" /&gt;
  &lt;package id="Newtonsoft.Json" version="10.0.3" targetFramework="net452" /&gt;
  &lt;package id="NUnit" version="3.7.1" targetFramework="net452" /&gt;
  &lt;package id="NUnit.Console" version="3.7.0" targetFramework="net452" /&gt;
  &lt;package id="NUnit.ConsoleRunner" version="3.7.0" targetFramework="net452" /&gt;
  &lt;package id="NUnit.Extension.NUnitProjectLoader" version="3.6.0" targetFramework="net452" /&gt;
  &lt;package id="NUnit.Extension.NUnitV2Driver" version="3.7.0" targetFramework="net452" /&gt;
  &lt;package id="NUnit.Extension.NUnitV2ResultWriter" version="3.6.0" targetFramework="net452" /&gt;
  &lt;package id="NUnit.Extension.TeamCityEventListener" version="1.0.2" targetFramework="net452" /&gt;
  &lt;package id="NUnit.Extension.VSProjectLoader" version="3.6.0" targetFramework="net452" /&gt;
  &lt;package id="Selenium.Firefox.WebDriver" version="0.18.0" targetFramework="net452" /&gt;
  &lt;package id="Selenium.Support" version="3.4.0" targetFramework="net452" /&gt;
  &lt;package id="Selenium.WebDriver" version="3.4.0" targetFramework="net452" /&gt;
  &lt;package id="Selenium.WebDriver.ChromeDriver" version="2.31.0" targetFramework="net452" /&gt;
  &lt;package id="Selenium.WebDriver.IEDriver" version="3.4.0" targetFramework="net452" /&gt;
  &lt;package id="Selenium.WebDriver.MicrosoftDriver" version="15.15063.0" targetFramework="net452" /&gt;
`</Code>
    <Description>Am writing a test framework to run e2e tests. Running the tests from Test Explorer within VS works fine. Want to run the tests via CLI. Added Nunit packages. Tried ``</Description>
  </Issue>
  <Issue>
    <IssueID>2342</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>OmicronPersei</FixedById>
        <IssueID>2342</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Remove deprecated Is.String* Constraints</Title>
    <CreatedDate>01/08/2017</CreatedDate>
    <ClosedDate>11/08/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>help wanted</Name>
        <IssueID>2342</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>2342</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>2342</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description> removed the attributes obsoleted in v3.0.

I suggest we also remove the Is.String* constraints which were deprecated at the same time - and do this in the 3.8 release, so we only inconvenience users the once. </Description>
  </Issue>
  <Issue>
    <IssueID>2341</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Using SetUp attribute with parallelizable atrribute creates conflicts in variables.</Title>
    <CreatedDate>31/07/2017</CreatedDate>
    <ClosedDate>01/08/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>2341</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>
using NUnit.Framework;
namespace UnitTests
{
    class Class1
    {
        private int testValue;

        [SetUp]
        public void BeforeEveryTest()
        {
            testValue = 2;
        }


        [Test, Parallelizable]
        public void Test1()
        {
            testValue++;
            Assert.That(testValue, Is.EqualTo(3));
        }

        [Test, Parallelizable]
        public void Test2()
        {
            testValue = testValue * 10;
            Assert.That(testValue, Is.EqualTo(20));
        }

        [Test, Parallelizable]
        public void Test3()
        {
            testValue = testValue * 3;
            Assert.That(testValue, Is.EqualTo(6));
        }
    }
}



Result:

Errors, Failures and Warnings

1) Failed : UnitTests.Class1.Test3
  Expected: 6
  But was:  60
at UnitTests.Class1.Test3() in C:\Users\azakharov\Documents\GitHub\IntegrationTests\UnitTests\Class1.cs:line 34

2) Failed : UnitTests.Class1.Test1
  Expected: 3
  But was:  61
at UnitTests.Class1.Test1() in C:\Users\azakharov\Documents\GitHub\IntegrationTests\UnitTests\Class1.cs:line 20
`</Code>
    <Description>NUnit Version: 3.7.0
Sorry in advance if it is by design but looks like assigning values to variables in [Setup] method creates conflicts. Please see the example code below:


``</Description>
  </Issue>
  <Issue>
    <IssueID>2336</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>NUnit Asserts no longer work in other testing frameworks</Title>
    <CreatedDate>28/07/2017</CreatedDate>
    <ClosedDate>30/07/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:duplicate</Name>
        <IssueID>2336</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I used to be able to use NUnit asserts with other testing frameworks like XUnit and VSUnit.
Now when I use an NUnit asset outside a NUnit test I get the following error:
&gt; System.NullReferenceException: Object reference not set to an instance of an object.

Note*
This issues stated with the release of V 3.7.0

Sample code:
``
</Description>
  </Issue>
  <Issue>
    <IssueID>2335</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>2335</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Execute OneTimeTearDown as early as possible when running fixtures in parallel</Title>
    <CreatedDate>28/07/2017</CreatedDate>
    <ClosedDate>09/08/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2335</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>2335</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>2335</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code> cs
using System.Threading;
using NLog;
using NUnit.Framework;

namespace Skanska.Korab2.UITests.Infrastructure.Tests
{
    class Common
    {
        private static readonly Logger Logger = LogManager.GetCurrentClassLogger();

        public static void LogMe(string message)
        {
            Logger.Log(LogLevel.Info, $"{message} from {Thread.CurrentThread.Name}");
        }
    }

    class Class1Fast
    {
        [Test]
        public void Test1()
        {
            Common.LogMe(nameof(Test1));
        }

        [Test]
        public void Test11()
        {
            Common.LogMe(nameof(Test11));
        }

        [OneTimeTearDown]
        public void Test1TearDown()
        {
            Common.LogMe(nameof(Test1TearDown));
        }
    }

    class Class2Slow
    {
        [Test]
        public void Test2()
        {
            Thread.Sleep(1000);
            Common.LogMe(nameof(Test2));
        }

        [Test]
        public void Test22()
        {
            Thread.Sleep(1000);
            Common.LogMe(nameof(Test22));
        }

        [OneTimeTearDown]
        public void Test2TearDown()
        {
            Common.LogMe(nameof(Test2TearDown));
        }
    }

    class Class3Slow
    {
        [Test]
        public void Test3()
        {
            Thread.Sleep(1000);
            Common.LogMe(nameof(Test3));
        }

        [Test]
        public void Test33()
        {
            Thread.Sleep(1000);
            Common.LogMe(nameof(Test33));
        }

        [OneTimeTearDown]
        public void Test3TearDown()
        {
            Common.LogMe(nameof(Test3TearDown));
        }
    }

    class Class4
    {
        [Test]
        public void Test4()
        {
            Common.LogMe(nameof(Test4));
        }

        [Test]
        public void Test44()
        {
            Common.LogMe(nameof(Test44));
        }

        [OneTimeTearDown]
        public void Test4TearDown()
        {
            Common.LogMe(nameof(Test4TearDown));
        }
    }

    class Class5
    {
        [Test]
        public void Test5()
        {
            Common.LogMe(nameof(Test5));
        }

        [Test]
        public void Test55()
        {
            Common.LogMe(nameof(Test55));
        }

        [OneTimeTearDown]
        public void Test5TearDown()
        {
            Common.LogMe(nameof(Test5TearDown));
        }
    }

    class Class6
    {
        [Test]
        public void Test6()
        {
            Common.LogMe(nameof(Test6));
        }

        [Test]
        public void Test66()
        {
            Common.LogMe(nameof(Test66));
        }

        [OneTimeTearDown]
        public void Test6TearDown()
        {
            Common.LogMe(nameof(Test6TearDown));
        }
    }

    class Class7
    {
        [Test]
        public void Test7()
        {
            Common.LogMe(nameof(Test7));
        }

        [Test]
        public void Test77()
        {
            Common.LogMe(nameof(Test77));
        }

        [OneTimeTearDown]
        public void Test7TearDown()
        {
            Common.LogMe(nameof(Test7TearDown));
        }
    }

    class Class8Slow
    {
        [Test]
        public void Test8()
        {
            Thread.Sleep(1000);
            Common.LogMe(nameof(Test8));
        }

        [Test]
        public void Test88()
        {
            Thread.Sleep(1000);
            Common.LogMe(nameof(Test88));
        }

        [OneTimeTearDown]
        public void Test8TearDown()
        {
            Common.LogMe(nameof(Test8TearDown));
        }
    }
}


##### AssemblyInfo.cs

 cs
[assembly: Parallelizable(ParallelScope.Fixtures)]
[assembly: LevelOfParallelism(2)]


##### Result:


2017-07-28 18:09:03.0068|INFO|   Test1 from Worker#2
2017-07-28 18:09:03.0338|INFO|   Test11 from Worker#2
2017-07-28 18:09:03.8560|INFO|   Test2 from Worker#1
2017-07-28 18:09:04.0419|INFO|   Test3 from Worker#2
2017-07-28 18:09:04.8612|INFO|   Test22 from Worker#1
2017-07-28 18:09:04.8732|INFO|   Test4 from Worker#1
2017-07-28 18:09:04.8732|INFO|   Test44 from Worker#1
2017-07-28 18:09:04.8862|INFO|   Test5 from Worker#1
2017-07-28 18:09:04.8862|INFO|   Test55 from Worker#1
2017-07-28 18:09:04.8982|INFO|   Test6 from Worker#1
2017-07-28 18:09:04.8982|INFO|   Test66 from Worker#1
2017-07-28 18:09:04.9132|INFO|   Test7 from Worker#1
2017-07-28 18:09:04.9132|INFO|   Test77 from Worker#1
2017-07-28 18:09:05.0482|INFO|   Test33 from Worker#2
2017-07-28 18:09:05.0522|INFO|   Test1TearDown from Worker#2
2017-07-28 18:09:05.0522|INFO|   Test2TearDown from Worker#2
2017-07-28 18:09:05.0677|INFO|   Test4TearDown from Worker#2
2017-07-28 18:09:05.0677|INFO|   Test5TearDown from Worker#2
2017-07-28 18:09:05.0677|INFO|   Test6TearDown from Worker#2
2017-07-28 18:09:05.0677|INFO|   Test7TearDown from Worker#2
2017-07-28 18:09:05.0677|INFO|   Test3TearDown from Worker#2
2017-07-28 18:09:05.9266|INFO|   Test8 from Worker#1
2017-07-28 18:09:06.9321|INFO|   Test88 from Worker#1
2017-07-28 18:09:06.9321|INFO|   Test8TearDown from Worker#1


##### Expected result:

`Test1TearDown` is run before Worker#2 has started tests from other fixtures.

#### Previous versions:

Logs from NUnit 3.6.1:


2017-07-28 18:18:19.3493|INFO|   Test1 from Worker#2
2017-07-28 18:18:19.3913|INFO|   Test11 from Worker#2
2017-07-28 18:18:19.4018|INFO|   Test1TearDown from Worker#2
2017-07-28 18:18:19.9824|INFO|   Test2 from Worker#1
2017-07-28 18:18:20.4252|INFO|   Test3 from Worker#2
2017-07-28 18:18:20.9884|INFO|   Test22 from Worker#1
2017-07-28 18:18:20.9914|INFO|   Test2TearDown from Worker#1
2017-07-28 18:18:20.9914|INFO|   Test4 from Worker#1
2017-07-28 18:18:20.9914|INFO|   Test44 from Worker#1
2017-07-28 18:18:21.0085|INFO|   Test4TearDown from Worker#1
2017-07-28 18:18:21.0085|INFO|   Test5 from Worker#1
2017-07-28 18:18:21.0224|INFO|   Test55 from Worker#1
2017-07-28 18:18:21.0224|INFO|   Test5TearDown from Worker#1
2017-07-28 18:18:21.0224|INFO|   Test6 from Worker#1
2017-07-28 18:18:21.0424|INFO|   Test66 from Worker#1
2017-07-28 18:18:21.0424|INFO|   Test6TearDown from Worker#1
2017-07-28 18:18:21.0574|INFO|   Test7 from Worker#1
2017-07-28 18:18:21.0574|INFO|   Test77 from Worker#1
2017-07-28 18:18:21.0724|INFO|   Test7TearDown from Worker#1
2017-07-28 18:18:21.4422|INFO|   Test33 from Worker#2
2017-07-28 18:18:21.4452|INFO|   Test3TearDown from Worker#2
2017-07-28 18:18:22.0818|INFO|   Test8 from Worker#1
2017-07-28 18:18:23.0879|INFO|   Test88 from Worker#1
2017-07-28 18:18:23.0879|INFO|   Test8TearDown from Worker#1
`</Code>
    <Description>_NUnit 3.7.1_

#### Setup:

Running fixtures in parallel (`Parallelizable(ParallelScope.Fixtures)` set in `AssemblyInfo.cs`) in at least 2 threads (`LevelOfParallelism(2)` set in `AssemblyInfo.cs`).

Multiple fixtures with tests and OneTimeTearDown's for each of them exist.

#### Problem:

All `[OneTimeTearDown]` methods are executed in bulk when first available thread finishes.

#### Example:

##### Tests:

``</Description>
  </Issue>
  <Issue>
    <IssueID>2334</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Insufficient error handling message in ProcessRunner -&gt; RunTests method</Title>
    <CreatedDate>28/07/2017</CreatedDate>
    <ClosedDate>28/07/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:duplicate</Name>
        <IssueID>2334</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>log.Error("Failed to run remote tests {0}", e.Message); is insufficeint. It lacks details required to diagnose problem. Here is sample of my log:
&gt; An exception occurred in the driver while loading tests.
&gt; Server stack trace: 
&gt;    at NUnit.Engine.Runners.DirectTestRunner.LoadDriver(IFrameworkDriver driver, String testFile, TestPackage subPackage)
&gt;    at NUnit.Engine.Runners.DirectTestRunner.LoadPackage()
&gt;    at NUnit.Engine.Runners.TestDomainRunner.LoadPackage()
&gt;    at NUnit.Engine.Runners.DirectTestRunner.EnsurePackageIsLoaded()
&gt;    at NUnit.Engine.Runners.DirectTestRunner.RunTests(ITestEventListener listener, TestFilter filter)
&gt;    at NUnit.Engine.Runners.AbstractTestRunner.Run(ITestEventListener listener, TestFilter filter)
&gt;    at NUnit.Engine.Runners.AggregatingTestRunner.RunTestsSequentially(ITestEventListener listener, TestFilter filter, List`1 results, Boolean disposeRunners)
&gt;    at NUnit.Engine.Runners.AggregatingTestRunner.RunTests(ITestEventListener listener, TestFilter filter)
&gt;    at NUnit.Engine.Runners.AbstractTestRunner.Run(ITestEventListener listener, TestFilter filter)
&gt;    at NUnit.Engine.Agents.RemoteTestAgent.Run(ITestEventListener listener, TestFilter filter)
&gt;    at System.Runtime.Remoting.Messaging.StackBuilderSink._PrivateProcessMessage(IntPtr md, Object[] args, Object server, Object[]&amp; outArgs)
&gt;    at System.Runtime.Remoting.Messaging.StackBuilderSink.PrivateProcessMessage(RuntimeMethodHandle md, Object[] args, Object server, Object[]&amp; outArgs)
&gt;    at System.Runtime.Remoting.Messaging.StackBuilderSink.SyncProcessMessage(IMessage msg)


I was unable to recognize error only by this stack trace. I was forced to download nunit3-console binaries and debug it myself. I found out that useful error message was in ex.InnerException which is not returned in error message at all. Please extend error message by adding ex.InnerException message.</Description>
  </Issue>
  <Issue>
    <IssueID>2333</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>TestCaseData.SetName issue</Title>
    <CreatedDate>28/07/2017</CreatedDate>
    <ClosedDate>25/08/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2333</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>When I use the SetName method to name my test and the name contains a dot, the VS Test Explorer doesn't display the test properly.
![image](

All the tests on the screen above are used in the same methods, but in the Test Explorer they are shown like different classes. All tests that don't have a dot in their name are combined in "CreateOrdersTests" - 5 items. But the "CreateSingleOrderChargeRate1.5 is put in the separate class "CreateSingleOrderChargeRate1".

If I substitute the dot with a comma, the issue is resolved. Check the screen.
![image](


Thanks.
</Description>
  </Issue>
  <Issue>
    <IssueID>2332</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>OmicronPersei</FixedById>
        <IssueID>2332</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Update build script to use NUnitConsoleRunner v3.7.0</Title>
    <CreatedDate>28/07/2017</CreatedDate>
    <ClosedDate>01/08/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2332</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>good first issue</Name>
        <IssueID>2332</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:build</Name>
        <IssueID>2332</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>2332</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>As the title says.</Description>
  </Issue>
  <Issue>
    <IssueID>2331</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>2331</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Repo does not build in VS without running `build -t build` first</Title>
    <CreatedDate>27/07/2017</CreatedDate>
    <ClosedDate>28/11/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2331</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:build</Name>
        <IssueID>2331</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:critical</Name>
        <IssueID>2331</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>For example, nunit.frameworktest-4.5 has 35 errors, all centered on ValueTuple not being found.

This afflicts every fresh clone and anyone who had a clone before 

It looks like some type of NuGet restore problem.

@rprouse We don't need packages.config for VS2015 support, so why do the test projects have both `packages.config` and `project.json` files?
</Description>
  </Issue>
  <Issue>
    <IssueID>2330</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>NUnit framework AssertionException inner exception null at NUnit.Framework.Assert.ReportFailure(String message)</Title>
    <CreatedDate>27/07/2017</CreatedDate>
    <ClosedDate>30/01/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>confirm</Name>
        <IssueID>2330</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I've written Specflow test cases to perform integration testing. I'm using Assert.Fail() method to report any failure from my test case in case of failed validations. However, whenever my validation fails and I reach to code statement Assert.Fail() I'm seeing below exception.

at NUnit.Framework.Assert.ReportFailure(String message)
   at NUnit.Framework.Assert.Fail(String message, Object[] args)
   at NUnit.Framework.Assert.Fail(String message)

Nuget Packages that I'm using in my project -
NUnit - 3.7.1
Specflow.NUnit - 2.2.0
NUnit 3 test Adapter for Visual Studio - 3.8.0</Description>
  </Issue>
  <Issue>
    <IssueID>2328</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>jnm2</FixedById>
        <IssueID>2328</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Test execution hangs without any progress.</Title>
    <CreatedDate>24/07/2017</CreatedDate>
    <ClosedDate>28/04/2019</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>confirm</Name>
        <IssueID>2328</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>`
System.Threading.ThreadAbortException occurred
  HResult=-2146233040
  Message=Thread was being aborted.
  Source=nunit.framework
  StackTrace:
       at NUnit.Framework.Internal.TestExecutionContext.get_ExecutionStatus() in C:\Sources\NUnit\src\NUnitFramework\framework\Internal\TestExecutionContext.cs:line 275
  InnerException: 
`

The stack trace for this exception is as follows:

`
&gt;	nunit.framework.dll!NUnit.Framework.Internal.TestExecutionContext.ExecutionStatus.get() Line 277	C#
 	nunit.framework.dll!NUnit.Framework.Internal.TestExecutionContext.ExecutionStatus.get() Line 275	C#
 	nunit.framework.dll!NUnit.Framework.Internal.TestExecutionContext.ExecutionStatus.get() Line 275	C#
 	nunit.framework.dll!NUnit.Framework.Internal.TestExecutionContext.ExecutionStatus.get() Line 275	C#
 	nunit.framework.dll!NUnit.Framework.Internal.TestExecutionContext.ExecutionStatus.get() Line 275	C#
 	nunit.framework.dll!NUnit.Framework.Internal.Execution.CompositeWorkItem.CheckForCancellation() Line 145	C#
 	nunit.framework.dll!NUnit.Framework.Internal.Execution.CompositeWorkItem.RunChildren() Line 274	C#
 	nunit.framework.dll!NUnit.Framework.Internal.Execution.CompositeWorkItem.PerformWork() Line 100	C#
 	nunit.framework.dll!NUnit.Framework.Internal.Execution.WorkItem.RunOnCurrentThread() Line 442	C#
 	nunit.framework.dll!NUnit.Framework.Internal.Execution.WorkItem.Execute() Line 226	C#
 	nunit.framework.dll!NUnit.Framework.Internal.Execution.SimpleWorkItemDispatcher.Dispatch(NUnit.Framework.Internal.Execution.WorkItem work) Line 75	C#
 	nunit.framework.dll!NUnit.Framework.Internal.Execution.CompositeWorkItem.RunChildren() Line 285	C#
 	nunit.framework.dll!NUnit.Framework.Internal.Execution.CompositeWorkItem.PerformWork() Line 100	C#
 	nunit.framework.dll!NUnit.Framework.Internal.Execution.WorkItem.RunOnCurrentThread() Line 442	C#
 	nunit.framework.dll!NUnit.Framework.Internal.Execution.WorkItem.Execute() Line 226	C#
 	nunit.framework.dll!NUnit.Framework.Internal.Execution.SimpleWorkItemDispatcher.Dispatch(NUnit.Framework.Internal.Execution.WorkItem work) Line 75	C#
 	nunit.framework.dll!NUnit.Framework.Internal.Execution.CompositeWorkItem.RunChildren() Line 285	C#
 	nunit.framework.dll!NUnit.Framework.Internal.Execution.CompositeWorkItem.PerformWork() Line 100	C#
 	nunit.framework.dll!NUnit.Framework.Internal.Execution.WorkItem.RunOnCurrentThread() Line 442	C#
 	nunit.framework.dll!NUnit.Framework.Internal.Execution.WorkItem.Execute() Line 226	C#
 	nunit.framework.dll!NUnit.Framework.Internal.Execution.SimpleWorkItemDispatcher.Dispatch(NUnit.Framework.Internal.Execution.WorkItem work) Line 75	C#
 	nunit.framework.dll!NUnit.Framework.Internal.Execution.CompositeWorkItem.RunChildren() Line 285	C#
 	nunit.framework.dll!NUnit.Framework.Internal.Execution.CompositeWorkItem.PerformWork() Line 100	C#
 	nunit.framework.dll!NUnit.Framework.Internal.Execution.WorkItem.RunOnCurrentThread() Line 442	C#
 	nunit.framework.dll!NUnit.Framework.Internal.Execution.WorkItem.Execute() Line 226	C#
 	nunit.framework.dll!NUnit.Framework.Internal.Execution.SimpleWorkItemDispatcher.Dispatch(NUnit.Framework.Internal.Execution.WorkItem work) Line 75	C#
 	nunit.framework.dll!NUnit.Framework.Internal.Execution.CompositeWorkItem.RunChildren() Line 285	C#
 	nunit.framework.dll!NUnit.Framework.Internal.Execution.CompositeWorkItem.PerformWork() Line 100	C#
 	nunit.framework.dll!NUnit.Framework.Internal.Execution.WorkItem.RunOnCurrentThread() Line 442	C#
 	nunit.framework.dll!NUnit.Framework.Internal.Execution.WorkItem.Execute() Line 226	C#
 	nunit.framework.dll!NUnit.Framework.Internal.Execution.SimpleWorkItemDispatcher.Dispatch(NUnit.Framework.Internal.Execution.WorkItem work) Line 75	C#
 	nunit.framework.dll!NUnit.Framework.Internal.Execution.CompositeWorkItem.RunChildren() Line 285	C#
 	nunit.framework.dll!NUnit.Framework.Internal.Execution.CompositeWorkItem.PerformWork() Line 100	C#
 	nunit.framework.dll!NUnit.Framework.Internal.Execution.WorkItem.RunOnCurrentThread() Line 442	C#
 	nunit.framework.dll!NUnit.Framework.Internal.Execution.WorkItem.Execute() Line 226	C#
 	nunit.framework.dll!NUnit.Framework.Internal.Execution.SimpleWorkItemDispatcher.RunnerThreadProc() Line 81	C#
 	mscorlib.dll!System.Threading.ThreadHelper.ThreadStart_Context(object state)	Unknown
 	mscorlib.dll!System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state, bool preserveSyncCtx)	Unknown
 	mscorlib.dll!System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state, bool preserveSyncCtx)	Unknown
 	mscorlib.dll!System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state)	Unknown
 	mscorlib.dll!System.Threading.ThreadHelper.ThreadStart()	Unknown
 	[Native to Managed Transition]	
``</Code>
    <Description>Recently we started encountering strange issues with our NUnit tests. In the middle of the execution, progress stops. If we attach to the application we see that no test is actually executed - NUnit just waits for the previous test to finish and apparently there is no one to signal that. After some investigation, we believe this is due to the following exception that we keep encountering:

``

We are using custom built NUnit framework in order to be able to debug it. Any suggestions would be much appreciated. We are ready to do some work ourselves - just need some pointers on what might be the issue. The whole setup is rather complex, event the test causing the hang is different every time.</Description>
  </Issue>
  <Issue>
    <IssueID>2327</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Assert fails in my Test</Title>
    <CreatedDate>20/07/2017</CreatedDate>
    <ClosedDate>06/10/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>2327</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>confirm</Name>
        <IssueID>2327</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description> Assert.AreEqual(text, getelement.getwebelementtext(element));   

'text' and 'getelement.getwebelementtext(element)' are same. But this step fails always. 

I am using NUnit - 3.7.1, NUnit3TestAdpater - 3.7.

</Description>
  </Issue>
  <Issue>
    <IssueID>2325</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>jnm2</FixedById>
        <IssueID>2325</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Retry attribute doesn't retry the test.</Title>
    <CreatedDate>19/07/2017</CreatedDate>
    <ClosedDate>12/12/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2325</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>2325</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>2325</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>c#
[Test, Order(2)]
[Retry(3)]
public void Login()
{
    step.BasicActions.LoginAndOpenPart15038(_driver);
    Assert.True(false == _driver.Url.Contains("login.html"));
}
`</Code>
    <Description>I've already used assert.true(), but it doesn't retry the test.

``</Description>
  </Issue>
  <Issue>
    <IssueID>2324</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Does.Not.Throw</Title>
    <CreatedDate>19/07/2017</CreatedDate>
    <ClosedDate>25/07/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:wontfix</Name>
        <IssueID>2324</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>design</Name>
        <IssueID>2324</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>2324</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I prefer `Does.Not.Throw` to `Throws.Nothing`. It also opens the door to `Does.Not.Throw.InstanceOf&lt;&gt;()`.

Impressions?</Description>
  </Issue>
  <Issue>
    <IssueID>2323</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Rename TestListener.NULL to Null</Title>
    <CreatedDate>18/07/2017</CreatedDate>
    <ClosedDate>16/01/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:wontfix</Name>
        <IssueID>2323</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>design</Name>
        <IssueID>2323</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>`NULL` goes against our coding standard and I dislike it. It also doesn't match the .NET BCL or .NET design guidelines.

It's in the internal namespace so we should be good to up and rename it, right?</Description>
  </Issue>
  <Issue>
    <IssueID>2322</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Cannot set WorkDirectory of test from external code because TestExecutionContext.DefaultWorkDirectory is internal</Title>
    <CreatedDate>17/07/2017</CreatedDate>
    <ClosedDate>18/07/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>2322</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Since the changes in #2072, I'm not able to specify the Working Directory of a test from an external runner anymore.

I have a basic helper library that runs tests directly from any `void Main()`, and it needs to be able to specify the working directory for each test (value passed from the build server). Previously, I could set it on the `TestExecutionContext.WorkDirectory` property which has been removed.

The code now use the static property `TestContext.DefaultWorkDirectory`, but it is `internal` and cannot be changed from external code. The only code that seems to be able to change this value is in `DefaultTestAssemblyBuilder`, but I would prefer being able to setup and run the test methods myself.

Is there some other way to specify the working directory of each test that I missed?</Description>
  </Issue>
  <Issue>
    <IssueID>2321</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Cannot set or clear current TestExecutionContext from external runner code anymore</Title>
    <CreatedDate>17/07/2017</CreatedDate>
    <ClosedDate>19/07/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>2321</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>The `TestExecutionContext.ClearCurrentContext()` method has been removed in 3.7.x, and the `TestExecutionContext.CurrentContext` property cannot be set from external code (marked `internal set` in .NET Standard builds).

I have a very basic test runner that allows me to run my tests from an assembly's `void Main(..)`. It creates a fake `TestExecutionContext` for each test method that is being executed. I was using `EstablishExecutionEnvironment()` and `ClearCurrentContext()` in previous versions to install/remove this context.

Am I missing something, or is there another way to achieve the same result?</Description>
  </Issue>
  <Issue>
    <IssueID>2319</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>jnm2</FixedById>
        <IssueID>2319</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Add .editorconfig to set file encodings so that people don't have to think about it</Title>
    <CreatedDate>13/07/2017</CreatedDate>
    <ClosedDate>12/10/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2319</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:build</Name>
        <IssueID>2319</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>2319</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>These days we want every file to be UTF-8 with no byte order mark. It's universally understood and compatible, unlike the ANSI encoding Visual Studio will use by default. This is a typical problem any time you copy and paste special characters from the clipboard into VS. It results in tests running fine locally and blowing up in Travis (see 

Obviously, this is not something we want people to have to even think about if we can possibly avoid it. So many things have native `.editorconfig` support that it is worthwhile to start one just to override the charset of every file on save.

(EditorConfig helps developers define and maintain consistent coding styles between different editors and IDEs. </Description>
  </Issue>
  <Issue>
    <IssueID>2318</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>How to test specific base class?</Title>
    <CreatedDate>12/07/2017</CreatedDate>
    <ClosedDate>12/07/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:duplicate</Name>
        <IssueID>2318</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I have a class want to test that was inherited in the same assembly. That class has a test function that need to test just on the base class. I want the test to only run once, not run on inherited

How could I do?</Description>
  </Issue>
  <Issue>
    <IssueID>2315</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Cannot attach the file as database during OneTimeSetUp</Title>
    <CreatedDate>11/07/2017</CreatedDate>
    <ClosedDate>16/01/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:norepro</Name>
        <IssueID>2315</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I have a testing project for my REST API that uses a different database from my application. But lately I stopped being able to run tests, probably due to a few changes made using migrations in my original project.

The message I am getting is:

`    OneTimeSetUp: System.Reflection:TargetInvocationException: Exception has been thrown by the target of an invocation.----&gt; System.Data.SqlClientException: Cannot attach the file ...\aspnet-RenterLog-Rest-Testing.mdf as aspnet-RenterLog-Rest-Testing. 
`
I already deleted the previous existing database to build it from the beginning but It did not work. Already tried also a few suggestions that I have found through internet but it did not work also.

I will share with you my connection string:

`      &lt;add name="DefaultConnection" connectionString="Data Source=(LocalDb)\MSSQLLocalDB;AttachDbFilename=|DataDirectory|\aspnet-RenterLog-Unit-Testing.mdf;Initial Catalog=aspnet-RenterLog-Unit-Testing;Integrated Security=True" providerName="System.Data.SqlClient" /&gt;`

I also have this Parameters set:

    ``

</Description>
  </Issue>
  <Issue>
    <IssueID>2313</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>MhdTlb</FixedById>
        <IssueID>2313</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Incorrect xmldoc on RetryAttribute</Title>
    <CreatedDate>10/07/2017</CreatedDate>
    <ClosedDate>12/07/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2313</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>good first issue</Name>
        <IssueID>2313</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>2313</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>2313</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>The xmldoc on RetryAttribute has been copy/pasted from RepeatAttribute. This should be corrected.



We already have some doc for RetryAttribute - so this could be a good issue for a first time contributor. 🙂 

</Description>
  </Issue>
  <Issue>
    <IssueID>2311</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Resolve test projects' namespace situation</Title>
    <CreatedDate>10/07/2017</CreatedDate>
    <ClosedDate>07/11/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2311</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:refactor</Name>
        <IssueID>2311</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>2311</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>We are fighting uphill against convention and against most contributors' tooling by not namespacing according to folder structure. We're inconsistent which leads to confusion and a bunch of `using` directives with the name segments in a different order when adding new files.

I propose that we (I'm willing) do a sweep and make everything match the folder structure. Most people are used to working this way. The root namespace in every file will be `NUnit.Framework.Tests`.

`NUnit.Framework.Internal.Tests` would become `NUnit.Framework.Tests.Internal`.
`NUnit.Framework.Helpers.Tests` would become `NUnit.Framework.Tests.Helpers` (as an example; we'll actually see this when we get to NUnit.Console).

It's bothered me continually since my first PR here and it bothers new contributors as well. I've had it in my mind for months to open this issue but I put it off since it will obviously create merge conflicts in all open PRs. We need to just pick a time and get 'er done.</Description>
  </Issue>
  <Issue>
    <IssueID>2092</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>2092</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Convert Portable library to .NET Standard 1.3</Title>
    <CreatedDate>24/03/2017</CreatedDate>
    <ClosedDate>24/05/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:build</Name>
        <IssueID>2092</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>2092</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>
Restoring packages for C:\src\spikes\NetstandardLibrary\NetstandardLibrary\NetstandardLibrary.csproj...
Package NUnit 3.6.1 is not compatible with netstandard1.3 (.NETStandard,Version=v1.3). Package NUnit 3.6.1 supports:
  - monoandroid (MonoAndroid,Version=v0.0)
  - net20 (.NETFramework,Version=v2.0)
  - net35 (.NETFramework,Version=v3.5)
  - net40 (.NETFramework,Version=v4.0)
  - net45 (.NETFramework,Version=v4.5)
  - netstandard1.6 (.NETStandard,Version=v1.6)
  - portable-net45+win8+wp8+wpa81 (.NETPortable,Version=v0.0,Profile=Profile259)
  - xamarinios10 (Xamarin.iOS,Version=v1.0)
One or more packages are incompatible with .NETStandard,Version=v1.3.
Package restore failed. Rolling back package changes for 'NetstandardLibrary'.
`</Code>
    <Description>The portable library is .NET Standard 1.3 (or possibly 1.0 or 1.1), but it cannot easily be installed in a .NET Standard 1.3 project. Attempting to do so results in the following error,

``

If we convert the project to the lowest .NET Standard version it supports instead of PCL, it will still work in all the PCL targets, plus it will work in .NET Standard.

Before we do this, can anyone see any issues with this approach?</Description>
  </Issue>
  <Issue>
    <IssueID>2091</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>When a native exception of corrupted state is thrown, nunit test thread crashes and the nunit-console process hangs</Title>
    <CreatedDate>22/03/2017</CreatedDate>
    <ClosedDate>26/10/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2091</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>2091</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>2091</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>When using NUnit in C++/CLI and the state is somehow corrupted (unrecoverable errors), the nunit thread that runs the test crashes. The nunit-console thread that is waiting on the operation to complete, never exits the wait and therefore hangs the whole process.

Maybe using NUnit for C++/CLI is not supported, but we have a lot of them.

I have made a quick fix like this in NUnit.Framework.Internal.Reflect in Reflect.cs:
``
</Description>
  </Issue>
  <Issue>
    <IssueID>2090</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>No start-test or test-case events on Mac OS X under Mono</Title>
    <CreatedDate>22/03/2017</CreatedDate>
    <ClosedDate>25/07/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:norepro</Name>
        <IssueID>2090</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I made a simple test event listener engine extension that handles &lt;start-test...&gt; and &lt;test-case...&gt; events. Just like  teamcity extension does. It works perfectly on Windows environment. On Mac OS X the engine doesn't send "start-test" and "test-case" reports to OnTestEvent. But it sends other types of events.</Description>
  </Issue>
  <Issue>
    <IssueID>2089</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Initializing an EGL display fails only in NUnit </Title>
    <CreatedDate>22/03/2017</CreatedDate>
    <ClosedDate>08/11/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:norepro</Name>
        <IssueID>2089</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Not sure this is a bug but initializing an EGL display from NUnit fails with EGL_NOT_INITIALIZED, while it suceeds with MSTest and from any console/window application: 

``

</Description>
  </Issue>
  <Issue>
    <IssueID>2088</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>AssemblyCleanup,AssemblyInitialize , how to use in Nunit</Title>
    <CreatedDate>22/03/2017</CreatedDate>
    <ClosedDate>22/03/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2088</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>2088</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>In MStest we have these attribute •	AssemblyInitialize, how to use in Nunit, Do we have any attribute</Description>
  </Issue>
  <Issue>
    <IssueID>2087</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>2087</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Enhance error message: Test is not runnable in single-threaded context. Timeout</Title>
    <CreatedDate>21/03/2017</CreatedDate>
    <ClosedDate>24/03/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2087</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>good first issue</Name>
        <IssueID>2087</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>2087</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>2087</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>When using the SingleThreadedAttribute and a TimeOutAttribute on a class, you get the error message:
"Test is not runnable in single-threaded context. Timeout".
It took quite a while to figure out what went wrong (I initially thought that my TestFixtureSetup code took too long).

Suggested error message:
"The SingleThreaded attribute and the Timeout attribute cannot be combined".</Description>
  </Issue>
  <Issue>
    <IssueID>2083</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>TestCaseSource skipping item</Title>
    <CreatedDate>16/03/2017</CreatedDate>
    <ClosedDate>26/10/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:duplicate</Name>
        <IssueID>2083</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>My coworker and I have come across an odd behavior when using TestCaseSource. I have defined a datasource with 3 items in it, however when my test executes it is only ever handed the first and third item. I have attached a project which replicates the issue.

[NunitTestProject.zip](
</Description>
  </Issue>
  <Issue>
    <IssueID>2082</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>HttpMock.dll(1.3.3) Has no TestFixtures with Nunit3-console.exe  </Title>
    <CreatedDate>15/03/2017</CreatedDate>
    <ClosedDate>15/03/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>2082</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Hi,

We have a project depends on HttpMock, recently I upgrade the Nunit from 2.6.4 to 3.6.1, HttpMock from 1.1.5 to 1.3.3. As the project is under AppVeyor which will detect HttpMock.dll as a test assembly, then I got this error:

&gt;NUnit Console Runner 3.5.0 
Copyright (C) 2016 Charlie Poole
Runtime Environment
   OS Version: Microsoft Windows NT 6.3.9600.0
  CLR Version: 4.0.30319.42000
Test Files
    C:\projects\d2l-security-oauth2\src\D2L.Security.OAuth2.TestFramework\bin\Debug\HttpMock.dll
    C:\projects\d2l-security-oauth2\test\D2L.Security.OAuth2.IntegrationTests\bin\Debug\D2L.Security.OAuth2.IntegrationTests.dll
    C:\projects\d2l-security-oauth2\test\D2L.Security.OAuth2.UnitTests\bin\Debug\D2L.Security.OAuth2.UnitTests.dll

&gt;Errors and Failures
&gt;1) Invalid : C:\projects\d2l-security-oauth2\src\D2L.Security.OAuth2.TestFramework\bin\Debug\HttpMock.dll
Has no TestFixtures

But it worked fine with HttpMock 1.1.5 before. not sure if it is the problem with Nunit3 or HttpMock1.3.3?</Description>
  </Issue>
  <Issue>
    <IssueID>2079</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Make TestMethod.Arguments public or otherwise accessible (e.g. TestContext)</Title>
    <CreatedDate>13/03/2017</CreatedDate>
    <ClosedDate>06/04/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2079</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>2079</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>2079</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>NUnit 3.6.1 (from NuGet)

I need a property in test's base class that returns a different value depending on test method's parameters (details in this SO question:  - I don't feel they are strictly relevant here though).

I've created a `ITestAction` attribute and in the `BeforeTest` call I have access to `TestMethod` instance describing currently executed test. 

If I could read the `Arguments` property I could react and accordingly set some properties in the fixture's base. Unfortunately, it's internal. This doesn't seem justified - a `TestMethod` description should naturally present method call arguments to the clients.

As a side note, I've tried also to use properties for this scenario, but even though I added them to my `TestCaseSource` results, they are not accessible from test method's level (probably related to issues #1358, #548 or #796).</Description>
  </Issue>
  <Issue>
    <IssueID>2078</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>NUnit 3 console runner ignores [Explicit] attribute for NUnit2 tests</Title>
    <CreatedDate>13/03/2017</CreatedDate>
    <ClosedDate>20/03/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>2078</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>confirm</Name>
        <IssueID>2078</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Hi,
I am currently working on an upgrade of our build server system and try to use NUnit 3 console runner with TeamCity. Because we have a lot of assemblies, which are still compiled against the NUnit 2.6.4, I installed the NUnit 3 console runner incl. extension as a NuGet package in the latest version (3.6.1) and it works fine besides that it also runs tests, where the [TestFixture] is also marked as [Explicit].
Any ideas, what I am doing wrong or is it an issue with the current console runner? Is it an issue with the mixture of assemblies with NUnit 2.6.4 and NUnit 3?

This is the command, which gets invoked by TeamCity:
`nunit3-console.exe C:\BuildAgent\temp\buildTmp\UK66MMKvlXUBK3DDEBoL6Vj7QEB2xLjR.nunit --result=C:\BuildAgent\temp\buildTmp\UK66MMKvlXUBK3DDEBoL6Vj7QEB2xLjR.nunit.xml --noheader --x86 --where cat!=Nightly&amp;&amp;cat!=Hardware --skipnontestassemblies --list-extensions --explore=C:\BuildAgent\temp\buildTmp\UpR2sSrldQDnoutBlzfm92zNgxmlppMd_all.tests`

Command line output:

&gt; [09:28:00][Step 5/7] Runtime Environment
[09:28:00][Step 5/7]    OS Version: Microsoft Windows NT 6.1.7601 Service Pack 1
[09:28:00][Step 5/7]   CLR Version: 4.0.30319.42000
[09:28:00][Step 5/7] 
[09:28:00][Step 5/7] Installed Extensions
[09:28:00][Step 5/7]   Extension Point: /NUnit/Engine/NUnitV2Driver
[09:28:00][Step 5/7]     Extension: NUnit.Engine.Drivers.NUnit2FrameworkDriver
[09:28:00][Step 5/7]   Extension Point: /NUnit/Engine/TypeExtensions/IService
[09:28:00][Step 5/7]   Extension Point: /NUnit/Engine/TypeExtensions/ITestEventListener
[09:28:00][Step 5/7]     Extension: NUnit.Engine.Listeners.TeamCityEventListener
[09:28:00][Step 5/7]   Extension Point: /NUnit/Engine/TypeExtensions/IDriverFactory
[09:28:00][Step 5/7]   Extension Point: /NUnit/Engine/TypeExtensions/IProjectLoader
[09:28:00][Step 5/7]     Extension: NUnit.Engine.Services.ProjectLoaders.NUnitProjectLoader
[09:28:00][Step 5/7]       FileExtension: .nunit
[09:28:00][Step 5/7]     Extension: NUnit.Engine.Services.ProjectLoaders.VisualStudioProjectLoader
[09:28:00][Step 5/7]       FileExtension: .sln .csproj .vbproj .vjsproj .vcproj .fsproj
[09:28:00][Step 5/7]   Extension Point: /NUnit/Engine/TypeExtensions/IResultWriter
[09:28:00][Step 5/7]     Extension: NUnit.Engine.Addins.NUnit2XmlResultWriter
[09:28:00][Step 5/7]       Format: nunit2
[09:28:00][Step 5/7] 
[09:28:00][Step 5/7] Test Files
[09:28:00][Step 5/7]     C:\BuildAgent\temp\buildTmp\UK66MMKvlXUBK3DDEBoL6Vj7QEB2xLjR.nunit
[09:28:00][Step 5/7] 
[09:28:00][Step 5/7] Test Filters
[09:28:00][Step 5/7]     Where: cat!=Nightly&amp;&amp;cat!=Hardware
[09:28:00][Step 5/7] 
[09:28:00][Step 5/7] Results (nunit3) saved as C:\BuildAgent\temp\buildTmp\UpR2sSrldQDnoutBlzfm92zNgxmlppMd_all.tests

TIA Tim</Description>
  </Issue>
  <Issue>
    <IssueID>2077</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Add support for NUnit vs .Net Core projects in VS 2017.</Title>
    <CreatedDate>12/03/2017</CreatedDate>
    <ClosedDate>28/03/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:duplicate</Name>
        <IssueID>2077</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Currently NUnit test adapter works only with .Net Framework 4.0+ projects in VS 2017.
Please add full support for .Net core projects under VS 2017.
xUnit works with .net Core under VS 2017 RC (+ with R#) more than half of a year.
Please do not force our team to switch to xUnit. We will never back again.
P.S. Probably this is duplicate issue.</Description>
  </Issue>
  <Issue>
    <IssueID>2076</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Agents and workers not being respected</Title>
    <CreatedDate>10/03/2017</CreatedDate>
    <ClosedDate>11/04/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:norepro</Name>
        <IssueID>2076</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I have a specflow project which I run using the NUnit3 console runner.  I set --workers=5 and --agents=5 in the command line as well, and have the Parallelizable(ParaallelScopeFixtures) value set in my AssemblyInfo file.  However, when I run this, it spins up more then 5 simultaneous threads.  </Description>
  </Issue>
  <Issue>
    <IssueID>2075</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>CollectionAssert.AreEqual in Nunit3.0</Title>
    <CreatedDate>09/03/2017</CreatedDate>
    <ClosedDate>10/03/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>2075</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Hello,

I see that CollectionAssert.AreEqual is deprecated after Nunit2.5.
How do I compare two lists using a user defined "Icomparer" for equality, in Nunit3.0 ? 
Any help is appreciated. Thanks..</Description>
  </Issue>
  <Issue>
    <IssueID>2074</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Mono AOT and constraints inheriting IConstraint.ApplyTo&lt;TActual&gt; gives errors</Title>
    <CreatedDate>09/03/2017</CreatedDate>
    <ClosedDate>18/05/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>confirm</Name>
        <IssueID>2074</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>So when working with platforms that only support AOT, we ran into problems using nunit, because of virtual generic methods. Almost all Assert's use this Constraint hierarchy.

We fixed it on our local fork of nunit. Without a big redesign, the only fix was to change  IConstraint.ApplyTo&lt;TActual&gt; to IConstraint.ApplyTo(object), and boxed the value when applying the test.

Dont know if you guys would accept this solution? Otherwise a new version of nunit should work with mono AOT.</Description>
  </Issue>
  <Issue>
    <IssueID>2073</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>2073</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Convert .NET Standard Projects to VS2017</Title>
    <CreatedDate>09/03/2017</CreatedDate>
    <ClosedDate>09/03/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2073</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>2073</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>VS2017 was released this week along with the updated .NET Core tooling which switches from the project.json format to CSPROJ. We will need to update the .NET Standard projects to the new format soon because I am pretty sure installing the new tooling will make the old tooling inoperable, so any developer who installs .NET Core with VS2017 will no longer be able to build.Before we make the change, we need to make sure that AppVeyor has VS2017 images available and the core NUnit team has VS2017 installed.</Description>
  </Issue>
  <Issue>
    <IssueID>2071</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Object comparison errors(Expected and actual are both)</Title>
    <CreatedDate>03/03/2017</CreatedDate>
    <ClosedDate>03/03/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>2071</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Am getting below exception eventhough both the objects has same values.

{"  Expected and actual are both &lt;ClassA&gt;\r\n  Values differ at index [1]\r\n  Expected: &lt;&gt;\r\n  But was:  &lt;&gt;\r\n"}

  ClassA test = GetMatch(cleanedCellText, true);
   ClassA test1 =GetMatch(cleanedCellText, true);
 Assert.AreEqual(test1, test );  // Exception 
 Assert.AreEqual(test, test );  return true 

</Description>
  </Issue>
  <Issue>
    <IssueID>2069</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Error with Is Equal To on Mono</Title>
    <CreatedDate>03/03/2017</CreatedDate>
    <ClosedDate>18/05/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>confirm</Name>
        <IssueID>2069</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I've the following Test:

		public struct TestPoint : IEquatable&lt;TestPoint&gt;
		{
			public double X { get; set; }
			public double Y { get; set; }

			public TestPoint(double x, double y)
				: this()
			{
				X = x;
				Y = y;
			}

			public bool Equals(TestPoint other)
			{
				return X == other.X &amp;&amp; Y == other.Y;
			}

			public override bool Equals(object obj)
			{
				return obj is TestPoint &amp;&amp; Equals((TestPoint)obj);
			}

			public static bool operator ==(TestPoint x, TestPoint y)
			{
				return x.Equals(y);
			}

			public static bool operator !=(TestPoint x, TestPoint y)
			{
				return !(x == y);
			}

			public override int GetHashCode()
			{
				return X.GetHashCode() ^ Y.GetHashCode();
			}
		}
		[Test]
		public void IsEqualToTest()
		{
			var t1 = (object) new TestPoint(1, 2);
			var t2 = (object)new TestPoint(1, 2);
			if (t1 is TestPoint)
			{
				var p1 = (TestPoint)t1;
				var p2 = (TestPoint)t2;
				Console.WriteLine("p1x:" + p1.X);
				Console.WriteLine("p1x:" + p1.X.ToString("G17"));
				Console.WriteLine("p1y:" + p1.Y);
				Console.WriteLine("p1y:" + p1.Y.ToString("G17"));
				Console.WriteLine("p2x:" + p2.X);
				Console.WriteLine("p2x:" + p2.X.ToString("G17"));
				Console.WriteLine("p2y:" + p2.Y);
				Console.WriteLine("p2y:" + p2.Y.ToString("G17"));
				Console.WriteLine("=" + (p1 == p2));
				Console.WriteLine("=" + (p1.X == p2.X));
				Console.WriteLine("=" + (p1.Y == p2.Y));
				Console.WriteLine("=" + (p1.Equals(p2)));
				Console.WriteLine("=" + (object.Equals(p1, p2)));
				Console.WriteLine("=" + (t1 == t2));
				Console.WriteLine("=" + (t1.Equals(t2)));
				Console.WriteLine("=" + (object.Equals(t1, t2)));
			}
			Assert.That(t1, Is.EqualTo(t2));
		}

wich Results in 

      p1x:1
      p1x:1
      p1y:2
      p1y:2
      p2x:1
      p2x:1
      p2y:2
      p2y:2
      =True
      =True
      =True
      =True
      =True
      =False
      =True
      =True

And Assert works on Windows, but on Mono (4.8, Linux) it throws

(you can see here in my Test results   error 1) at the End of the log)</Description>
  </Issue>
  <Issue>
    <IssueID>2067</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Test method has non-void return type, but no result is expected /  Wrong number of arguments provided</Title>
    <CreatedDate>02/03/2017</CreatedDate>
    <ClosedDate>02/03/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>2067</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Hi Folks, 
Have a big problem with running nunit-console on mono (debian server) tests were written on VS 2015.
On Windows, VS runs perfectly without any problem
NUnit 2.6.4
NUnitTestAdapter.WithFramework 2.0.0
MONO 4.0.0
Code Example below:

TestData code:

&gt; namespace My_Project.DataSource
&gt; {
&gt;     public class My_Data_Class
&gt;     {
&gt;         public static IEnumerable&lt;TestCaseData&gt; SearchFilterData
&gt;         {
&gt;             get
&gt;             {
&gt;              yield return new TestCaseData(
&gt;                     "Some_String_1",
&gt;                     "Some_String_2",
&gt;                     "Some_String_3",
&gt;                     "Some_String_4")
&gt;                     .Returns("success")
&gt;                     .SetCategory("Some_Categorie")
&gt;                     .SetName("Some_Name");
&gt;             }
&gt;        }
&gt;    }
&gt; }

Test code: 

&gt; namespace My_Project
&gt; {
&gt;     public class Some_Test
&gt;     {
&gt;         [Test, TestCaseSource(typeof(My_Data_Class), "SearchFilterData")]
&gt;         public string Search(string text1, string text2, string text3, string text4)
&gt;         {
&gt;              //do something ...
&gt;             return "success";
&gt;         }
&gt;     }
&gt; }

In this case, i receive "Test method has non-void return type, but no result is expected"

If I make Search Method void:   "Wrong number of arguments provided"

Please help.


</Description>
  </Issue>
  <Issue>
    <IssueID>2065</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Is Nunit test project configurable to Jenkins</Title>
    <CreatedDate>01/03/2017</CreatedDate>
    <ClosedDate>01/03/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2065</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>2065</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Is Nunit test project configurable to Jenkins? 
Can you send me the steps to do this. 

If any test case fails then we need to show project build failed in jenkins</Description>
  </Issue>
  <Issue>
    <IssueID>2064</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>How to execute nunit test as part of visual studio build</Title>
    <CreatedDate>01/03/2017</CreatedDate>
    <ClosedDate>01/03/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2064</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>2064</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I have one project and added new unitTest project in VS 2015, Am able to debug or execute individual test cases using nunit3 adapter. 

When I build Visual studio how to execute Unit Test project and if any test case fails build should fail. 
How to trigger Nunit project with visual studio 2015 build. 

send me options , Is there any simple properties change required

Thanks,
Gopi</Description>
  </Issue>
  <Issue>
    <IssueID>2063</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>NUnit 3.6.1 not working with .NET Framework 4.5.2</Title>
    <CreatedDate>01/03/2017</CreatedDate>
    <ClosedDate>01/03/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>2063</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Latest version of **NUnit is 3.6.1**. And Microsoft **Visual Studio 2015 uses .NET Framework 4.5.2**. I wrote my first Nunit Test and it failed to run. I had to degrade (switch to a lower version) to .NET Framework 4.5 and it started working. But we do not intend to. Is there a way to use latest .NET Frameworks and write NUnit tests as well

- [ ] Next we are planning to shift to Microsoft Visual Studio 2017 which uses .NET Framework 4.6.2. We want to go with NUnit. Please suggest.</Description>
  </Issue>
  <Issue>
    <IssueID>2062</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>OmicronPersei</FixedById>
        <IssueID>2062</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>TestCaseSource attribute causes test to pass when source is not defined</Title>
    <CreatedDate>28/02/2017</CreatedDate>
    <ClosedDate>12/08/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2062</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>2062</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>2062</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>csharp
public class TestClass 
{
   [TestCaseSource("UndefinedSource")]
   public void Test(int param) { }
}
`</Code>
    <Description>Steps to reproduce:
1. Create a new project,
2. Reference nunit.framework.dll version 3.6.1
3. Paste the following snippet as a class into the project:
4. Compile project and run the tests using nunit3-console.exe

``

Observed result:
1. Test Count: 0, Passed: 0, Failed: 0, Warnings: 0, Inconclusive: 0, Skipped: 0
2. TestResult.xml contains node &lt;test-suite name="Test" result="Passed" /&gt; with no children

Expected result:
1. NUnit should report absence of class member referenced in by the attribute as an error</Description>
  </Issue>
  <Issue>
    <IssueID>2061</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>2061</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>TestContext.WorkDirectory not initialized during build process</Title>
    <CreatedDate>27/02/2017</CreatedDate>
    <ClosedDate>08/03/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2061</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>2061</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>2061</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>``

returns the CurrentDirectory during the build phase since there is no TestExecutionContext (null) at the time that the TestCaseSource is processed/created.</Description>
  </Issue>
  <Issue>
    <IssueID>2054</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>NUnit 3.6.0 problem on Xamarin platforms</Title>
    <CreatedDate>24/02/2017</CreatedDate>
    <ClosedDate>25/02/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>2054</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>confirm</Name>
        <IssueID>2054</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I experience the following issue in my own [testrunner project](
Calling `Assert.True(false);` causes NullReferenceException:
`  at NUnit.Framework.Assert.ReportFailure(String message)
   at NUnit.Framework.Assert.ReportFailure(ConstraintResult result, String message, Object[] args)
   at NUnit.Framework.Assert.That[TActual](TActual actual, IResolveConstraint expression, String message, Object[] args)
   at NUnit.Framework.Assert.True(Boolean condition)
   at Sample.MyTest.Fail()`

I came across it, when added FsUnit test support. FsUnit 3.0.0-beta1 supports .NET Standard 1.6 and this requires NUnit 3.6.0.
Until NUnit 3.5.0 I have experienced no problem.

In a Xamarin Android or iOS project, or even in a UWP project the problem appears with .NET Standard version, I suppose. If I update the NUnit NuGet package from 3.5.0 to 3.6.0 in one of the [samples]( it breaks.
What am I missing?

The easiest way to reproduce the issue is using the UWP sample. Just bump the NUnit package version in project.json from 3.5.0 to 3.6.0 and run the app.  The problem occurs at the test named 'Fail' </Description>
  </Issue>
  <Issue>
    <IssueID>2053</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Exception in LaunchAgentProcess when running under TeamCity</Title>
    <CreatedDate>24/02/2017</CreatedDate>
    <ClosedDate>24/02/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:duplicate</Name>
        <IssueID>2053</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Any ideas what this might be. Seems to be a problem in the test runner itself. Command line options are nunit3-console.exe 'assemblies' --teamcity --x86 --workers=0 --process=Multiple --where cat=UnitTest (I added --workers=0 --process=Multiple to try to fix the issue).

The odd thing is this has not happened when I run the same command line from a command prompt.

Teamcity version is 9.1 (build 36973), Nuget Package versions are:

``</Description>
  </Issue>
  <Issue>
    <IssueID>2052</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>gcichosz</FixedById>
        <IssueID>2052</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>NullReferenceException with TestCaseSource if a property has no setter</Title>
    <CreatedDate>23/02/2017</CreatedDate>
    <ClosedDate>27/02/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2052</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>good first issue</Name>
        <IssueID>2052</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>2052</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>2052</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I've written a base class for running NSpec examples using NUnit. I just upgraded it to use NUnit 3, which worked fine. But when I try to target netstandard 1.6, I get the following when running tests:

``

I'm guessing that the exception happens here:



That code is only used with netstandard 1.6, which explains why things worked well before that.</Description>
  </Issue>
  <Issue>
    <IssueID>2051</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Visual Studio 2017 RC does not detect nunit tests</Title>
    <CreatedDate>23/02/2017</CreatedDate>
    <ClosedDate>23/02/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:duplicate</Name>
        <IssueID>2051</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Hi,

Visual Studio 2017 RC does not detect nunit tests. Package references NUnit 3.6.0, VS has NUnit 3 Test Adapter 3.7.0.0 installed, and project targets both .NET 4.0 and .NET Core RC4.

Running manually nunit from console or GUI works (targetting the .NET 4.0), but gets no debug backtrace (showing simply NullReferenceException on the test but not the backtrace of where it really happened).</Description>
  </Issue>
  <Issue>
    <IssueID>2050</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>2050</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Creation of TestExecutionContext should be explicit</Title>
    <CreatedDate>21/02/2017</CreatedDate>
    <ClosedDate>26/02/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2050</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:refactor</Name>
        <IssueID>2050</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>2050</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Originally, in V2,  it seemed to make sense to set `CurrentContext` lazily to a new context in the getter, whenever it was found to be null.

Now, with parallel dispatching, things are more complicated. The context is  changed as different tests begin to execute and the current work item both controls and depends upon it's content. When the context is discovered to be null, it's an error that we should not be masking.

The basic refactoring here is
* Make the getter function as a simple getter, returning null if that's what is found.
* Remove the `GetTestExecutionContext()` method, replacing all calls with use of the property.
* Discover all points in the code where the context is found to be null, and fix them.

Obviously, the last point is going to be difficult.</Description>
  </Issue>
  <Issue>
    <IssueID>2048</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Random Error with OpenCover</Title>
    <CreatedDate>20/02/2017</CreatedDate>
    <ClosedDate>20/02/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:duplicate</Name>
        <IssueID>2048</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Hello

We have an issue with NUnit when running it with OpenCover. 
Our tests are executed successfully but sometime NUnit report an error. Without coverage, we don't have any problem.

We are using the the nuget package 
&lt;package id="NUnit" version="3.6.0" targetFramework="net452" /&gt;
&lt;package id="NUnit.ConsoleRunner" version="3.6.0" targetFramework="net452"  /&gt;
&lt;package id="NUnit.Extension.NUnitV2ResultWriter" version="3.5.0" targetFramework="net452"  /&gt;

Starting Coverage for ABCDE
Executing: D:\abcde\lib\NUnit.ConsoleRunner\tools\nunit3-console.exe
Runtime Environment
   OS Version: Microsoft Windows NT 6.1.7601 Service Pack 1
  CLR Version: 4.0.30319.42000

Test Files
    D:\abcde\proj\bin\Debug\XYZ\ABCDE.XYZ.Unit.Tests.dll
    D:\abcde\proj\bin\Debug\ABCDE.Unit.Tests.dll

Test Filters
    Where: cat == ABCDE


Errors, Failures and Warnings

1) Error : D:\abcde\proj\bin\Debug\Sgcib.Iron.Aggregation.Plugin.XOne.Unit.Tests.dll
The given key was not present in the dictionary.
   at System.ThrowHelper.ThrowKeyNotFoundException()
   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)
   at NUnit.Engine.Services.TestAgency.AgentDataBase.get_Item(Guid id)
   at NUnit.Engine.Services.TestAgency.CreateRemoteAgent(TestPackage package, Int32 waitTime)
   at NUnit.Engine.Services.TestAgency.GetAgent(TestPackage package, Int32 waitTime)
   at NUnit.Engine.Runners.ProcessRunner.CreateAgentAndRunner()
   at NUnit.Engine.Runners.ProcessRunner.RunTests(ITestEventListener listener, TestFilter filter)

Run Settings
    DisposeRunners: True
    DefaultTimeout: 600000
    WorkDirectory: C:\Users\ABCEF\AppData\Local\Temp
    MaxAgents: 4
    NumberOfTestWorkers: 1
    ImageRuntimeVersion: 4.0.30319
    ImageTargetFrameworkName: .NETFramework,Version=v4.5.2
    ImageRequiresX86: False
    ImageRequiresDefaultAppDomainAssemblyResolver: False

Test Run Summary
  Overall result: Failed
  Test Count: 8, Passed: 8, Failed: 0, Warnings: 0, Inconclusiv0, Skipped: 0
  Start time: 2017-02-17 22:31:47Z
    End time: 2017-02-17 22:34:50Z
    Duration: 182.701 seconds

Results (nunit2) saved as D:\abcde\nunit-report-ABCD.xml
Committing...
Visited Classes 216 of 1516 (14.25)
Visited Methods 750 of 8329 (9)
Visited Points 5137 of 55802 (9.21)
Visited Branches 1459 of 18950 (7.70)

Regards

Sébastien</Description>
  </Issue>
  <Issue>
    <IssueID>2047</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Braking change in TestStatus enum</Title>
    <CreatedDate>20/02/2017</CreatedDate>
    <ClosedDate>20/02/2017</ClosedDate>
    <IssueLabels />
    <Description> has a braking change. If you want to change an enum, you should add new item below or you should use explicit item value, for example:

Inconclusive = 0,
Skipped = 1,
etc.

Currently the Warning item has value for Failed item in previous versions.</Description>
  </Issue>
  <Issue>
    <IssueID>2045</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>gcichosz</FixedById>
        <IssueID>2045</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>NUnitlite-runner crashes if no file is provided</Title>
    <CreatedDate>17/02/2017</CreatedDate>
    <ClosedDate>27/02/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2045</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>good first issue</Name>
        <IssueID>2045</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>2045</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>2045</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>If you run nunitlite-runner without a file argument, it crashes. It should actually check and give an error message, just like nunit3-console.

This is slightly tricky because nunitlite-runner passes the arguments on to nunitlite. NUnitlite is often called without a file argument because the tests are in the failing exe. We need to fix this issue without breaking the behavior when nunitlite is called form a test. Most likely, we need a separate entry point.</Description>
  </Issue>
  <Issue>
    <IssueID>2044</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>NUnit Adapter 3.7 - Error</Title>
    <CreatedDate>17/02/2017</CreatedDate>
    <ClosedDate>17/02/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>2044</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>DataSources.TestCases has tow test cases, used in more than one test like shown below.
But the Test-Explorer shows only two tests in class Tests, expected are four. This seems to me an error in NUnit Adapter 3.7.
NUnit3TestExecutor does execute all tests, so it is possible to debug them. But is impossible to select one testcase and debug only Test1. Test2 is also executed.

`public class Tests {`
`[TestCaseSource(typeof(DataSources), nameof(DataSources.TestCases))]
[Test]
public void Test1(int value)
{    ...   }`

`[TestCaseSource(typeof(DataSources), nameof(DataSources.TestCases))]
[Test]
public void Test2(int value)
{    ...   }`</Description>
  </Issue>
  <Issue>
    <IssueID>2043</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>2043</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Regression in 3.6.0 when catching AssertionException</Title>
    <CreatedDate>16/02/2017</CreatedDate>
    <ClosedDate>25/02/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2043</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>2043</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:critical</Name>
        <IssueID>2043</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>@pdpurcell commented on [Thu Feb 16 2017](In version 3.5.0, catching a failed assertion would allow the test to continue and the test would then pass.  Version 3.6.0 continues running the code, but the final state will be set to failed.  Is this a regression?  I see no mention of this sort of behaviour change in the [release notes](  
I have [attached an example solution]( that contains two projects that have identical tests; one using 3.5.0 and one using 3.6.0.  
eg:
``---@CharliePoole commented on [Thu Feb 16 2017](The bad news is that this has __never actually been supported__ even though it's a technique promulgated on many blogs and forums. That is...

*NUnit makes no guarantee that failures cause an AssertionException that catching the exception will prevent the failure from happening. This is certainly not a guarantee in NUnit 3 and - to my memory - never was in NUnit V2 either.*

When this technique has come up, I have frequently tried to warn people off using it. There are lots of reasons to avoid it:

* It implies that your test knows something about the framework that is executing it, which is a serious violation of encapsulation - that is, unless you are actually testing the internals of framework itself.

* There are usually supported ways to accomplish whatever you are trying to do, without the  try / catch.

* Where there is an unsupported need, it makes more sense to request a feature, which will be supported now and in the future.

* It's an implementation detail of NUnit, which could change at any time.

Of course, the last point has come true in the latest release.

In NUnit 3.6, the details of the implementation have changed. We still use an exception to terminate execution of your test. It's the only way we have to unwind any nested calls you have made. However, we no longer use the exception to report that the test failed. That info is recorded before the exception is thrown. This allows us to use a consistent approach for single assertion failures, multiple assertion failures and warnings.

As you say, there is no mention of this in the release notes. That's because we felt that there was no need to document an internal change that should never be used by users. For the same reason, we didn't list this as a breaking change. From some of the feedback, it's clear that there are users who did __not__ consider this a detail of implementation and relied on it. There are already several issues.

Most of the issues - like yours - illustrate the "problem" without motivating the need to be able to intercept a failure. In each case, I have asked the submitter of the issue to give a motivating example that would help us meet the need. IOW we need to know __why__ you want to be able to prevent a failure by catching the AssertionException. In the long term, we may want to add features that make it unnecessary for you to do such a thing!

Since you're the fourth or fifth person to raise the issue, it is clear that we need to do something, in spite of my continued belief that you should not really be relying on how NUnit is implemented. I'll close this comment and start a fresh one with a proposal to partially role back the change.---@CharliePoole commented on [Thu Feb 16 2017](@nunit/framework-team @nunit/core-team 
As stated in my first comment here and on several other issues, I continue to believe that folks who rely on AssertionException and particularly on catching it are making a mistake. "NUnit implements failures via an assertion exception and you can stop the failure by catching it" is __not a sentence in our documentation__ and not part of the API we provide to programmers.

Several people have pointed out reasons why it should work, however:
* Most other frameworks work that way
* It has worked in the past
* Exceptions thrown is part of the API of many methods

I could argue against all of those points, but why bother? It seems that a number of users are affected and I think there's a change that can be made. Here's what I propose...

1. Stop creating the failure message in the result before throwing an AssertionException outside of a Multiple Assert block.

2. Continue to create the failure message without throwing when inside a Multiple Assert block.

3. Upon exit from a MultipleAssertBlock in which failures have occured, throw a (new) MultipleAssertionException rather than an AssertionException, so that the framework knows that one or more failures have already been recorded and need to be reported.

4. Continue to handle warnings as we do, recording them without throwing an exception.

This will ensure that __where we do throw an AssertionException__ it works exactly as before. Those places where we don't throw one are new features so no compatibility issue arises.

I think this is critical enough to warrant a hot fix release. Please let me know if you agree with that as well as with the fix itself. I can do the fix myself pretty quickly once we agree on it.</Description>
  </Issue>
  <Issue>
    <IssueID>2042</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>When I build my own ConstraintResult, Not is not accounted for</Title>
    <CreatedDate>16/02/2017</CreatedDate>
    <ClosedDate>16/02/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>2042</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I'm pretty sure this is just my lack of understanding of the API. 

NUnit, version v3.6.0.0
NUnit3TestAdapter v3.7.0

I have a method that uses the EqualConstraint and ConstraintResult objects directly (instead of nested in an Assert call). It is a workaround for some old code I am still supporting.

I ended up with the following code:

`var constraint = Is.Not.EqualTo(1.234d).Within(0.1d);`
`var result = constraint.ApplyTo(1.234d);`
`Assert.That(result.IsSuccess, Is.False);`

My Expectation is that the assertion would succeed: result.IsSuccess would be **false**, because 1.234d is equal to 1.234d.

The actual result, though, is that result.IsSuccess ends up **true**.

Is there some approach to constraints that I am not understanding? 

ETA: This is consistent regardless of the constraint type: it also happens on NullConstraint (test that a null object is not null still give result.IsSuccess true)</Description>
  </Issue>
  <Issue>
    <IssueID>2040</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>2040</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Cannot catch AssertionException</Title>
    <CreatedDate>15/02/2017</CreatedDate>
    <ClosedDate>27/02/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2040</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>2040</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Executing an NUnit assertion within a try block results in it not being captured by the catch block and it fails the test.

The following test fails due to the `Assert.False(true)` and does not throw the `NotImplementedException`:
``</Description>
  </Issue>
  <Issue>
    <IssueID>2039</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>[Invalid]</Title>
    <CreatedDate>15/02/2017</CreatedDate>
    <ClosedDate>15/02/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>2039</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Never mind, unrelated tooling issue.</Description>
  </Issue>
  <Issue>
    <IssueID>2038</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Run test in isolation</Title>
    <CreatedDate>15/02/2017</CreatedDate>
    <ClosedDate>15/02/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2038</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>2038</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Hi,

Is it possible to run a test method in isolation, i.e. no other tests runs in parallel?</Description>
  </Issue>
  <Issue>
    <IssueID>2036</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>SocketException when exploring a test assembly</Title>
    <CreatedDate>09/02/2017</CreatedDate>
    <ClosedDate>09/02/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:duplicate</Name>
        <IssueID>2036</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I'm upgrading my projects from NUnit engine 3.4 to 3.6, using framework 3.6 before and after.

When exploring an assembly for tests, I get the following exception:

``</Description>
  </Issue>
  <Issue>
    <IssueID>2035</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>2035</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>NullReferenceException inside failing Assert.That call</Title>
    <CreatedDate>06/02/2017</CreatedDate>
    <ClosedDate>27/02/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2035</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>2035</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>2035</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>
Result StackTrace:	
at NUnit.Framework.Assert.ReportFailure(String message)
   at NUnit.Framework.Assert.ReportFailure(ConstraintResult result, String message, Object[] args)
   at NUnit.Framework.Assert.That[TActual](TActual actual, IResolveConstraint expression, String message, Object[] args)
   at NUnit.Framework.Assert.That[TActual](TActual actual, IResolveConstraint expression)
   at My.Test.Case.Here() in C:\Path\To\File.cs:line 108
Result Message:	System.NullReferenceException : Object reference not set to an instance of an object.
`</Code>
    <Description>I have some integration tests written in NUnit that test the code I have that calls the NUnit Engine APIs . This is particularly to ensure that I am treating the NUnit XML correctly and handling certain edge cases

i.e.: Test Runner Unit Tests ---&gt; NUnit Engine ---&gt; Dummy Unit Tests

I am in the process of upgrading this from NUnit 3.4 to 3.6.

When using the 3.6 framework and binaries for all of the above listed components, a failing Test Runner unit test throws a NullReferenceException:

``

It appears that in the process of creating, calling into and disposing of engine, `TestExecutionContext.CurrentContext.CurrentResult` becomes null.</Description>
  </Issue>
  <Issue>
    <IssueID>2033</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>ChrisMaddock</FixedById>
        <IssueID>2033</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Nameof refactor</Title>
    <CreatedDate>04/02/2017</CreatedDate>
    <ClosedDate>16/12/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2033</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:refactor</Name>
        <IssueID>2033</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>In the [C# version conversation]( I asked if we'd be interested in doing a total `nameof` refactor now that the keyword is available. The core reason is well stated by @ChrisMaddock:

&gt;  I'd personally be a fan of doing it globally for nameof(), if nothing else. nameof adds compile time checking where there currently is none, which would be great of all the reflection code within the framework. It would be some nice extra security for future refactors.
&gt;
&gt; When we first moved to VS 2015, nameof was the only thing we 'bulk converted', and it caught a couple of bugs in rotten-code. I'm sure NUnit is better maintained, but I feel it could be justified as a 'code enhancement' rather than just a syntactic nicety.

Besides the security, I've also noticed it makes navigation to the related member *so much easier*. Whether it's a TestCaseSource or it's an NUnit test which references a method in a helper test fixture, a single F12 press jumps you right where to want to be. I guess CodeLens would also pick up on it and provide navigation in the opposite direction.

As noted, the refactor itself is not difficult, especially with ReSharper. It would involve a single click to take care of attributes such as `TestCaseSource`. However, we'd need to manually check all call sites of `TestAssert.IsRunnable` and Properties keys and similar methods. I volunteer because this is something I really want to see happen. Of course extra eyes on the same hunt couldn't hurt. Maybe I can twist the arm of @ChrisMaddock's inner perfectionist. :smile:</Description>
  </Issue>
  <Issue>
    <IssueID>2031</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>jnm2</FixedById>
        <IssueID>2031</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Limit Language level to C#6</Title>
    <CreatedDate>04/02/2017</CreatedDate>
    <ClosedDate>18/05/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2031</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>good first issue</Name>
        <IssueID>2031</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:build</Name>
        <IssueID>2031</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>2031</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>The framework and console currently use a maximum language level of C#6 - we want to maintain that to ensure the projects can still be built by the C#6 generation of IDEs.

To enforce this, it would be great if we could add the `&lt;LangVersion&gt;` attribute to all the csproj's. This would prevent the projects compiling with C#7 features, help new contributors discover the required language level, and ensure no C#7 code slips through code review.

This can be set in VS by going to:
    
    Project Properties =&gt; Build tab =&gt; Advanced button =&gt; Language Version

Making that change will add a new property to the csproj file - it may be easier to edit the rest of the csproj's by hand, once the required XML has been found!</Description>
  </Issue>
  <Issue>
    <IssueID>2027</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Socket Exception when running tests with --explore option (3.6)</Title>
    <CreatedDate>03/02/2017</CreatedDate>
    <ClosedDate>29/05/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:duplicate</Name>
        <IssueID>2027</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Hi,

I'm not sure whether an issue with NUnit or with my configuration, but when trying to run tests with the `--explore` option, it errors with the following output:

``

The command I executed was:
&gt; "nunit3-console.exe" "C:\...\some.dll" --noresult --noheader --where cat=='cat_name' --framework=net-4.0 --explore

Tests execute successfully when dropping `--explore`

Thanks</Description>
  </Issue>
  <Issue>
    <IssueID>2026</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>CollectionAssert.AreEqual and AreEquivalent failing on equal lists</Title>
    <CreatedDate>02/02/2017</CreatedDate>
    <ClosedDate>02/02/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>2026</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>As noted by their names the first test fails while the second passes.
``

I believe the failure occurs because the hash codes are different so the objects are not actually equal. However, this reduces the usefulness of these comparers. While I can create an IComparer object I don't feel that should be the expected requirement. Can the hash codes be ignored or at least add a switch or another function that ignores them? 

Also, I think the error messages probably need an update. Object equality tests fail with unhelpful error messages:

&gt; Test Name:	Fail
Test FullName:	Sapsan.Api.Tests.TeeSheet.CourseControllerTests.TestyTest
Test Source:	C:\Code\dearborn-station\Sapsan\Sapsan.Api.Tests\TeeSheet\CourseControllerTests.cs : line 116
Test Outcome:	Failed
Test Duration:	0:00:00.178
Result StackTrace:	at NUnit.Framework.CollectionAssert.AreEquivalent(IEnumerable expected, IEnumerable actual)
at Sapsan.Api.Tests.TeeSheet.CourseControllerTests.TestyTest() in C:\Code\dearborn-station\Sapsan\Sapsan.Api.Tests\TeeSheet\CourseControllerTests.cs:line 145
Result Message:	Expected: equivalent to &lt; &lt;Sapsan.Api.Tests.TeeSheet.CourseControllerTests+TestObject&gt;, &lt;Sapsan.Api.Tests.TeeSheet.CourseControllerTests+TestObject&gt; &gt;
  But was:  &lt; &lt;Sapsan.Api.Tests.TeeSheet.CourseControllerTests+TestObject&gt;, &lt;Sapsan.Api.Tests.TeeSheet.CourseControllerTests+TestObject&gt; &gt;

These tests were run in Visual Studio 2015 using NUnit 3.6.0.</Description>
  </Issue>
  <Issue>
    <IssueID>2025</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>2025</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>NullReferenceException using Is.EqualTo on two unequal strings</Title>
    <CreatedDate>02/02/2017</CreatedDate>
    <ClosedDate>28/02/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2025</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>2025</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I'm writing some tests and wanted to test the equality of two strings. I didn't realise until runtime that they would be unequal. I expected the Assert to fail but not with a null reference exception. 

Text comparison as been shortened for ease of reading but the result is the same.

   
           'string errorText = ScenarioContext.Current.Get&lt;FlightSearchPod&gt;().errorOnScreen;

            string requiredText = "You can only book one infant per adult online.";

            Assert.That(errorText, Does.Contain(requiredText));`

At runtime errorText = "Oops!\r\nYou can only book one infant per adult online.".

If I change requiredText to "Oops!\r\nYou can only book one infant per adult online." it works without an exception. 
This Exception is only thrown on v3.6.0, If I try the same Assert on earlier versions it works fine so I'm trying to determine if it's a feature or an issue. 

I can get around the issue by using Does.Contain but have been asked by my organisation to see if we can identify the cause of this unexpected exception.

Let me know if I need to provide any more information, I'm fairly new to automation testing. </Description>
  </Issue>
  <Issue>
    <IssueID>2022</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Make Is partial</Title>
    <CreatedDate>01/02/2017</CreatedDate>
    <ClosedDate>01/02/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:wontfix</Name>
        <IssueID>2022</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>It would be useful to be able to append more constraints to the `Is` and `Has` classes.

In order to do this it would have to be made `partial`.

* Is this something that can be done?
* Is this something that I could do and submit a pull request?</Description>
  </Issue>
  <Issue>
    <IssueID>2021</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Alternate Timeout API for dynamic timeout intervals</Title>
    <CreatedDate>31/01/2017</CreatedDate>
    <ClosedDate>12/12/2017</ClosedDate>
    <IssueLabels />
    <Code>c#
var timeoutMs = Environment.GetEnvironmentVariable("TF_BUILD") != null ? 7000 : 3000;
Assert.That(() =&gt;
{
    // ...
}, Does.Not.Timeout(timeoutMs));
`</Code>
    <Description>There is only one way to specify a timeout as far as I can tell: [`TimeoutAttribute`]( The fact that it's an attribute means that the timeout time must be a compile-time constant.

However, I am searching for a way to override that timeout if a given environment variable is present. If `TF_BUILD` is present, I want to use `7000`. Otherwise, I want to use `3000`.

If you want to stick with attributes, a conditional timeout attribute could be added such as `TimeoutIfEnv("TF_BUILD", 7000)`. However a more flexible API might be an assertion, taking a page from `Throws`:

``

The non-aborting version could be `Has.MaxTime`.
There could be a `TimeSpan` overload as well.

What are your opinions?</Description>
  </Issue>
  <Issue>
    <IssueID>2020</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Better message when timeout fails</Title>
    <CreatedDate>31/01/2017</CreatedDate>
    <ClosedDate>14/04/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2020</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>2020</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Currently when a timeout fails NUnit reports, "Test cancelled by user." While in a certain sense it's not wrong, it's confusing. It led me to believe that I was clicking the test abort icon in ReSharper. (I've been having tooling issues unrelated to NUnit.) In an integration test, it makes it sound as though the build is being canceled.

It's also missing the most relevant information about the test failure: how long it was expected to take.

Ideally it would say "Timeout of 3000 ms exceeded" or something similar. This way, you instantly know what caused the cancellation (the timeout attribute) without guessing, and you know how long it took. This is in the same spirit as every assertion message.</Description>
  </Issue>
  <Issue>
    <IssueID>2019</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>2019</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>TestFixtureSourceAttribute doesn't work with items implementing ITestFixtureData</Title>
    <CreatedDate>31/01/2017</CreatedDate>
    <ClosedDate>17/03/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2019</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>good first issue</Name>
        <IssueID>2019</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:docs</Name>
        <IssueID>2019</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>2019</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Consider the following test:

``

According to [documentation]( for `TestFixtureSourceAttribute` this should be supported scenario.

I have used NUnit and NUnit.Console 3.6.0.</Description>
  </Issue>
  <Issue>
    <IssueID>2017</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>gcichosz</FixedById>
        <IssueID>2017</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Two NUnit project's tests fail on systems with comma decimal mark settings</Title>
    <CreatedDate>31/01/2017</CreatedDate>
    <ClosedDate>31/01/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2017</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>2017</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>2017</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>The following tests fail on systems with comma decimal mark settings:
- NUnit.Framework.Internal.Results.TestResultGeneralTests.SuiteResultXml_Duration
- NUnit.Framework.Internal.Results.TestResultGeneralTests.TestResultXml_Duration

Steps to reproduce:
1. Change system region, or language settings to one with comma  decimal mark ([Countries using Arabic numerals with decimal comma](
2. Run the build script with `-Target Test` option
3. See aforementioned tests fail for every framework</Description>
  </Issue>
  <Issue>
    <IssueID>2015</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Applying an ICommandWrapper to every test in a fixture</Title>
    <CreatedDate>30/01/2017</CreatedDate>
    <ClosedDate>30/01/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2015</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>2015</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I wrote a custom `ICommandWrapper` (`IWrapSetUpTearDown`) which derives from `PropertyAttribute`.
This attribute is very similar to the built-in `ApartmentAttribute`. I would like to be able to specify it per fixture as well as per test. If applied per-fixture, it would have the same effect as applying it to every test method in the fixture, just like `ApartmentAttribute`.

Am I overlooking something, or is this a feature request?</Description>
  </Issue>
  <Issue>
    <IssueID>2014</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>OneTimeSetUp in different assembly?</Title>
    <CreatedDate>30/01/2017</CreatedDate>
    <ClosedDate>30/01/2017</ClosedDate>
    <IssueLabels />
    <Description>@markikollasch and I are attempting to run tests in multiple different assemblies that will all require very similar setup. To avoid having to write that setup in every assembly, we've created an additional assembly with a single abstract class containing the `[OneTimeSetUp]` and `[OneTimeTearDown]` behavior we need. In each of the test assemblies we have created a concrete subclass with the `[SetUpFixture]` attribute, in such a way that the setup fixture is in the same namespace as the corresponding tests.

However, the one-time setup and one-time teardown methods aren't running in this configuration, and we're not sure why. Is this behavior intended, and is there a recommended way to run one-time setup methods from different assemblies?

</Description>
  </Issue>
  <Issue>
    <IssueID>2013</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Assert.That(length, Is.PowerOfTwo)</Title>
    <CreatedDate>30/01/2017</CreatedDate>
    <ClosedDate>03/04/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:wontfix</Name>
        <IssueID>2013</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>In some cases it is important that an input or an output has a power of 2.
Not many developers know how to check this easily.
I wish that integrated and readable in NUnit, something like
`Assert.That(length, Is.PowerOfTwo)`
Needed for all integer types, also int, long and decimal because Length/Count of CollectionTypes is int.

I use the following easy method (for unsigned only, signed needs cast)
`private static bool IsPowerOfTwo(uint x)
{
    return x &gt; 0 &amp;&amp; (x &amp; (x - 1)) == 0;
}`
</Description>
  </Issue>
  <Issue>
    <IssueID>2012</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Intermittent errors while running tests after updating to 3.6 </Title>
    <CreatedDate>30/01/2017</CreatedDate>
    <ClosedDate>30/01/2017</ClosedDate>
    <IssueLabels />
    <Description>Every now and then when we run our tests using the console runner after updating to 3.6 it fails with an error for some of the test assemblies. Tests for assemblies with this error are not discovered nor executed. It is not always the same assemblies that fails, sometimes it is one and sometimes there are more than one that fails. 

We execute the tests with: nunit3-console.exe [path to assemblies] -work=[absolute path to a directory] --result=TestResult.xml;format=nunit2

So far we've observed these errors with similar callstacks:
&gt; Index was outside the bounds of the array.
&gt;    at System.Collections.Generic.Dictionary`2.Insert(TKey key, TValue value, Boolean add)
&gt;    at NUnit.Engine.Services.TestAgency.LaunchAgentProcess(TestPackage package)
&gt;    at NUnit.Engine.Services.TestAgency.CreateRemoteAgent(TestPackage package, Int32 waitTime)
&gt;    at NUnit.Engine.Runners.ProcessRunner.CreateAgentAndRunner()
&gt;    at NUnit.Engine.Runners.ProcessRunner.RunTests(ITestEventListener listener, TestFilter filter)

&gt; Object reference not set to an instance of an object.
&gt;    at System.Collections.Generic.Dictionary`2.Insert(TKey key, TValue value, Boolean add)
&gt;    at NUnit.Engine.Services.TestAgency.LaunchAgentProcess(TestPackage package)
&gt;    at NUnit.Engine.Services.TestAgency.CreateRemoteAgent(TestPackage package, Int32 waitTime)
&gt;    at NUnit.Engine.Runners.ProcessRunner.CreateAgentAndRunner()
&gt;    at NUnit.Engine.Runners.ProcessRunner.RunTests(ITestEventListener listener, TestFilter filter)</Description>
  </Issue>
  <Issue>
    <IssueID>2008</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>TestCase and Values do not correctly convert DateTime string in current culture</Title>
    <CreatedDate>25/01/2017</CreatedDate>
    <ClosedDate>29/06/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:wontfix</Name>
        <IssueID>2008</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>c#
[TestCase("12.10.1942")]
[SetCulture("de-DE")]
public void CanConvertStringToDateTimeInCurrentCulture(DateTime dt)
{
     Assert.AreEqual(new DateTime(1942, 10, 12), dt);
}

[Test]
[SetCulture("de-DE")]
public void CanConvertStringToDateTimeInCurrentCulture([Values("12.10.1942")] DateTime dt)
{
     Assert.AreEqual(new DateTime(1942, 10, 12), dt);
}
`</Code>
    <Description>Converting `string` into `DateTime` the `TestCase`, `Values` attributes use invariant culture `System.Globalization.CultureInfo.InvariantCulture`. I expect that when I change the `TestExecutionContext.CurrentCulture` using `SetCultureAttribute` for test / test fixture, the converter should use the new culture info. What do you think about?

The following tests fail

``</Description>
  </Issue>
  <Issue>
    <IssueID>2007</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>3.6 Multiple assertion backwards compatibility</Title>
    <CreatedDate>24/01/2017</CreatedDate>
    <ClosedDate>11/04/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2007</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>2007</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>We use nunit along with selenium to check that elements are present on a web page etc.  Our framework uses exception capturing loops for certain cases such as interacting with browsers which isn't always the most reliable thing.  This allows a bit of time for elements to appear which they are created by Javascript however if things don't appear after a short time then the nunit assertion exception is not captured and bubbles up to the runner and is reported on.

We have found since upgrading to 3.6 that the failed assertions are getting recorded due to the new multiple assertion feature even though the same assertion later passes. I think exceptions should not be recorded unless you are inside a multiple assertion block, would you agree?

A potential fix is to move this earlier in the ReportFailure method:
if (TestExecutionContext.CurrentContext.MultipleAssertLevel == 0)
                throw new AssertionException(writer.ToString());

in src/NUnitFramework/framework/Assert.cs
</Description>
  </Issue>
  <Issue>
    <IssueID>2006</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>3.6 Console runner hanging on unit tests</Title>
    <CreatedDate>24/01/2017</CreatedDate>
    <ClosedDate>14/02/2017</ClosedDate>
    <IssueLabels />
    <Description>I followed these steps:
1. Uninstalled NUnit 3.5
2. Installed  NUnit Console 3.6
3. Downloaded NUnit 3.6 zip and copied 4.5 directory to "C:\Program Files (x86)\NUnit.org\"
4. Executed the following command (unchanged from last release) in both Jenkins and from an administrator command prompt:

     `"C:\Program Files (x86)\NUnit.org\nunit-console\nunit3-console.exe" Saucery\NUnit\Version3\UnitTests\bin\Release\UnitTests.dll --result:nunit-unittests-testsuite.xml;format=nunit2`

It displays:

    NUnit Console Runner 3.6.0 
    Copyright (C) 2017 Charlie Poole

    Runtime Environment
       OS Version: Microsoft Windows NT 10.0.14393.0
      CLR Version: 4.0.30319.42000

    Test Files
        Saucery\NUnit\Version3\UnitTests\bin\Release\UnitTests.dll

then  just hangs .

This command was working with NUnit 3.5 console runner and would take seconds to complete.

Should I have installed NUnit 3.6 Framework?  Is there an installer for the framework anymore?  What am I missing?</Description>
  </Issue>
  <Issue>
    <IssueID>2005</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Exclude empty failure messages from results xml</Title>
    <CreatedDate>23/01/2017</CreatedDate>
    <ClosedDate>26/01/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2005</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>2005</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>2005</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>From the discussion on #1955 - if the message property for a failure is an empty string, then the message element should not be written to the xml.

To reproduce:
    
    Assert.Fail("")

will currently produce:

    &lt;message&gt;&lt;![CDATA[]]&gt;&lt;/message&gt;

@cristobalito is going to take a look at this one.</Description>
  </Issue>
  <Issue>
    <IssueID>2004</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Has.One as synonym for Has.Exactly(1).Items</Title>
    <CreatedDate>22/01/2017</CreatedDate>
    <ClosedDate>29/06/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2004</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>good first issue</Name>
        <IssueID>2004</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>2004</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:low</Name>
        <IssueID>2004</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>As discussed in the context of issue #1790, we would like to implement this so that the following work:

Short Form                | Long Form
----------------------|----------------------------------
Has.One                    | Has.Exactly(1).Items
Has.One.EqualTo("X") | Has.Exactly(1).Items.EqualTo("X")

Similarly, we should add `One` wherever we now allow `Exactly`, e.g.: in `ConstraintExpression`.</Description>
  </Issue>
  <Issue>
    <IssueID>2003</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>2003</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Better user info about ParallelizableAttribute and ParallelScope</Title>
    <CreatedDate>22/01/2017</CreatedDate>
    <ClosedDate>04/02/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2003</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>2003</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>2003</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>This comes up as I work on issue #164 and I'll implement it in conjunction with that is.sue. However, I think it needs to have separate review, which is why I'm creating this issue.

`ParallelizableAttribute` takes an optional argument of Type `ParallelScope`. The values of `ParallelScope` are a mix of things. Some apply to the item on which the attribute appears and others to descendants. In addition, `ParallelScope.None` is used both when specified by the user and as a default. This turns out to lose info for us, since there are three, rather than two, actions the dispatcher may take in running a test:
 * Run directly on the same thread as parent
 * Enqueue on a parallel queue
 * Enqueue on a non-parallel queue

I'm proposing a number of changes to make parallel test cases work and also to clarify things for users:

1. I have already defined `ParallelScope.Default` which indicates that no attribute was used. This turned out to be necessary to effectively implement parallel test cases.

2. For convenience internally I have re-defined the various scopes in two ranges, separating those flags that affect the item on which they appear from those that affect descendants. I use two masks to pick out the flags that are needed in a particular instance.

[Remaining items have to do with how this appears to users]

3. I'd like to deprecate `ParallelScope.None` in favor of `ParallelScope.NonParallel`. The former name is confusing enough that it was confusing me in working #164. Its implementation has always been "run test on non-parallel queue" but it sounds as if it means "not specified" or "use default". I'm open to other names. I considered "Never" as an option.

4. For consistency, I'd like to define `ParallelScope.Parallel` as a synonym for `ParallelScope.Self`. I wouldn't deprecate the latter, however, because combos like `ParallelScope.Self+ParallelScope.Children` read quite well.

5. To make it even easier for users. It may be useful to define `NonParallelizableAttribute` with no arguments. Just as `[Parallelizable]` defaults to `[Parallelizable(ParallelScope.Self)`, this new attribute would mean the same as `[Parallelizable(ParallelScope.NonParallel)`

6. Some values of `ParallelScope` make no sense in certain places and are currently ignored silently. For example, `Parallelizable(ParallelScope.Fixtures)` has no effect if placed on a test case. Rather than silently ignoring the attribute, I propose that we mark the test as invalid so that the user knows it won't do whatever is expected and removes it. Implementation will require looking at each scope value and deciding whether to allow it on an Assembly, a class or a method. It seems to me that getting an early error is better for the user than having their intent (which we don't know of course) ignored silently.

7. I propose adding `ParallelScope.Cases` to the set of scopes that impact descendants. Used at the assembly level without combining with other scopes, it would cause test fixtures to run sequentially but all the cases within them to run in parallel. I don't think this will get a lot of use but it's consistent with the presense of `ParallelScope.Fixtures`. I would redefine `Children` as `Fixtures+Cases` if we do this.

Please comment! For implementation details, you'll be able to review the PR of course.</Description>
  </Issue>
  <Issue>
    <IssueID>2001</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>2001</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>NullReferenceException when running an async test for .NET Core</Title>
    <CreatedDate>22/01/2017</CreatedDate>
    <ClosedDate>22/01/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:duplicate</Name>
        <IssueID>2001</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>2001</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>2001</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>C#
[Test]
public async Task Test()
{
    await Task.Run(() =&gt; { });
    Assert.Fail("This error message should be shown");
}

Running the test with `dotnet test` command produces the following output:

Error : NUnitErrorInvestigation.TestClass.Test
System.NullReferenceException : Object reference not set to an instance of an object.
   at NUnit.Framework.Assert.ReportFailure(String message)
   at NUnitErrorInvestigation.TestClass.&lt;Test&gt;d__0.MoveNext() in C:\Temp\NUnitErrorInvestigation\src\NUnitErrorInvestigation\TestClass.cs:line 13
--- End of stack trace from previous location where exception was thrown ---
   at System.Runtime.ExceptionServices.ExceptionDispatchInfo.Throw()
   at NUnit.Framework.Internal.AsyncInvocationRegion.AsyncTaskInvocationRegion.WaitForPendingOperationsToComplete(Object invocationResult)
   at NUnit.Framework.Internal.Commands.TestMethodCommand.RunAsyncTestMethod(TestExecutionContext context)

The project.json file: 

{
  "version": "1.0.0-*",
  "testRunner": "nunit",
  "dependencies": {
    "dotnet-test-nunit": "3.4.0-beta-3",
    "Microsoft.NETCore.App": {
      "version": "1.1.0",
      "type": "platform"
    },
    "NUnit": "3.6.0"
  },
  "frameworks": {
    "netcoreapp1.0": {
      "imports": "portable-net45+win8"
    }
  }
}
`</Code>
    <Description>After upgrading my .NET Core project from NUnit 3.5 to NUnit 3.6, I noticed that a failing `Assert.That` in an async test produces a `NullReferenceException` in the test results instead of a normal assert message. 

The minimal piece of code that reproduces the issue:
``
Replacing `"NUnit": "3.6.0"` with `"NUnit": "3.5.0"` in the project.json makes the issue disappear.

The Visual Studio 2015 solution with this failing test: [NUnitErrorInvestigation.zip](

I couldn't reproduce the issue if the test was put into a normal "Class Library" project for the .NET Framework 4.6.1. Also, the issue disappears if the `await` is replaced with `Task.Wait` or if `Assert.Fail` is put before the line with `await`. </Description>
  </Issue>
  <Issue>
    <IssueID>1999</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>JustinRChou</FixedById>
        <IssueID>1999</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Author Tests assume ICustomAttributeProvider.GetCustomAttributes return order is defined</Title>
    <CreatedDate>20/01/2017</CreatedDate>
    <ClosedDate>21/01/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1999</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>1999</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:low</Name>
        <IssueID>1999</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>After some research, it appears that the order of the attributes returned by ICustomAttributeProvider.GetCustomAttributes is undefined (random).

However, it seems like the assumption is made in Nunit that custom attributes are always returned in the order they appear in the source code.

For example, the AuthorAttribute allows multiple occurrences of the attribute.  The tests for multiple AuthorAttribute assumes a specific order for the values in the resulting Author element in the test's Properties.  That test can fail because the order is actually not defined.</Description>
  </Issue>
  <Issue>
    <IssueID>1997</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>gcichosz</FixedById>
        <IssueID>1997</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Remove unused --verbose and --full command line options</Title>
    <CreatedDate>20/01/2017</CreatedDate>
    <ClosedDate>02/02/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1997</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>good first issue</Name>
        <IssueID>1997</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>1997</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>1997</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>@thomaslevesque commented on [Fri Oct 14 2016](What is the `--verbose` flag supposed to do? I can't see any difference between running nunit3-console.exe with or without this flag.(btw, is there a way to print to the console which test is currently executing? that's what I was trying to do with `--verbose`)---@thomaslevesque commented on [Fri Oct 14 2016](I just looked at the code: apparently the `CommandLineOptions.Verbose` property is never used (except to define it in `ConfigureOptions`). The same is true of the `Full` property.---@ChrisMaddock commented on [Fri Oct 14 2016](I think you're looking for `--labels`? I'll leave someone else to comment on`--verbose`---@thomaslevesque commented on [Fri Oct 14 2016](Thanks @ChrisMaddock, this is what I was looking for!---@CharliePoole commented on [Fri Oct 14 2016](Once upon a time, `--verbose` did something. When I removed that code, I thought I would be coming back to add some different verbose output. We'll either kill the option or use it.The `--full` option was an experimental report of all tests run. We'll either remove or use this one too.---@ChrisMaddock commented on [Fri Jan 20 2017](This is potentially easyfix once a decision is made. 

Can I suggest we remove both unused options, with the view that they could always be re-added, if something is implemented at a later date? @nunit/engine-team - thoughts?---@rprouse commented on [Fri Jan 20 2017](I say remove for now---@CharliePoole commented on [Fri Jan 20 2017](I agree</Description>
  </Issue>
  <Issue>
    <IssueID>1996</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>jnm2</FixedById>
        <IssueID>1996</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Timeout does not work if native code is running at the time</Title>
    <CreatedDate>20/01/2017</CreatedDate>
    <ClosedDate>13/06/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1996</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>design</Name>
        <IssueID>1996</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>1996</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>If you have native code running, Timeout has no effect. I assume this is because it relies on Thread.Abort.

Is there anything that could be done to improve this? A native way to nuke it if Thread.Abort does nothing?</Description>
  </Issue>
  <Issue>
    <IssueID>1994</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>1994</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>NUnitLite runner crashing when --trace is specified</Title>
    <CreatedDate>19/01/2017</CreatedDate>
    <ClosedDate>20/01/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1994</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>1994</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>1994</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Using the nunitlite.runner with arguments `nunit.framework.tests.dll --trace:Info` causes null reference exception in `TextRunner.GetLogFileName()`</Description>
  </Issue>
  <Issue>
    <IssueID>1993</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Question: Is this possible to attach screenshot that will be visible in TFS Build Report</Title>
    <CreatedDate>19/01/2017</CreatedDate>
    <ClosedDate>19/01/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:duplicate</Name>
        <IssueID>1993</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Hi All,
I run NUnit tests with TFS Build.
In the results when we click on specific test we see Attachment:
![image](
Is this possible to attach screenshot using Nunit in the TFS Build Report?

Best Regards,
Stanislava</Description>
  </Issue>
  <Issue>
    <IssueID>1992</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>1992</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>NullReferenceException in Assert.ReportFailure method</Title>
    <CreatedDate>19/01/2017</CreatedDate>
    <ClosedDate>19/01/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>1992</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I use NUnit 3.6.0. And I noticed that messages of all failed tests are "System.NullReferenceException: Object reference not set to an instance of an object" every time.

I wrote simple test:
``
Here are test fails using NUnit 3.5 and NUnit 3.6:
![nullrefexception](

 



</Description>
  </Issue>
  <Issue>
    <IssueID>1991</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>TestContext.CurrentContext.Test.Properties.Get("Category") only returns first category assigned to test</Title>
    <CreatedDate>18/01/2017</CreatedDate>
    <ClosedDate>18/01/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>1991</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>First off I'm not sure if this is expected behavior so if it is please disregard.

Nunit Version 3.4.1 (from NuGet)

I'm running a test with the following attributes

`[Test, Parallelizable, Retry(3), Category("Catalog"), Category("Production")]`

and later in the test there is a safety check to make sure that tests running in the production environment have the Production Category assigned to it. This uses:

`var category = (string) TestContext.CurrentContext.Test.Properties.Get("Category");`

Calling CurrentContext to get the Category property as shown above only returns the first category in the test decorators (in this case "Catalog"), which makes it hard if you are doing any sort of category validation within the test in a setup block like i am.
</Description>
  </Issue>
  <Issue>
    <IssueID>1990</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>tom-dudley</FixedById>
        <IssueID>1990</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Add namespace filter</Title>
    <CreatedDate>18/01/2017</CreatedDate>
    <ClosedDate>07/05/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1990</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>1990</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>1990</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>As a pre-requisite to nunit/nunit-console#162, implement a namespace filter in the framework.

Modify the TSL implementation in nunitlite to handle namespace as a keyword.</Description>
  </Issue>
  <Issue>
    <IssueID>1989</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Retarget PCL build to .NET Standard</Title>
    <CreatedDate>17/01/2017</CreatedDate>
    <ClosedDate>05/05/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:duplicate</Name>
        <IssueID>1989</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>1989</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>1989</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>@rprouse mentioned somewhere during the 3.6 release that we may want to retarget the PCL build as a .NET Standard build. .NET standard is essentially the replacement for PCLs. I did a little experimentation - Visual Studio automates the retargetting to .NET Standard 1.0 quite happily, with no additional changes needed.

I wonder if we should consider targeting a higher .NET standard version, which would allow us to renable more functionality - I think the lowest platform we have runners for is UWP/netstandard 1.4? Of course, people could be using the PCL on other platforms via NUnitLite. I haven't investigated how much extra we would gain, by increasing a standard version or two. 

Thoughts? Rob - I'm very much stealing your idea and running with it here - you're welcome to have it back if you had other plans!

|.NET Platform              | 1.0| 1.1| 1.2| 1.3| 1.4| 1.5| 1.6| 2.0|
|:--------------------------|-----:|-----:|-----:|-----:|-----:|-----:|-----:|-----:|
|.NET Core                  |&amp;rarr;|&amp;rarr;|&amp;rarr;|&amp;rarr;|&amp;rarr;|&amp;rarr;|   1.0| vNext|
|.NET Framework             |&amp;rarr;|  4.5 | 4.5.1|   4.6|&amp;rarr;|&amp;rarr;|&amp;rarr;| 4.6.1|
|Mono                       |&amp;rarr;|&amp;rarr;|&amp;rarr;|&amp;rarr;|&amp;rarr;|&amp;rarr;|   4.6| vNext|
|Xamarin.iOS                |&amp;rarr;|&amp;rarr;|&amp;rarr;|&amp;rarr;|&amp;rarr;|&amp;rarr;|  10.0| vNext|
|Xamarin.Android            |&amp;rarr;|&amp;rarr;|&amp;rarr;|&amp;rarr;|&amp;rarr;|&amp;rarr;|   7.0| vNext|
|Universal Windows Platform |&amp;rarr;|&amp;rarr;|&amp;rarr;|&amp;rarr;|  10.0|&amp;rarr;|&amp;rarr;| vNext|
|Windows                    |&amp;rarr;|   8.0|   8.1|      |      |      |      |      |
|Windows Phone              |&amp;rarr;|&amp;rarr;|   8.1|      |      |      |      |      |
|Windows Phone Silverlight  |   8.0|      |      |      |      |      |      |      |</Description>
  </Issue>
  <Issue>
    <IssueID>1988</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Exception thrown by other thread</Title>
    <CreatedDate>17/01/2017</CreatedDate>
    <ClosedDate>18/05/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>1988</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>During upgrade to NUnit 3.5.0 (from 2.x) I have found out some tests don't fail, but throw exceptions on console (Console runner execution) while the test itself passes. After investigation I figured out why.

Test method creates an object, which inside creates thread and runs WaitHandle.WaitAny(waiters) in that thread... the issue here is one waiter is null and thanks to that, this throws an exception. But, because it is running in different thread and following asserts don't check on anything related to this thread, test passes.

Putting aside this proves the code is obviously badly designed, are there any possibilities to be able to catch such exceptions from the NUnit side? I am quite doubtful it's possible at all, but maybe you know a way?</Description>
  </Issue>
  <Issue>
    <IssueID>1986</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>1986</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>NUnitLite ignores --workers option</Title>
    <CreatedDate>17/01/2017</CreatedDate>
    <ClosedDate>17/01/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>1986</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>1986</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I came across this working on #164. Changing the number of test workers with the command-line `--workers` option didn't have any effect on the duration of the test. On investigation, it's clear that although the option is accepted there is no code to transmit it to the framework as a setting.</Description>
  </Issue>
  <Issue>
    <IssueID>1985</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Warning Message Suppressed on Test Failure</Title>
    <CreatedDate>16/01/2017</CreatedDate>
    <ClosedDate>16/01/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>1985</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I'm using Warn.If to validate a few values in a grid. The execution continues as expected when the condition fails, which is great. However, the warning message is suppressed if any other assert fails in the test later down the line. I can see the warning message and the test in Inconclusive state when there are no further failures in the test. This is exactly opposite of what is written up in the documentation i.e.  
"If the test subsequently fails, the warnings will be displayed along with the failure message or - in the case of Assert.Multiple - messages."

Here's what I see:
**On an Assertion Failure:** Only the message associated with the current assertion failure is reported, the test status is Failed and the Warning Message is suppressed. (First Picture)
**On Assertion Pass:** Warning Message is displayed and the Test Status becomes inconclusive.(Second Picture)

Please confirm if this is the expected behavior with Warnings? Attached screenshots for both the cases described above.
![on assertion failure](
![on assertion pass](



</Description>
  </Issue>
  <Issue>
    <IssueID>1982</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>$RANDOM_SEED$ is appearing in non-test project build output</Title>
    <CreatedDate>15/01/2017</CreatedDate>
    <ClosedDate>15/01/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:duplicate</Name>
        <IssueID>1982</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>This is messing up the installer generated by CI. Now I _can_ update my build script to find and exclude those files, but they should not be appearing at all because there are no test assemblies in those folders.</Description>
  </Issue>
  <Issue>
    <IssueID>1981</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>NUnit 3.6.0 don't find tests on .Net Standard 1.6 projects</Title>
    <CreatedDate>14/01/2017</CreatedDate>
    <ClosedDate>14/01/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>1981</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>
------ Discover test started ------
NUnit Adapter 3.6.0.0: Test discovery starting
Error: Unable to get runner for this assembly. Check installation, including any extensions.
FileNotFoundException: Could not load file or assembly 'nunit.framework' or one of its dependencies. The system cannot find the file specified.
Dependent Assembly nunit.framework of C:\Users\gutem\documents\visual studio 2017\Projects\ClassLibrary1\ClassLibrary1\bin\Debug\netstandard1.6\ClassLibrary1.dll not found. Can be ignored if not a NUnit project.
NUnit Adapter 3.6.0.0: Test discovery complete
========== Discover test finished: 0 found (0:00:00.655) ==========


This is the sample .csproj:


&lt;Project Sdk="Microsoft.NET.Sdk" ToolsVersion="15.0"&gt;
  &lt;PropertyGroup&gt;
    &lt;TargetFramework&gt;netstandard1.6&lt;/TargetFramework&gt;
  &lt;/PropertyGroup&gt;
  &lt;ItemGroup&gt;
    &lt;Compile Include="**\*.cs" /&gt;
    &lt;EmbeddedResource Include="**\*.resx" /&gt;
  &lt;/ItemGroup&gt;
  &lt;ItemGroup&gt;
    &lt;PackageReference Include="Microsoft.NET.Test.Sdk" Version="15.0.0-preview-20170113-02" /&gt;
    &lt;PackageReference Include="NETStandard.Library" Version="1.6.1" /&gt;
    &lt;PackageReference Include="NUnit" Version="3.6.0" /&gt;
    &lt;PackageReference Include="NUnit3TestAdapter" Version="3.6.0" /&gt;
  &lt;/ItemGroup&gt;
&lt;/Project&gt;

With this sample test:


[TestFixture]
    public class Class1
    {
        string teststring = "";

        [SetUp]
        public void SetUp()
        {
            teststring = "AAA";
        }

        [Test]
        public void TestDemo()
        {
            Assert.True(teststring.Equals("AAA"));
        }
    }
`</Code>
    <Description>Visual Studio is throwing this:

``

Do we need to do anything else?

Thank you.
</Description>
  </Issue>
  <Issue>
    <IssueID>1975</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>1975</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>TestFixtureSource doesn't work with a class that has no namespace</Title>
    <CreatedDate>11/01/2017</CreatedDate>
    <ClosedDate>19/01/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1975</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>1975</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>1975</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>
[TestFixtureSource("FixtureArgs")]
public class TestFixtureAtributeTest {
    
    public TestFixtureAtributeTest(string word, int num) { }

    [Test]
    public void TestSomething()
    {
        Assert.That(true, Is.True);
    }

    static object [] FixtureArgs = {
        new object[] { "Question", 1 },
        new object[] { "Answer", 42 }
    };
}

with following error:

&gt; An exception was thrown while loading the test.
&gt; System.ArgumentNullException: pathName
&gt; Parameter name: Argument pathName must not be null
&gt;   at NUnit.Framework.Guard.ArgumentNotNull (System.Object value, System.String name) [0x00000] in &lt;filename unknown&gt;:0 
&gt;   at NUnit.Framework.Guard.ArgumentNotNullOrEmpty (System.String value, System.String name) [0x00000] in &lt;filename unknown&gt;:0 
&gt;   at NUnit.Framework.Internal.Test..ctor (System.String pathName, System.String name) [0x00000] in &lt;filename unknown&gt;:0 
&gt;   at NUnit.Framework.Internal.TestSuite..ctor (System.String parentSuiteName, System.String name) [0x00000] in &lt;filename unknown&gt;:0 
&gt;   at NUnit.Framework.Internal.ParameterizedFixtureSuite..ctor (ITypeInfo typeInfo) [0x00000] in &lt;filename unknown&gt;:0 
&gt;   at NUnit.Framework.Internal.Builders.DefaultSuiteBuilder.BuildMultipleFixtures (ITypeInfo typeInfo, IEnumerable`1 fixtures) [0x00000] in &lt;filename unknown&gt;:0 
&gt;   at NUnit.Framework.Internal.Builders.DefaultSuiteBuilder.BuildFrom (ITypeInfo typeInfo) [0x00000] in &lt;filename unknown&gt;:0

I managed to fix the issue but discovering a different one where TestFixtureSource with only 1 value will fail to generated the reult. I didn't manage to compile the head cahngeset from master or I'm pasting the patch here (based on 3.5):


diff --git a/src/NUnitFramework/framework/Internal/Tests/Test.cs b/src/NUnitFramework/framework/Internal/Tests/Test.cs
index 044637e..1caccc9 100644
--- a/src/NUnitFramework/framework/Internal/Tests/Test.cs
+++ b/src/NUnitFramework/framework/Internal/Tests/Test.cs
@@ -84,11 +84,12 @@ protected Test( string name )
         /// &lt;param name="name"&gt;The name of the test&lt;/param&gt;
         protected Test( string pathName, string name ) 
         {
-            Guard.ArgumentNotNullOrEmpty(pathName, "pathName");
-
             Initialize(name);
 
-            FullName = pathName + "." + name;
+            if (!string.IsNullOrEmpty(pathName))
+                FullName = pathName + "." + name;
+            else
+                FullName = name;
         }
 
         /// &lt;summary&gt;
diff --git a/src/NUnitFramework/testdata/SetUpFixtureData.cs b/src/NUnitFramework/testdata/SetUpFixtureData.cs
index 09c6a42..03cde6f 100644
--- a/src/NUnitFramework/testdata/SetUpFixtureData.cs
+++ b/src/NUnitFramework/testdata/SetUpFixtureData.cs
@@ -600,6 +600,40 @@ public void DoNamespaceTearDown()
     }
 }
 
+[TestFixtureSource("MyData")]
+public class NoNamespaceTestFixtureSourceWithTwoValues
+{
+    public NoNamespaceTestFixtureSourceWithTwoValues(int i)
+    {
+
+    }
+
+    [Test]
+    public void Test()
+    {
+        NUnit.TestUtilities.SimpleEventRecorder.RegisterEvent("NoNamespaceTestFixtureSourceWithTwoValues");
+    }
+
+    static object [] MyData = { 1, 2 };
+}
+
+[TestFixtureSource("MyData")]
+public class NoNamespaceTestFixtureSourceWithSingleValue
+{
+    public NoNamespaceTestFixtureSourceWithSingleValue(int i)
+    {
+
+    }
+
+    [Test]
+    public void Test()
+    {
+        NUnit.TestUtilities.SimpleEventRecorder.RegisterEvent("NoNamespaceTestFixtureSourceWithSingleValue");
+    }
+
+    static object [] MyData = { 1 };
+}
+
 [TestFixture]
 public class SomeFixture
 {
diff --git a/src/NUnitFramework/tests/Internal/SetUpFixtureTests.cs b/src/NUnitFramework/tests/Internal/SetUpFixtureTests.cs
index 4cbcf6d..faa5879 100644
--- a/src/NUnitFramework/tests/Internal/SetUpFixtureTests.cs
+++ b/src/NUnitFramework/tests/Internal/SetUpFixtureTests.cs
@@ -251,6 +251,28 @@ public void AssemblySetupFixtureWrapsExecutionOfTest()
                                                      "Assembly.OneTimeTearDown");
         }
         #endregion NoNamespaceSetupFixture
+
+        #region NoNamespaceTestFixtureSource
+        [NUnit.Framework.Test]
+        public void NoNamespaceTestFixtureSourceWithTwoValuesTest()
+        {
+            ITestResult result = runTests(null, new Filters.FullNameFilter("NoNamespaceTestFixtureSourceWithTwoValues"));
+            Assert.AreEqual(2, result.PassCount);
+            Assert.That(result.ResultState.Status, Is.EqualTo(TestStatus.Passed));
+            TestUtilities.SimpleEventRecorder.Verify("Assembly.OneTimeSetUp",
+                                                     "NoNamespaceTestFixtureSourceWithTwoValues");
+        }
+
+        [NUnit.Framework.Test]
+        public void NoNamespaceTestFixtureSourceWithSingleValueTest()
+        {
+            ITestResult result = runTests(null, new Filters.FullNameFilter("NoNamespaceTestFixtureSourceWithSingleValue"));
+            Assert.AreEqual(1, result.PassCount);
+            Assert.That(result.ResultState.Status, Is.EqualTo(TestStatus.Passed));
+            TestUtilities.SimpleEventRecorder.Verify("Assembly.OneTimeSetUp",
+                                                     "NoNamespaceTestFixtureSourceWithSingleValue");
+        }
+        #endregion NoNamespaceTestFixtureSource
     }
 }
 #endif
`</Code>
    <Description>Following example will fail to build with :
``

</Description>
  </Issue>
  <Issue>
    <IssueID>1974</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>"Method has non-void return value, but no result is expected"</Title>
    <CreatedDate>11/01/2017</CreatedDate>
    <ClosedDate>11/01/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>1974</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I am trying to unit test for the first time and I choose NUnit.

I am using Visual Studio 2015 Update 2
NUnit version 3.6.00
NUnit 3 Test Adapter 3.6.1.0

`using NUnit.Framework;

namespace ConsoleApplication1.test
{
    [TestFixture]
    public class math_test
    {
        [TestCase]
        public void DoAdd()
        {
            int result = Add(1, 2);
        }

        [Test]
        public int Add(int x, int y)
        {
            int z = x + y;

            return z;
        }
    }
}`

I tried a very simple test code and I got confused on the result for Add
"Method has non-void return value, but no result is expected"
Why is that?</Description>
  </Issue>
  <Issue>
    <IssueID>1971</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Switch CHANGES.txt to Markdown</Title>
    <CreatedDate>10/01/2017</CreatedDate>
    <ClosedDate>06/04/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>good first issue</Name>
        <IssueID>1971</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>1971</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>1971</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Our `CHANGES.txt` is currently nearly in Markdown format except for the headings. When the changes are copied into releases or the release notes in the docs, they need to be modified to Markdown format. I propose that we just switch `CHANGES.txt` to `CHANGES.md` and format it accordingly.

I am putting this out there as an idea. If the @nunit/core-team likes the idea, we can create issues for the other repos that have CHANGES files.</Description>
  </Issue>
  <Issue>
    <IssueID>1970</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>NUnitLite cannot find .dll file</Title>
    <CreatedDate>10/01/2017</CreatedDate>
    <ClosedDate>24/07/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:norepro</Name>
        <IssueID>1970</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>confirm</Name>
        <IssueID>1970</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>javascript
{
   "dependencies": {
      "NUnit": "3.5.0",
      "NUnitLite": "3.5.0",
      "System.Reflection.TypeExtensions": "4.3.0"
      // etc...
   },
   "frameworks": {
      "netcoreapp1.1": {
         "imports": [
            "dnxcore50"
         ]
      }
   },

   "buildOptions": {
      "emitEntryPoint": true,
      "preserveCompilationContext": true,
      "xmlDoc": false
   },
}


and Program.cs looks like:

csharp
new AutoRun(typeof(Program).GetTypeInfo().Assembly)
   .Execute(args, new ExtendedTextWrapper(Console.Out), Console.In);


## Scenario

start the program to run the tests with `dotnet run`

## Expected

it runs the test

## Actual


NUnitLite 3.5.0 (Portable)
Copyright (C) 2016 Charlie Poole

Test Files
    C:\myPath\to\MyAssembly\bin\Debug\netcoreapp1.1\MyAssembly.dll

Could not load file or assembly 'test, Culture=neutral, PublicKeyToken=null'. The system cannot find the file specified.
`</Code>
    <Description>@la-yumba commented on [Mon Jan 09 2017](## Environment:

- .NET Core 1.1
- SDK version: "1.0.0-preview2-1-003177"

project.json looks like:

``

Note:

- The .dll is there at the named path. 
- The same issue occurs on Windows and OSx---@rprouse commented on [Mon Jan 09 2017](NUnitLite has been merged into the main framework, so I am moving this issue there.</Description>
  </Issue>
  <Issue>
    <IssueID>1966</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>1966</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Xamarin Runner cannot reference NUnit NuGet Package</Title>
    <CreatedDate>09/01/2017</CreatedDate>
    <ClosedDate>09/01/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1966</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>1966</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>1966</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>As initially reported by @ChrisMaddock , since the .NET Standard target was added to the NuGet package, the Xamarin projects cannot reference the package. I have confirmed this and tracked it down to the reference to `Microsoft.NETCore.Portable.Compatibility` in the package. The package lists this as a dependency because the framework references it, but it only references it because of some unused using statements.</Description>
  </Issue>
  <Issue>
    <IssueID>1965</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>1965</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>TestContext does not flow in async method</Title>
    <CreatedDate>08/01/2017</CreatedDate>
    <ClosedDate>27/02/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1965</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>1965</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>1965</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Example tests recreating issue:
``

The side effect of that behaviour is that it is not possible to use `TestContext.WriteLine()` after await as it causes `NullReferenceException`.

Tested with `NUnit 3.5.0`, `net46` and `netcoreapp1.0`</Description>
  </Issue>
  <Issue>
    <IssueID>1963</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>1963</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Investigate removing SpecialValue</Title>
    <CreatedDate>08/01/2017</CreatedDate>
    <ClosedDate>13/01/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1963</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>good first issue</Name>
        <IssueID>1963</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:refactor</Name>
        <IssueID>1963</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>1963</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>`SpecialValue.cs` has the comment:

    /// Null represents a null value, which cannot be 
    /// used as an argument to an attribute under .NET 1.x

We no longer support .NET 1.x, so we should check if there are any uncommented dependencies, and whether it can be removed. 

There's also a very similar `NUnitNullType` - perhaps these can be combined, if SpecialValue can't be removed.</Description>
  </Issue>
  <Issue>
    <IssueID>1962</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>1962</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>A Theory with no data passes</Title>
    <CreatedDate>06/01/2017</CreatedDate>
    <ClosedDate>20/02/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1962</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>1962</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>1962</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>As a result of changes made for issue #1933, an internal problem was made visible. A Theory, for which no data is supplied, will pass.

If a Theory has data but all of it is unsuitable (assumptions fail), then the Theory itself fails. It's somewhat inconsistent for a Theory without data to pass - it should fail as well.

The source of the problem is in how NUnit runs test suites with no test cases. In NUnit V2, such suites were not handled in a special way. Any one-time setup (TestFixtureSetUp) and teardown (TestFixtureTearDown) was run, whether there were tests or not. In NUnit 3, we decided to change this behavior and only run one-time setup and teardown if there are actually child tests to be run. This saves wasted cycles when the one-time setup performs a lot of work, which is more common these days with folks doing database and web testing using NUnit.

Unfortunately, we did not change how Theories examine the result of their individual cases and decide whether they should pass or faill. This was (and is still) done by a special command added to the one-time teardown for the parameterized test suite representing the theory. Since one-time teardown is not run when there are no tests (i.e. no data) the command is never run.

To fix this requires re-thinking how we want to handle the overall result of a suite. In the general case, this is done each time a test case result is added to the suite result. In the case of Theories, a special action is taken to override the default behavior of suites. We will probably want to handle this by creating a special result for Theories with it's own aggregation behavior.

Since this is part of the fundamental architecture of the framework, I'm assigning it to myself for now.</Description>
  </Issue>
  <Issue>
    <IssueID>1961</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>TestContext.Progress.Write working on my machine but not colleagues'</Title>
    <CreatedDate>06/01/2017</CreatedDate>
    <ClosedDate>09/01/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>1961</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Heya,

I am currently using the _TestContext.Progress.Write()_ functionality, which works perfectly fine on my machine. 

However, my colleagues' test executing engine doesn't show the writes. 

Any clue as where to look? Our .runsettings etc. are fully the same

Both me and colleague are using VS2015, NUnit 3.x and Resharper 2016</Description>
  </Issue>
  <Issue>
    <IssueID>1958</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>OmicronPersei</FixedById>
        <IssueID>1958</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>System.Reflection.TargetInvocationException after run finished</Title>
    <CreatedDate>05/01/2017</CreatedDate>
    <ClosedDate>18/01/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1958</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>1958</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>1958</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>After running tests (`/packages/NUnit.ConsoleRunner.3.5.0/tools/nunit3-console.exe workspace/Tests/ED_DC_Tests.dll --where "cat == _Acceptance" --work workspace --inprocess `) there is error:

``

The error is in some test, because other categories runs good. All tests runs in parallel. Any suggesting to find buggy case?</Description>
  </Issue>
  <Issue>
    <IssueID>1954</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>JustinRChou</FixedById>
        <IssueID>1954</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Change Error Message for Assert.Equals</Title>
    <CreatedDate>04/01/2017</CreatedDate>
    <ClosedDate>09/01/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1954</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>good first issue</Name>
        <IssueID>1954</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>1954</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>1954</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Based on the number of votes on this StackOverflow question,  many users find the message in our `Assert.Equals` override to be confusing. It currently says "Assert.Equals should not be used for Assertions", we should change it to be "Assert.Equals should not be used for Assertions, use Assert.AreEqual(...) instead".</Description>
  </Issue>
  <Issue>
    <IssueID>1953</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>async teardown called early?</Title>
    <CreatedDate>04/01/2017</CreatedDate>
    <ClosedDate>04/01/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:norepro</Name>
        <IssueID>1953</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Hi, I have a bunch of async tests. Most of these run well but every once in awhile, esp. when first tested, some of the tests do not complete correctly. When I run them again it usually works. It looks like "Teardown" is being run maybe about 200 ms after the async test runs, which usually gives enough time but sometimes doesn't. Is async testing actually not supported? Have I been fooling myself all this time? 📦 

My expectation is that
``

I also tried using an async Teardown but it didn't help.</Description>
  </Issue>
  <Issue>
    <IssueID>1952</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>1952</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>TestContext.Out null when used in task with .NET Core</Title>
    <CreatedDate>04/01/2017</CreatedDate>
    <ClosedDate>28/02/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1952</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>1952</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>1952</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Hi,

I have a test project targeting both .NET Framework (4.6.2) and .NET Core (1.1) and am finding that for the latter `TextContext.Out` is null when used from a `Task`. The code below reproduces the issue:

``
printed at the console.

I'm using NUnitLite 3.5.0 with dotnet-test-nunit 3.4.0-beta-3. The failure occurs when using `dotnet test` from the command-line as well as from Visual Studio.
</Description>
  </Issue>
  <Issue>
    <IssueID>1949</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>VS tests gets passed when running in Visual Studio 2015 Community Version but when running the same code through Nunit3 Console runner Test cases gets pass and fail.</Title>
    <CreatedDate>03/01/2017</CreatedDate>
    <ClosedDate>08/08/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>1949</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Hi everyone,
Apologies for the lengthy post.

I have created VS tests in visual studio 2015 community version. When i run the test cases my test cases gets passed constantly.

I want to run my VS tests without visual studio software in remote machine, so I created the bat file with pointing nunit3 console.exe followed by my dll file. But the tests gets pass for first time and gets failed for third , fourth time , and fifth time it gets passed. The result is not constant. 

I would like to know where the problem is ? Can anyone suggest me please.</Description>
  </Issue>
  <Issue>
    <IssueID>1947</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>1947</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Add NonTestAssemblyAttribute</Title>
    <CreatedDate>02/01/2017</CreatedDate>
    <ClosedDate>03/01/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1947</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:feature</Name>
        <IssueID>1947</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>1947</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>The use of this attribute is described in nunit/nunit-console#62

It should be non-browsable to avoid use by the wrong people.

Priority is high because of the console issue.</Description>
  </Issue>
  <Issue>
    <IssueID>1946</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>CompositeWorkItem reports all skipped tests as 'OneTimeSetUp: '</Title>
    <CreatedDate>30/12/2016</CreatedDate>
    <ClosedDate>30/12/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>1946</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>csharp
	[TestFixture, Explicit]
	public class ExplicitTests {
		[Test]
		public void Test1() {
			Assert.Pass();
		}
	}

	[TestFixture, Explicit("Some reason")]
	public class ExplicitTestsWithReason {
		[Test]
		public void Test1() {
			Assert.Pass();
		}
	}

	[TestFixture]
	public class TestsWithExplicitOnlyTest {
		[Test, Explicit]
		public void Test1() {
			Assert.Pass();
		}
	}

	[TestFixture]
	public class TestsWithExplicitReasonOnlyTest {
		[Test, Explicit("Some reason")]
		public void Test1() {
			Assert.Pass();
		}
	}

	[TestFixture]
	public class TestsWithExplicitAndNonExplicitTests {
		[Test, Explicit("Some reason")]
		public void Test1() {
			Assert.Pass();
		}

		[Test]
		public void Test2() {
			Assert.Pass();
		}
	}


Running them gives the following output:

bash

Tests not run

1) Explicit : NUnitTests.ExplicitTests.Test1
OneTimeSetUp:

2) Explicit : NUnitTests.ExplicitTestsWithReason.Test1
OneTimeSetUp: Some reason

3) Explicit : NUnitTests.TestsWithExplicitAndNonExplicitTests.Test1
Some reason

4) Explicit : NUnitTests.TestsWithExplicitOnlyTest.Test1

5) Explicit : NUnitTests.TestsWithExplicitReasonOnlyTest.Test1
Some reason
`</Code>
    <Description>Tested against v3.5.0

Given the following set of test fixtures:

``

Note that some (but not all, presumably due to them being handled by something different?) of them are saying `OneTimeSetUp` for the given reason, when I've not used the attribute at all.

Culprit seems to be [ where it's been hard coded in. To me it seems like it should just render the value of `resultState` as the prefix</Description>
  </Issue>
  <Issue>
    <IssueID>1944</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>jnm2</FixedById>
        <IssueID>1944</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Removing Compact Framework workarounds</Title>
    <CreatedDate>29/12/2016</CreatedDate>
    <ClosedDate>24/01/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1944</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:build</Name>
        <IssueID>1944</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:low</Name>
        <IssueID>1944</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Browsing through the code, I noticed some references to compromises made in order to support CF, or documentation of CF quirks:

- [x] &lt;s&gt;[/src/NUnitFramework/framework/Constraints/NUnitEqualityComparer.cs#L260](

   &gt; [@CharliePoole] Just a comment - somebody wanted to use methods that are not in CF - note that "original" in this context doesn't mean original NUnit code, just that person's original idea of how to code. No change except maybe the useless comment.

- [x] [/src/NUnitFramework/framework/Interfaces/ITestResult.cs#L95](

   &gt; [@CharliePoole] Useless comment - we haven't supported CF 1.0 for MANY years.

- [x] &lt;s&gt;[/src/NUnitFramework/framework/Internal/Reflect.cs#L162](

   &gt; [@CharliePoole] Another comment. This one could be acted on by changing the code when somebody is actually working in the file.

- [ ] &lt;s&gt;[/src/NUnitFramework/framework/Internal/StackFilter.cs#L96](

   &gt; [@CharliePoole] I think the comment may be wrong and that other platforms may need that code. It was probably true when written.

- [x] &lt;s&gt;[/src/NUnitFramework/framework/Internal/TestNameGenerator.cs#L165](

   &gt; [@CharliePoole] This would be a reasonable change if we know all platforms support TryParse. No sense changing when we aren't working in the file though.

- [ ] &lt;s&gt;[/src/NUnitFramework/tests/Internal/StackFilterTests.cs#L52](

   &gt; [@CharliePoole] Comment is obsolete but the test remains valid in case we do get deeper stack traces. This stack trace behavior seems to change with different releases of the framework.

- [x] [/src/NUnitFramework/nunitlite/CommandLineOptions.cs#L128](

   &gt; [@CharliePoole] The NETCF code should be removed, since we removed it in most other places.

- [x] &lt;s&gt;[/src/NUnitFramework/nunitlite/CommandLineOptions.cs#L324](

   &gt; [@CharliePoole] As earlier, I'd use TryParse when I next work work in this file

- [x] [/src/NUnitFramework/nunitlite/DebugWriter.cs#L31](

   &gt; [@CharliePoole] The class should probably be removed at some point as we don't use it.

- [x] [/src/NUnitFramework/nunitlite/TextUI.cs#L138](

   &gt; [@CharliePoole] This impacts users so should get an issue and be fixed.

If I understand correctly, this repo will never support CF again. In that case some cleanup might be desirable. Willing to help with this.</Description>
  </Issue>
  <Issue>
    <IssueID>1943</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Escaping test method name patterns</Title>
    <CreatedDate>29/12/2016</CreatedDate>
    <ClosedDate>07/11/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:wontfix</Name>
        <IssueID>1943</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>1943</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:low</Name>
        <IssueID>1943</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>When you use TestCaseData.SetName, there are a number of substitutions made for such patterns as `{n}`, `{c}`, `{C}`, `{m}`, `{M}`, `{a}`, `{i}`, `{0}`, `{1}`, `{2}`, etc. [(docs)](

What I am often required to do in my test case sources, due to the length and unhelpfulness of the `.ToString()` rendering of some parameter types, is this: `.SetName($"{{m}}({param1.Name}, {param2.Name})")`

The unfortunate thing is that if any parameter happens to contain, say, `{c}` or `{1:20}`, it will be interpreted as a substitution rather than a literal.

In other scenarios similar to this one (command line parameters, regex, URLs, XML), we escape literal text to protect it. I'd like to be able to use `string TestNameGenerator.Escape(string literal)` in the same manner as I would if I was escaping anything else:

`.SetName($"{{m}}({TestNameGenerator.Escape(param1.Name)}, {TestNameGenerator.Escape(param2.Name)})")`

For the underlying escaping mechanism, I'd suggest escaping `{` as `{{` and `}` as `}}` because this has precedent in .NET format strings and C# interpolation. There are also more scenarios where it _won't_ have to be double-escaped than scenarios where it will.

With an eye to backwards compatibility, escaping is probably better to implement ahead of time rather  than when needed.

Willing to PR.</Description>
  </Issue>
  <Issue>
    <IssueID>1941</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Use dictionary-based property for test run parameters</Title>
    <CreatedDate>28/12/2016</CreatedDate>
    <ClosedDate>09/01/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1941</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>1941</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>This issue tracks the orchestration of the work assigned to me by @CharliePoole in 

 * ~~Superseding~~ Supplementing the string-based test parameters property with a dictionary-based one. Decouples parsing test parameters between the various runners, from each other and from the framework which test assemblies happen to be built against.
 * Providing backward compatibility for both old runners with new framework and old framework with new runners.

- [x] Framework:  commit 
- [x] NUnitLite:  commit 
- [x] nunit3-vs-adapter: 
- [x] nunit-console: 
- [x] dotnet-test-nunit: 
     - [x] nunit.portable.agent: 
- [x] &lt;s&gt;nunit-gui&lt;/s&gt; (Does not have a concept of test parameters)
- [x] Any others? (No)

Due to the two-way backwards compatibility guarantee, each of these top-level tasks is completely  independent of the others.</Description>
  </Issue>
  <Issue>
    <IssueID>1939</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Ability to access name of suite for which test case source is being executed</Title>
    <CreatedDate>28/12/2016</CreatedDate>
    <ClosedDate>29/12/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>1939</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>c#
public static IEnumerable&lt;TestCaseData&gt; AllThings(string suiteName)
{
    return
        from [...]
        select new TestCaseData(thingInfo1, thingInfo2)
            .SetName($"{suiteName}({thingInfo1.Name}, {thingInfo2.Name})");
}

[TestCaseSource(typeof(ThingTests), nameof(AllThings), new object[] { nameof(TestAspectOfThing) })]
public void TestAspectOfThing(Type thingInfo1, FieldInfo thingInfo2)
{
}


I would much rather write something like this:
c#
public static IEnumerable&lt;TestCaseData&gt; AllThings()
{
    return
        from ...
        select new TestCaseData(thingInfo1, thingInfo2)
            .SetName($"{TestContext.CurrentContext.Test.Name}({thingInfo1.Name}, {thingInfo2.Name})");
}

[TestCaseSource(nameof(AllThings))]
public void TestAspectOfThing(Type thingInfo1, FieldInfo thingInfo2)
{
}


The problem is that `TestContext.CurrentContext.Test` is null at this time.
Is something like this possible?

A perhaps even better alternative, which I could also implement via extension method if I had  `TestContext.CurrentContext.Test.Name` or something similar:

c#
public static IEnumerable&lt;TestCaseData&gt; AllThings()
{
    return
        from ...
        select new TestCaseData(thingInfo1, thingInfo2)
            .SetParameterNames(thingInfo1.Name, thingInfo2.Name);
}

[TestCaseSource(nameof(AllThings))]
public void TestAspectOfThing(Type thingInfo1, FieldInfo thingInfo2)
{
}
`</Code>
    <Description>I have code like this all over the place:

``

The overarching reason to do this that the default `.ToString()` parameter naming results in extremely long test names and I need the parameter names to be easily absorbed.</Description>
  </Issue>
  <Issue>
    <IssueID>1938</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>ExpectedExceptionAttribute</Title>
    <CreatedDate>26/12/2016</CreatedDate>
    <ClosedDate>26/12/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1938</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>1938</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I'm using in VS2013 nunit.framework 3.5.0.0 taken from NuGet packages. What do I need to connect the lib so I could test using the attribute: [ExpectedException (typeof (ArgumentException))]?</Description>
  </Issue>
  <Issue>
    <IssueID>1936</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Should full c# style escaping be supported TestParameters?</Title>
    <CreatedDate>23/12/2016</CreatedDate>
    <ClosedDate>18/05/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:idea</Name>
        <IssueID>1936</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>The discussion in #1885 has focused on the problems related to having semicolons in the value of a --params option.

In considering that issue, I had the realization that other characters requiring escaping should be allowed in the parameter value as well (such as control characters).

It therefore seems like the various front ends should allow full C# (or other model) character escaping in the value of the test parameter in addition to the semicolon (and the escape character, whatever it is).</Description>
  </Issue>
  <Issue>
    <IssueID>1934</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>gcichosz</FixedById>
        <IssueID>1934</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>NullReferenceException when null arguments are used in TestFixtureAttribute</Title>
    <CreatedDate>21/12/2016</CreatedDate>
    <ClosedDate>19/05/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>1934</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>1934</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>This seems to be related to #1507. We started getting several errors after moving from 3.4 to 3.5. The errors can be seen in the Visual Studio test runner and the nunit3-console runner. The errors are all similar to the following:
``</Description>
  </Issue>
  <Issue>
    <IssueID>1933</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Tests should pass if test case source provides 0 test cases</Title>
    <CreatedDate>20/12/2016</CreatedDate>
    <ClosedDate>08/01/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1933</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>1933</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>1933</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I'm in a situation where I need to run a set of integration tests sets against multiple databases. It's been _extremely_ helpful to use TestCaseSource to give separate test cases for each object in certain database tables. In fact, this is what motivated the move to NUnit in the first place.

The only issue is that it's perfectly valid for tables to be empty.  In that scenario, I would expect that no test cases would exist or be run. Surprisingly, and problematically, even though I'm returning an empty `IEnumerable&lt;TestCaseData&gt;` from the test case source, NUnit still attempts to run the test anyway as a single case with no arguments. And of course the test fails, since the arguments are necessary.

Is this helpful behavior or a bug? If this is helpful behavior to some people, can I globally configure NUnit to always consider 0 test cases as 0 test cases which matches my intuition and needs?</Description>
  </Issue>
  <Issue>
    <IssueID>1932</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>NUnit Warn class should be removed from stack trace by filter</Title>
    <CreatedDate>19/12/2016</CreatedDate>
    <ClosedDate>11/04/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1932</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>good first issue</Name>
        <IssueID>1932</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>1932</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:low</Name>
        <IssueID>1932</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>The Warn class is in the same category as Assert and Assume. The standard filter should be updated to include it.</Description>
  </Issue>
  <Issue>
    <IssueID>1931</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>NUnit'</Title>
    <CreatedDate>19/12/2016</CreatedDate>
    <ClosedDate>19/12/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>1931</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
  </Issue>
  <Issue>
    <IssueID>1930</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Nunit 3.5.0 on Visual Studio Mac with .NET Core 1.1</Title>
    <CreatedDate>15/12/2016</CreatedDate>
    <ClosedDate>15/12/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>1930</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>This may be a longshot but I wanted to run the above config
I create a project and edit the csproj to target .NET Core 1.1

Then I add the NUint 3.5.0 nuget package and can see in the screen that it supports DotNet core 

However the nuget log says this:
Which seems like it does not include .NET Core

Is this supported or not yet ?
I have 1.0 Preview 2 of the SDK tools. Do I need to get preview3 from github maybe ?

(Restore target) -&gt; 
  /Library/Frameworks/Mono.framework/Versions/4.8.0/lib/mono/xbuild/NuGet.targets : error : Package NUnit 3.5.0 is not compatible with netcoreapp1.1 (.NETCoreApp,Version=v1.1). Package NUnit 3.5.0 supports: [/Users/nicka/dotnet-test/xy/xy/xy/xy.csproj]
/Library/Frameworks/Mono.framework/Versions/4.8.0/lib/mono/xbuild/NuGet.targets : error :   - dotnet (.NETPlatform,Version=v5.0) [/Users/nicka/dotnet-test/xy/xy/xy/xy.csproj]
/Library/Frameworks/Mono.framework/Versions/4.8.0/lib/mono/xbuild/NuGet.targets : error :   - net20 (.NETFramework,Version=v2.0) [/Users/nicka/dotnet-test/xy/xy/xy/xy.csproj]
/Library/Frameworks/Mono.framework/Versions/4.8.0/lib/mono/xbuild/NuGet.targets : error :   - net35 (.NETFramework,Version=v3.5) [/Users/nicka/dotnet-test/xy/xy/xy/xy.csproj]
/Library/Frameworks/Mono.framework/Versions/4.8.0/lib/mono/xbuild/NuGet.targets : error :   - net40 (.NETFramework,Version=v4.0) [/Users/nicka/dotnet-test/
xy/xy/xy/xy.csproj]
/Library/Frameworks/Mono.framework/Versions/4.8.0/lib/mono/xbuild/NuGet.targets : error :   - net45 (.NETFramework,Version=v4.5) [/Users/nicka/dotnet-test/xy/xy/xy/xy.csproj]
/Library/Frameworks/Mono.framework/Versions/4.8.0/lib/mono/xbuild/NuGet.targets : error :   - portable-monoandroid10+monotouch10+net45+win8+wp8+wpa81+xamarinios10+xamarinmac (.NETPortable,Version=v0.0,Profile=net45+win8+wp8+wpa81+Xamarin.Mac+MonoAndroid10+MonoTouch10+Xamarin.iOS10) [/Users/nicka/dotnet-test/xy/xy/xy/xy.csproj]
  /Library/Frameworks/Mono.framework/Versions/4.8.0/lib/mono/xbuild/NuGet.targets : error : One or more packages are incompatible with .NETCoreApp,Version=v1.1. [/Users/nicka/dotnet-test/xy/xy/xy/xy.csproj]
</Description>
  </Issue>
  <Issue>
    <IssueID>1928</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Nunit failure from teamcity &amp; command line</Title>
    <CreatedDate>14/12/2016</CreatedDate>
    <ClosedDate>15/12/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:duplicate</Name>
        <IssueID>1928</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Im getting below error when I don't provide the path of nunit, something like below.

[exec] Run Environment: NCOVER_USING_PROJECT[6471E3B9202D8311D439C110FAF65D996658CBDB]
[11:23:21][exec] Run Environment: NCOVER_BUILD_ID[17.1.0_CI_308]
[11:23:21][exec] Run Environment: COR_ENABLE_PROFILING[1]
[11:23:21][exec] Run Environment: COR_PROFILER[NCover.ProfilerLauncher]
[11:23:21][exec] Unable to start requested process: nunit3-console.exe
[11:23:22][exec] EXCEPTION: 2016-12-14T11:23:21 Error starting process:  --&gt; System.ComponentModel.Win32Exception: The system cannot find the file specified
[11:23:22][exec]    at System.Diagnostics.Process.StartWithCreateProcess(ProcessStartInfo startInfo)
[11:23:22][exec]    at ? .???.??(String[] ?  , ?  ?  )

Script used in nant that ran through team city.
**&lt;exec
              program="ncover"
              basedir="C:\Program Files\NCover Code Central\"
              workingdir="${Workspace.Path}\UnitTesting\UnitTests"
              commandline="run --project=&amp;quot;&amp;quot;UnitTests&amp;quot;&amp;quot; --build-id=${build.Version} -- nunit3-console.exe UnitTests.sln /out:TestResult.txt"
              failonerror="true" verbose="true"&gt;
    &lt;/exec&gt;**

From command line above script works fine.

I have tried below approach to fix, but it fails with different error now.
**&lt;exec
              program="ncover"
              basedir="C:\Program Files\NCover Code Central\"
              workingdir="${Workspace.Path}\UnitTesting\UnitTests"
              commandline="run --project=&amp;quot;&amp;quot;UnitTests&amp;quot;&amp;quot; --build-id=${build.Version} -- &amp;quot;&amp;quot;${Workspace.Path}\Tools\Nunit\nunit-console\nunit3-console.exe&amp;quot;&amp;quot; UnitTests.sln /out:TestResult.txt"
              failonerror="true" verbose="true"&gt;
    &lt;/exec&gt;**

Error in command line
![image](


     [exec]
     [exec] Time Elapsed 00:00:04.06
     [exec] Starting 'C:\Program Files\NCover Code Central\ncover (run --project=""UnitTests"" --build-id=17.1.0_CI_309 -- ""C:\TeamCity\buildAgent\work\GIT_Security\source\Tools\Nunit\nunit-console\nunit3-console.exe"" HostAnalytics.Pl
ln /out:TestResult.txt)' in 'C:\TeamCity\buildAgent\work\GIT_Security\source\UnitTesting\Tests\Tests'
     [exec] NCover v5.5.3543.583 x64 (Administrator)
     [exec] Copyright (c) 2007 - 2016 NCover LLC
     [exec] Starting: NCover Code Central on Microsoft Windows NT 6.1.7601 Service Pack 1
     [exec] Server Root: 
     [exec] Run Environment: NCOVER_USING_PROJECT[6471E3B9202D8311D439C110FAF65D996658CBDB]
     [exec] Run Environment: NCOVER_BUILD_ID[17.1.0_CI_309]
     [exec] Run Environment: COR_ENABLE_PROFILING[1]
     [exec] Run Environment: COR_PROFILER[NCover.ProfilerLauncher]
     [exec] NUnit Console Runner 3.4.1
     [exec] Copyright (C) 2016 Charlie Poole
     [exec]
     [exec] Runtime Environment
     [exec]    OS Version: Microsoft Windows NT 6.1.7601 Service Pack 1
     [exec]   CLR Version: 4.0.30319.34209
     [exec]
     [exec] Test Files
     [exec]     HostAnalytics.Planning.Tests.sln
     [exec]
     [exec] System.Exception: Unable to acquire remote process agent
     [exec]    at NUnit.Engine.Runners.ProcessRunner.CreateAgentAndRunner()
     [exec]    at NUnit.Engine.Runners.ProcessRunner.LoadPackage()
     [exec]    at NUnit.Engine.Runners.AbstractTestRunner.Load()
     [exec]    at NUnit.Engine.Runners.MasterTestRunner.LoadPackage()
     [exec]    at NUnit.Engine.TestEngine.GetRunner(TestPackage package)
     [exec]    at NUnit.ConsoleRunner.ConsoleRunner.RunTests(TestPackage package, TestFilter filter)
     [exec]    at NUnit.ConsoleRunner.ConsoleRunner.Execute()
     [exec]    at NUnit.ConsoleRunner.Program.Main(String[] args)



Total time: 38.8 seconds.



</Description>
  </Issue>
  <Issue>
    <IssueID>1926</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>1926</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Determine why Cake NUnit Task Fails on Linux</Title>
    <CreatedDate>13/12/2016</CreatedDate>
    <ClosedDate>12/08/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>1926</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>1926</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>The Cake NUnit task fails on linux with the default settings, but works in-process. We should determine if it is a Cake problem or an NUnit problem.

The Travis failure is,

``

Once this issue is fixed, the `IsRunningOnWindows` check should be removed from `build.cake` for the NUnit tests task where it sets the tests to run in-process.</Description>
  </Issue>
  <Issue>
    <IssueID>1924</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>1924</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Run tests using the NUnit Console Runner</Title>
    <CreatedDate>11/12/2016</CreatedDate>
    <ClosedDate>13/12/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1924</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:build</Name>
        <IssueID>1924</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>1924</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>When we split the repositories, we switched the test runs from using the NUnit Console to using the NUnitLite runner. This works, but using the released version of the NUnit Console will provide a small measure of integration testing between the projects.</Description>
  </Issue>
  <Issue>
    <IssueID>1922</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Xml Documentation in the Nuget packages</Title>
    <CreatedDate>11/12/2016</CreatedDate>
    <ClosedDate>11/12/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>1922</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>@cinnamon25 commented on [Fri Dec 09 2016](Can you please, include the XML Documentation in the nuget packages, so that Visual Studio shows the documentation, when I hover on a method...---@CharliePoole commented on [Fri Dec 09 2016](I assume you mean in the nuget package for the framework?---@cinnamon25 commented on [Sun Dec 11 2016](Yes---@rprouse commented on [Sun Dec 11 2016](@cinnamon25 we do include the XML Docs for the NUnit framework in the package. Is there another project that it is missing from or are you seeing problems?

Here is a screenshot of the 3.5 release in NuGet Package Explorer

![image](
</Description>
  </Issue>
  <Issue>
    <IssueID>1921</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Request for TestCaseSource parallelization</Title>
    <CreatedDate>06/12/2016</CreatedDate>
    <ClosedDate>06/12/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:duplicate</Name>
        <IssueID>1921</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Currently the only parallelization supported is fixture level, even though it sounds likely that test-level parallelization is planned.

This would be a terrifyingly good optimization for me. What stands between us and having parameterized test cases run in parallel? Can I contribute?</Description>
  </Issue>
  <Issue>
    <IssueID>1918</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>1918</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Changing DefaultFloatingPointTolerance breaks tests running in parallel</Title>
    <CreatedDate>01/12/2016</CreatedDate>
    <ClosedDate>24/04/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1918</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>1918</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>1918</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>GlobalSettings.DefaultFloatingPointTolerance is a static. When it is changed for a single test, other tests may be affected. Even if the test resets it to the original value in TearDown, any tests that run in parallel with the test making the change are affected.

We should deprecate the GlobalSettings class (this is its sole member) and provide some other way to change the default tolerance. As it stands, the default tolerance should only be set at the command-line or in a global SetUpFixture.</Description>
  </Issue>
  <Issue>
    <IssueID>1917</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>1917</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Use of IsolatedContext breaks tests in user-created AppDomain</Title>
    <CreatedDate>01/12/2016</CreatedDate>
    <ClosedDate>02/12/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1917</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>1917</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>1917</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>In fixing issue #1914, I had to comment out a test in LowTrustFixture.cs, which ran code in a separate AppDomain created by the user.

The problem is that the TestExecutionContext is marshalled by reference, while some of it's members are neither MBR nor serializable. Accessing any such member causes a remoting error. This is a consequence of the fact that we don't explicitly support running tests in a separate AppDomain but nothing stops a user from creating an AppDomain in their tests.

The particular test commented out uses Assert.Throws, which now creates an isolated context for the delegate it executes. Creating the context in a separate domain involves copying members across the remoting boundary. I think we can avoid this by using a public method of TestExecutionContext to create the isolated domain in the original context.

We have a few other issues that relate to problems in user-created AppDomains: #42 and #71. They may be due to the same phenomenon, so I'll look at them at the same time.</Description>
  </Issue>
  <Issue>
    <IssueID>1914</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>1914</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Extra AssertionResult entries in TestResults</Title>
    <CreatedDate>29/11/2016</CreatedDate>
    <ClosedDate>01/12/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1914</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>1914</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>1914</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>There are a few situations where spurious AssertionResult entries are created in the result:

1. Assert.Throws or ThrowsConstraint when the code executed by the delegate argument includes asserts. The second-level asserts may leave failure and warning entries in the result that is being used for the top level test.

2. Executing code that causes an AssertionException and then catches it. This is done in some of our NUnit tests and it's a "trick" used by some users. The failure represented by the exception is added to the result before we can catch it.

3. Any Assert that takes a delegate could theoretically do the same thing if there were Asserts in the code executed. However, this is something of a pathological situation, since there isn't much reason to use Asserts in such delegates.

To resolve this, all such "second level" code should be executed in an isolated context and should apply to a separate result, which is ignored by the top-level code.</Description>
  </Issue>
  <Issue>
    <IssueID>1913</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>1913</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Report Warnings in NUnitLite</Title>
    <CreatedDate>26/11/2016</CreatedDate>
    <ClosedDate>15/12/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1913</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:feature</Name>
        <IssueID>1913</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>1913</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Warnings should be listed along with errors and failures.</Description>
  </Issue>
  <Issue>
    <IssueID>1912</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>1912</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Add new warning status and result state</Title>
    <CreatedDate>26/11/2016</CreatedDate>
    <ClosedDate>14/12/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1912</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:feature</Name>
        <IssueID>1912</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>1912</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>This issue is preliminary to all other work on the Warning-level Assertions Epic.

To do, while making sure all tests continue to pass:
* Create a warning TestStatus
* Create a warning ResultState
* Ensure that all code that switches on either TestStatus or ResultState  takes the new values into account.
* Redefine the Ignored result state as a warning and change logic around ignored tests
* Create and Test Assert.Warn
* Create and Test Warn.If and Warn.Unless (same overloads as Assume.That)
* Ensure that warnings are all saved in the `&lt;assertions&gt;` element, with status Warning.</Description>
  </Issue>
  <Issue>
    <IssueID>1908</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Nunit3 runs all tests in Teamcity</Title>
    <CreatedDate>22/11/2016</CreatedDate>
    <ClosedDate>01/12/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>1908</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I recently upgraded to Nunit3.21 from 2.6.4. Some of the tests are running successfully, 
When i try to debug a failing tests, it runs all the other tests before running the specific test, I wasnt seeing this behavior in the earlier versions.
Any help or input would be useful.</Description>
  </Issue>
  <Issue>
    <IssueID>1907</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>1907</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Handle early termination of multiple assert block</Title>
    <CreatedDate>20/11/2016</CreatedDate>
    <ClosedDate>29/11/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1907</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:feature</Name>
        <IssueID>1907</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>1907</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>According to the spec, we want the test will be terminated immediately in case of Assert.Fail, Assert.Pass, Assert.Inconclusive, Assert.Ignore, Assumeption failures and unexpected exceptions. We are doing that now but we don't have tests and we don't display the special messages called for in the spec:
 * Assert.Fail encountered with pending failures: $usermessage$
 * Assert.Pass encountered with pending failures: $usermessage$
 * Assert.Inconclusive encountered with pending failures: $usermessage$
 * Assert.Ignore encountered with pending failures: $usermessage$
 * Assumption failed with pending test failures: $usermessage$
 * TypeOfException encountered with pending failures: $exceptionmessage$

Question for @nunit/contributors : Should we show the pending failures in any of these cases?
</Description>
  </Issue>
  <Issue>
    <IssueID>1906</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>SetUpAttribute attribute not allowed in a SetUpFixture - base class and derived class implementation</Title>
    <CreatedDate>18/11/2016</CreatedDate>
    <ClosedDate>18/11/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>1906</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I upgraded Nunit from 2.6.4 to 3.2.1, and the tests which were using inheritance have started to fail with the message "OneTimeSetUp: SetUpAttribute attribute not allowed in a SetUpFixture".

The code is as follows:
[NUnit.txt](

Note:
Except for "FixtureBase" class,all the other classes are in the same namespace.

It was working perfectly in Nuni.2.6.2, not sure how to make this work in 3.2.1, any help will be really helpful.

Thanks</Description>
  </Issue>
  <Issue>
    <IssueID>1905</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>1905</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>SetupFixture without namespace will make assembly-level Parallelable attribute useless</Title>
    <CreatedDate>18/11/2016</CreatedDate>
    <ClosedDate>29/10/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1905</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>1905</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>1905</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>csharp
using System.Threading;
using NUnit.Framework;

[assembly:Parallelizable(ParallelScope.Fixtures)]

[SetUpFixture]
public class GlobalSetup
{
    [OneTimeSetUp]
    public void Setup()
    {
        Thread.Sleep(5000);
    }
}

namespace NUnitTest
{
    [TestFixture]
    public class TestFixture1
    {
        [Test]
        public void Test1()
        {
            Thread.Sleep(5000);
        }
    }

    [TestFixture]
    public class TestFixture2
    {
        [Test]
        public void Test2()
        {
            Thread.Sleep(5000);
        }
    }
}


Here is the test result file.
xml
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;test-run id="2" name="NUnitTest.dll" fullname="GlobalSetup" testcasecount="2" result="Passed" start-time="2016-11-18 14:25:20Z" end-time="2016-11-18 14:25:35Z" duration="15.037411" total="2" passed="2" failed="0" inconclusive="0" skipped="0" asserts="0" random-seed="1862713937"&gt;
  &lt;command-line&gt;&lt;![CDATA[XXX\NUnit-3.5.0\bin\net-4.5\nunitlite-runner.exe  NUnitTest.dll]]&gt;&lt;/command-line&gt;
  &lt;filter /&gt;
  &lt;test-suite type="SetUpFixture" id="1000" name="NUnitTest.dll" fullname="GlobalSetup" classname="GlobalSetup" runstate="Runnable" testcasecount="2" result="Passed" start-time="2016-11-18 14:25:20Z" end-time="2016-11-18 14:25:35Z" duration="15.037411" total="2" passed="2" failed="0" inconclusive="0" skipped="0" asserts="0"&gt;
    &lt;environment framework-version="3.5.0.0" clr-version="4.0.30319.42000" os-version="Microsoft Windows NT 6.2.9200.0" platform="Win32NT" cwd="XXX\NUnitTest\NUnitTest\bin\Debug" machine-name="XXX" user="XXX" user-domain="XXX" culture="en-US" uiculture="en-US" os-architecture="x86" /&gt;
    &lt;settings&gt;
      &lt;setting name="WorkDirectory" value="XXX\NUnitTest\NUnitTest\bin\Debug" /&gt;
      &lt;setting name="NumberOfTestWorkers" value="8" /&gt;
    &lt;/settings&gt;
    &lt;properties&gt;
      &lt;property name="ParallelScope" value="Fixtures" /&gt;
      &lt;property name="_PID" value="8328" /&gt;
      &lt;property name="_APPDOMAIN" value="nunitlite-runner.exe" /&gt;
    &lt;/properties&gt;
    &lt;test-suite type="TestSuite" id="1006" name="NUnitTest" fullname="NUnitTest" runstate="Runnable" testcasecount="2" result="Passed" start-time="2016-11-18 14:25:25Z" end-time="2016-11-18 14:25:35Z" duration="10.023981" total="2" passed="2" failed="0" inconclusive="0" skipped="0" asserts="0"&gt;
      &lt;test-suite type="TestFixture" id="1001" name="TestFixture1" fullname="NUnitTest.TestFixture1" classname="NUnitTest.TestFixture1" runstate="Runnable" testcasecount="1" result="Passed" start-time="2016-11-18 14:25:25Z" end-time="2016-11-18 14:25:30Z" duration="5.011831" total="1" passed="1" failed="0" inconclusive="0" skipped="0" asserts="0"&gt;
        &lt;test-case id="1002" name="Test1" fullname="NUnitTest.TestFixture1.Test1" methodname="Test1" classname="NUnitTest.TestFixture1" runstate="Runnable" seed="1420857753" result="Passed" start-time="2016-11-18 14:25:25Z" end-time="2016-11-18 14:25:30Z" duration="5.003950" asserts="0" /&gt;
      &lt;/test-suite&gt;
      &lt;test-suite type="TestFixture" id="1003" name="TestFixture2" fullname="NUnitTest.TestFixture2" classname="NUnitTest.TestFixture2" runstate="Runnable" testcasecount="1" result="Passed" start-time="2016-11-18 14:25:30Z" end-time="2016-11-18 14:25:35Z" duration="5.004199" total="1" passed="1" failed="0" inconclusive="0" skipped="0" asserts="0"&gt;
        &lt;test-case id="1004" name="Test2" fullname="NUnitTest.TestFixture2.Test2" methodname="Test2" classname="NUnitTest.TestFixture2" runstate="Runnable" seed="2116975853" result="Passed" start-time="2016-11-18 14:25:30Z" end-time="2016-11-18 14:25:35Z" duration="5.000674" asserts="0" /&gt;
      &lt;/test-suite&gt;
    &lt;/test-suite&gt;
  &lt;/test-suite&gt;
&lt;/test-run&gt;
`</Code>
    <Description>I've tried to combine parallel testing and SetupFixture. But no luck.

I added `[assembly:Parallelizable(ParallelScope.Fixtures)]` in code. And if I put SetupFixture into root namespace, then test fixtures in this assembly will run sequentially. However, if I put SetupFixture into the same namespace as other text fixtures, test fixtures can run in parallel.

I've tried both NUnit 3.4.1 and 3.5.0. The results are the same.

Below is a simple file to repro the issue.
``</Description>
  </Issue>
  <Issue>
    <IssueID>1904</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>1904</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Add .NET Standard 1.6 Dependencies to the Nuspec Files</Title>
    <CreatedDate>17/11/2016</CreatedDate>
    <ClosedDate>01/12/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1904</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>1904</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:critical</Name>
        <IssueID>1904</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I just noticed that I didn't add a dependency on the .NET Standard libraries to the Nuspec files for the .NET Standard version of NUnit and NUnitLite.

Probably something like,

``</Description>
  </Issue>
  <Issue>
    <IssueID>1903</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Support predicate type argument for TestCaseData Returns property</Title>
    <CreatedDate>16/11/2016</CreatedDate>
    <ClosedDate>16/11/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>1903</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:idea</Name>
        <IssueID>1903</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I have been trying to find a way to get Returns to support a condition, rather than an absolute value in my TestCaseData factory.
As opposed to setting say `.Returns(10)` (its current format), i would like to be able to say: `.Returns(x=&gt;x &gt; 5)`. 
The scenario I have is that I do not care what number is returned, as long as the number is greater than 0. I am trying not to use multiple tests because I don't think i should have to as the test is doing the same thing. I have tried to find a way round it but unable to.</Description>
  </Issue>
  <Issue>
    <IssueID>1902</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Unable to get property on a test's class when properties are specified on a test within the class.</Title>
    <CreatedDate>14/11/2016</CreatedDate>
    <ClosedDate>01/12/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:duplicate</Name>
        <IssueID>1902</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I have a class\test that looks like below, but when I go to read the Properties of the Test via it's context, i'm only given the "Retry" property when I was hoping to see the Category that was specified at the class level as well.  I've figured out that if I remove the Retry property from the test that I'm then able to see the Category from the class decorator. So it appears that the properties are being overwritten by the ones specified at the test level instead of "added" to a list of properties from both the class and test?

    [TestFixture]
    [Category("SmokeTest")]
    public class LoginTests
    {
        [Test]
        [Retry(2)]
        public void UserCanLogIn()
        {
              // Test Guts in here...
        }
    }

c# code to get category - returns null reference error instead of "SmokeTest"
string categoryName = TestContext.Test.Properties.Get("Category").ToString();</Description>
  </Issue>
  <Issue>
    <IssueID>1900</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Do not add failed tests to Test Result XML</Title>
    <CreatedDate>11/11/2016</CreatedDate>
    <ClosedDate>11/11/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:wontfix</Name>
        <IssueID>1900</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Below is my call to Nunit3 tests in MSBUILD 
**_&lt;NUnit3 ContinueOnError="WarnAndContinue"  Workers="1"  TextOutputFile ="E:\Logs\tests\TestResult.txt" OutputXmlFile="$(ProjectTestDir)\TestResults.xml;format=nunit2"
           Assemblies="@(TestAssemblies)"  Process="Single" ToolPath="$(NUnit3Dir)" Where="cat == Sequential"  /&gt;_**

As I'm using ContinueOnError="WarnAndContinue" feature, I want my build to progress even if some tests break, which is working fine. However, the issue I'm facing is the failed tests are added to TestResults.xml. 

So my requirement is Exclude the failed tests from TestResult.xml 
</Description>
  </Issue>
  <Issue>
    <IssueID>1899</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>jnm2</FixedById>
        <IssueID>1899</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Constraint Throws.Exception does not catch exception with async lambdas</Title>
    <CreatedDate>10/11/2016</CreatedDate>
    <ClosedDate>10/11/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1899</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>1899</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>1899</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>CSharp
namespace Tests
{
	using System;
	using System.Threading;
	using System.Threading.Tasks;
	using NUnit.Framework;

	[TestFixture]
	public class Test_Throw_Exception
	{

		[Test]
		public void Test_Blocking()
		{
			Assert.That(() =&gt; { Thread.Sleep(1000); throw new Exception("KAPOW"); }, Throws.Exception);
			// =&gt; PASS
		}

		[Test]
		public async Task Test_Async_1()
		{
			Assert.That(async () =&gt; { await Task.Delay(1000); throw new Exception("KAPOW"); }, Throws.Exception);
			// =&gt; will throw
		}

		[Test]
		public async Task Test_Async_2()
		{
			Assert.That(async () =&gt; { await Task.Delay(1000); throw new Exception("KAPOW"); }, Throws.Exception.TypeOf(typeof(Exception)));
			// =&gt; PASS
		}

	}
}


With NUnit 2.6.4, all three test cases pass.

With NUnit 3.5.0, tests `Test_Blocking` and `Test_Async_2` pass, but test `Test_Async_1` fails with the following output:

Test 'Tests.Test_Throw_Exception.Test_Async_1' failed: System.Exception : KAPOW
	Project\Test.cs(310,0): at Tests.Test_Throw_Exception.&lt;&gt;c.&lt;&lt;Test_Async_1&gt;b__1_0&gt;d.MoveNext()
	--- End of stack trace from previous location where exception was thrown ---
	at NUnit.Framework.Internal.ExceptionHelper.Rethrow(Exception exception)
	at NUnit.Framework.Internal.AsyncInvocationRegion.AsyncTaskInvocationRegion.WaitForPendingOperationsToComplete(Object invocationResult)
	at NUnit.Framework.Constraints.Constraint.ApplyTo[TActual](ActualValueDelegate`1 del)
	at NUnit.Framework.Assert.That[TActual](ActualValueDelegate`1 del, IResolveConstraint expr, String message, Object[] args)
	at NUnit.Framework.Assert.That[TActual](ActualValueDelegate`1 del, IResolveConstraint expr)
	Project\Test.cs(310,0): at Tests.Test_Throw_Exception.&lt;Test_Async_1&gt;d__1.MoveNext()
	--- End of stack trace from previous location where exception was thrown ---
	at NUnit.Framework.Internal.ExceptionHelper.Rethrow(Exception exception)
	at NUnit.Framework.Internal.AsyncInvocationRegion.AsyncTaskInvocationRegion.WaitForPendingOperationsToComplete(Object invocationResult)
	at NUnit.Framework.Internal.Commands.TestMethodCommand.RunAsyncTestMethod(TestExecutionContext context)

0 passed, 1 failed, 0 skipped, took 1,95 seconds (NUnit 3.5.0).
`</Code>
    <Description>After converting tests from NUnit 2.6.4 to 3.5.0, a few of them starting failing for no reason. After a quick diagnostic, all of them use the constraint `Throws.Exception` with an async lambda (don't care about the actual exception type, just checking that it fails on invalid input).

The behavior is that the test case fails by throwing the actual Exception, instead of catching it.

I have other places that use `Throws.Exception` with regular non-async lambda, and all of them work as intended.

Finally, I noticed that if I replace `Throws.Exception` with `Throws.Exception.TypeOf(...)` then the test pass properly with async lambdas.

Simple repro here:
``

Tested with Resharper, TestDriven.net and NUnit.ConsoleRunner.3.5.0 package, under VS2015</Description>
  </Issue>
  <Issue>
    <IssueID>1897</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>tenwit</FixedById>
        <IssueID>1897</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>EqualTo().Using() prevents caller from comparing strings to anything else</Title>
    <CreatedDate>09/11/2016</CreatedDate>
    <ClosedDate>07/09/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>1897</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>1897</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Given a suitable `DateTimeComparer` class that converts `IConvertible` objects to `DateTime`, I expect this code to not throw an assertion:
``
But it does, because `Using(DateTimeCompare.Instance)`  returns either a `ComparerAdapter` or an `EqualityComparerAdapter`, neither of which override the default implementation of `CanCompare`.

Since the person writing the test is taking responsibility for comparing the actual and expected values (due to calling `Using`), `CanCompare` should always return `true` for any `ExternalComparer` added when calling `Using`.

The original issue and MCVE is described at [Stackoverflow](</Description>
  </Issue>
  <Issue>
    <IssueID>1896</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Test has passed however Reason with an empty message is printed in the xml</Title>
    <CreatedDate>09/11/2016</CreatedDate>
    <ClosedDate>23/01/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1896</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>good first issue</Name>
        <IssueID>1896</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>1896</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:low</Name>
        <IssueID>1896</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>``

This when imported into TeamCity reports a failure</Description>
  </Issue>
  <Issue>
    <IssueID>1895</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>LogicalCallContext lost with async SetUp methods</Title>
    <CreatedDate>09/11/2016</CreatedDate>
    <ClosedDate>28/04/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>1895</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>In NUnit 3.5.0 running on .NET 4.5: The logical call context set during async SetUp methods is lost when running tests. See the following failing unit test `PreservesLogicalCallContextOnAsyncSetUp`. Note that `PreservesLogicalCallContextOnSyncSetUp` works without problems.

    [TestFixture]
    public class LogicalCallContextTest
    {
      [SetUp]
      public void SyncSetUp()
      {
        CallContext.LogicalSetData ("MySyncKey", 123);
      }

      [SetUp]
      public async Task AsyncSetUp ()
      {
        CallContext.LogicalSetData ("MyAsyncKey", 456);
      }

      [Test]
      public void PreservesLogicalCallContextOnSyncSetUp ()
      {
        var data = CallContext.LogicalGetData ("MySyncKey");
        Assert.That (data, Is.EqualTo (123));
      }

      [Test]
      public void PreservesLogicalCallContextOnAsyncSetUp ()
      {
        var data = CallContext.LogicalGetData ("MyAsyncKey");
        Assert.That (data, Is.EqualTo (456));
      }
    }</Description>
  </Issue>
  <Issue>
    <IssueID>1893</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Cannot load configuration file</Title>
    <CreatedDate>08/11/2016</CreatedDate>
    <ClosedDate>05/12/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:duplicate</Name>
        <IssueID>1893</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>confirm</Name>
        <IssueID>1893</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>1893</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>1893</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I am trying to get nunit3-console.exe to load a specific configuration file as described here:  The idea is to use on single config file for many assemblies through the use of a .nunit project file.

I have "ServerTests.nunit" and "ServerTests.nunit.config" and the console runner is started as:

    nunit3-console.exe ServerTests.nunit

or

    nunit3-console.exe /process:Separate /domain:Single ServerTests.nunit

But apparently it is not loading the ServerTests.nunit.config file in any way. What could be wrong?</Description>
  </Issue>
  <Issue>
    <IssueID>1891</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>1891</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>TestContext.Progress and TestContext.Error silently drop text that is not properly XML encoded</Title>
    <CreatedDate>07/11/2016</CreatedDate>
    <ClosedDate>08/11/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1891</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>1891</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>1891</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I upgraded my test cases from NUnit 2.x to 3.x and replaced all occurrences of `Console.WriteLine(...)` to use either `TestContext.Out`, `TestContext.Error` or `TestContext.Progress`. After doing this, I started to see random parts of the test output missing.

After some investigation, I found that both `TestContext.Progress` and `TestContext.Error` do not work well with text that is not properly encoded XML.

Using NUnit 3.5, the following test only outputs the 1st and last line, because the 2nd and 3rd lines contain `&lt;` and `&amp;` that are not valid XML tokens (while `&gt;` is allowed)
``

This would explain the issue above, and also would be open to abuse if someone would do something like `TestContext.Progress.WriteLine("&lt;/&lt;test-output&gt;&lt;!--");`. The `Stream` and `TestName` values should probably also be XML encoded, though in this case I would think they are safe (unless a C# method name can contain characters that require XML encoding?)

My guess is that the receiving end of the event will fail to decode the XML fragment, and silently drop the XmlException, hence not seeing anything in the output.

Side question: maybe if an instance of `TestOutput` is created for each line written, it should be a `struct` instead of a `class`, to recuce GC overhead?</Description>
  </Issue>
  <Issue>
    <IssueID>1889</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>1889</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Modify nunitlite to display multiple assert information</Title>
    <CreatedDate>06/11/2016</CreatedDate>
    <ClosedDate>08/11/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1889</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>1889</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>1889</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Currently, the nunitlite runner uses the single failure message created for compatibility in order to display the result of a test using multiple asserts. It should use the actual result of each assert to display both the message and stack frame.</Description>
  </Issue>
  <Issue>
    <IssueID>1886</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Support TestContext.Parameters.Get&lt;xxx[]&gt; ()</Title>
    <CreatedDate>04/11/2016</CreatedDate>
    <ClosedDate>24/07/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:wontfix</Name>
        <IssueID>1886</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I recently had occasion to want to pass an array of integers as a test parameter.

There is no problem doing so on the command line (--p:par1=1,2,3,4).

However, I then had to manually parse and convert that to an array of integers in the test.

Since Parameters.Get&lt;&gt; already knows how to do conversions to the requested type, it would be useful if that could be extended to allow Get&lt;xxx[]&gt;, which would return an array of the specified type.</Description>
  </Issue>
  <Issue>
    <IssueID>1885</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>jnm2</FixedById>
        <IssueID>1885</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Test parameter containing a semicolon</Title>
    <CreatedDate>04/11/2016</CreatedDate>
    <ClosedDate>18/05/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>Epic</Name>
        <IssueID>1885</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>good first issue</Name>
        <IssueID>1885</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>1885</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>1885</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Currently, the --p (--params) command line option uses the semi-colon as a separator.  This makes it difficult to have a parameter containing a semi-colon,

I thought that using multiple --p option would work, but internally, all of the parameters are still  concatenated together using a semi-colon as a separator.

The external interface should not be changed.  However, the internal format (used to pass the option from the command line to the builder needs to be changed to use non-inputtable character as the separator.  Perhaps a null should be used?  Alternatively, since the options value is an object, the parameters could be passed as an array of strings?

Not sure why the decision was made to simple concatenate all the parameters separated by semicolons was made in the first place? </Description>
  </Issue>
  <Issue>
    <IssueID>1881</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Data type conversion</Title>
    <CreatedDate>04/11/2016</CreatedDate>
    <ClosedDate>18/05/2020</ClosedDate>
    <IssueLabels />
    <Description>In many places, the Convert.ChangeType method is used to convert the type of an object to a desired type.

This works fine for the base types (Boolean, Char, SByte, Byte, Int16, Int32, Int64, UInt16, UInt32, UInt64, Single, Double, Decimal, DateTime and String) and for user-defined types that implement IConvertible.

However, for all other types, a TypeConverter needs to be used.

NUnit currently does not use the TypeConverter class anywhere.

It would seem useful to add support for TypeConverter in some of these conversion instances.  For instance, the ValuesAttribute would be seemingly be enhanced by doing so.</Description>
  </Issue>
  <Issue>
    <IssueID>1880</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>1880</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>AttributeUsage for various Attributes</Title>
    <CreatedDate>03/11/2016</CreatedDate>
    <ClosedDate>07/01/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1880</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>1880</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>1880</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I have noticed that many the attributes do not have the AttributeUsageAttribute applies to them.

For instance, the RandomAttribute, which only applies to a parameter, is not constrained by an AttributeUsageAttribute with a AttributeTargets.Parameter flag set.

It seems like it should be.

I have not examined all of the attributes, but there may be others that are not constrained that should be.</Description>
  </Issue>
  <Issue>
    <IssueID>1877</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>1877</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Resolve differences between NUnit Console and NUnitLite implementations of @filename</Title>
    <CreatedDate>01/11/2016</CreatedDate>
    <ClosedDate>24/04/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1877</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:feature</Name>
        <IssueID>1877</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>1877</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>We (well actually I) mistakenly merged the nunitlite changes thinking that the differences between the console runner and nunitlite implementations had already been resolved between @NikolayPianikov and @oznetmaster 

We need to decide first what features to include / exclude then change one or both of them so that users do not get confused and features we have not decided to support do not become supported by default.

Eventually, we should also resolve code differences for the common features but that can await the point where we create a shared codebase for conmmand-line option processing.

I'm putting this in the discussion pipeline so that the NUnit team can work out what we want to support. Everyone else is welcome to participate in the discussion as well.</Description>
  </Issue>
  <Issue>
    <IssueID>1876</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>1876</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>What should we do about Env.cs</Title>
    <CreatedDate>01/11/2016</CreatedDate>
    <ClosedDate>02/11/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1876</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>good first issue</Name>
        <IssueID>1876</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:refactor</Name>
        <IssueID>1876</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:low</Name>
        <IssueID>1876</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Now that we no longer have CF and Silverlight integrated, Env.cs is no longer doing much. It defines:

* **Newline** which is always equal to `Environment.Newline`

* **DocumentFolder** which maps to `\MyDocuments` in portable and to the special documents folder in all other builds.

* **DefaultWorkDirectory** which maps to DocumentFolder in portable and to `Environment.CurrentDirectory` in other builds.

In the case of NewLine, we are already somewhat inconsistent. There are 24 references to both Env and Environment scattered around. The other two are referenced, respectively, zero and 3 times!

Options: 
* Leave file as is
* Remove Env.NewLine
* Remove file entirely</Description>
  </Issue>
  <Issue>
    <IssueID>1874</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Build fails when targeting .net 4.0, profile=client</Title>
    <CreatedDate>30/10/2016</CreatedDate>
    <ClosedDate>02/12/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:wontfix</Name>
        <IssueID>1874</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I have an assembly foo.dll which is  .net 4.0, profile=client, and foo.tests.dll which has same target framework.When I'm trying to build solution, there is a warning and build errors.![nunit_clientprofile](If set full .net4.0 for foo.tests.dll, then build works fine.Does it mean that test assemblies no more support v4.0, profile=client?</Description>
  </Issue>
  <Issue>
    <IssueID>1872</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>1872</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Parameterized method being called with no parameter</Title>
    <CreatedDate>30/10/2016</CreatedDate>
    <ClosedDate>06/11/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1872</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>1872</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:low</Name>
        <IssueID>1872</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>``It appears that an extra call to the parameterized method is being generated that uses no parameters.</Description>
  </Issue>
  <Issue>
    <IssueID>1870</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>Corniel</FixedById>
        <IssueID>1870</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>EqualConstraint result failure message for DateTime doesn't show sufficient resolution</Title>
    <CreatedDate>28/10/2016</CreatedDate>
    <ClosedDate>29/10/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1870</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>good first issue</Name>
        <IssueID>1870</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>1870</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:low</Name>
        <IssueID>1870</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>As reported on PR #1868 the failure message does not show ticks, which may cause the two values to be displayed the same even though they are not equal. We should use 'F' rather than 'f' in the format string.</Description>
  </Issue>
  <Issue>
    <IssueID>1867</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>pnunit test framework</Title>
    <CreatedDate>25/10/2016</CreatedDate>
    <ClosedDate>01/12/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>1867</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Hi,I got a project which used pnunit test for testing.  This is part of nunit binaries in 2.6.+.zip.  But I cannot find it in 3.+.  Does anyone know what happens to it?Also, in the current 2.6.+ version, I notice a problem. Say two pnunit-agents are launched, and punit-launcher executes test.  One of the pnunit-agent gets tests and executes fine, but the other one get stuck at PNUnit.Agent.PNUnitTestRunner - Entering MakeTest.Strange thing is, if the first instance of the punit-agent is killed, then the second punit-agent starts executing.  Has anyone seen this or better, known any workaround to this?Thank youYang</Description>
  </Issue>
  <Issue>
    <IssueID>1866</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>1866</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
      <IssueAssignee>
        <FixedById>rvignesh89</FixedById>
        <IssueID>1866</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>[Request] More readable way to set polling interval in After constraint</Title>
    <CreatedDate>25/10/2016</CreatedDate>
    <ClosedDate>08/11/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1866</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>1866</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>1866</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>This issue is a follow up of #1837 (originally requested by @mbendtsen ) to work on improving the readability of setting a polling interval in the After constraint. </Description>
  </Issue>
  <Issue>
    <IssueID>1861</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Wrapping MethodInfo.Invoke or improving TestCommand wrappers</Title>
    <CreatedDate>24/10/2016</CreatedDate>
    <ClosedDate>08/08/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>1861</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Hi! First of all, great job with the product and the recent changes to the architecture. I was able to use extension points to achieve most things I needed for implementing nUnit in the tools I'm working on besides few small things. What I would like to achieve is to delegate the test's code invocation to a separate thread that I have control of (not just to spawn on a separate thread). In most places (besides TestMethodCommand) the invocation happpens via the Reflect class. Luckily the I was able to wrap the TestMethodCommand command without a problem but I couldn't find a soution for doing it globally or for the other points the Reflect.InvokeMethod method is used (like SetUpTearDownCommand). My solution was to introduce a global delegate field in Reflect that could be set before the run happens. Then, the method.Invoke in Reflect.InvokeMethod would be passed to the delegate if it's set. ``It's not the nicest solution but it was simple. Ideallly I would like to do it via wrappers or extension point but the IWrapTestMethod is flexible enough. What would be the best approach in your eyes for solving this problem so I could eventually make PR?Tomek</Description>
  </Issue>
  <Issue>
    <IssueID>1859</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>ConcurrentQueue is duplicate with System.Threading.dll package</Title>
    <CreatedDate>24/10/2016</CreatedDate>
    <ClosedDate>05/04/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>good first issue</Name>
        <IssueID>1859</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>1859</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:low</Name>
        <IssueID>1859</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Make .NET 3.5 project.Install both NUnit package and System.Threading.dll package (System.Collections.Concurrent.ConcurrentQueue defined in both assemblies.</Description>
  </Issue>
  <Issue>
    <IssueID>1858</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>1858</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>build -testall</Title>
    <CreatedDate>24/10/2016</CreatedDate>
    <ClosedDate>25/10/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>1858</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:build</Name>
        <IssueID>1858</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:low</Name>
        <IssueID>1858</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>this seems to only build everything now :(how do I build and then test everything in one command?</Description>
  </Issue>
  <Issue>
    <IssueID>1856</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Define TestCaseSource equivalent that does not give an error when there is no data</Title>
    <CreatedDate>21/10/2016</CreatedDate>
    <ClosedDate>18/05/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:idea</Name>
        <IssueID>1856</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code> csharp
public static readonly List&lt;ControllerMethodPair&gt; TemporaryExemptionsList = new List&lt;ControllerMethodPair&gt; {
                // This list is empty. To add a temporary exemption, use the syntax:
                // new ControllerMethodPair(typeof(ControllerName), nameof(ControllerName.MethodName))
            };

- Write a test that uses the list as a source, e.g. below:

 csharp
        [TestCaseSource(typeof(ControllerActionPermissions_TestCaseSources), nameof(ControllerActionPermissions_TestCaseSources.TemporaryExemptionsList))]
        public void TemporaryExemptionListItemsShouldNotHaveAPermanentExemption(ControllerMethodPair pairToTest)
        {
            SecurityTestHelper.HasPermanentExemption(pairToTest).Should().BeFalse("The controller {0}.{1} is in the temporary list but also has a permanent exemption. Please ensure only one of these is the case", pairToTest.Controller.Name, pairToTest.MethodName);
        }
`</Code>
    <Description>Hi all,Thank you for a fantastic product that keeps our codebase in shape.I am in the process of trying to confirm whether the "issue" I'm seeing is:- A misunderstanding of NUnit on my part (expectation is wrong)- A difference in the way test runners treat this scenario - An issue with how NUnit services results in this issue.## Background- I have a `TestCaseSource` that houses the concept of a temporary exemption (when testing some security rules). - When an item is in the temporary exemption list, certain rules / tests apply. - Occasionally, the temporary exemptions lists are empty, leading to what I describe below.## Reproduction steps- Create a `TestCaseSource` similar to the following (the `ControllerMethodPair` class is mine; substitute any POCO): ``- Run the tests when the temporary exemptions list is empty.## Expected ResultThe tests run and are ignored by my test runner, or given an "inconclusive" label of some kind.## Actual ResultI see -- at least in ReSharper's test runner -- that the tests fail. See the screenshot below:![image](This makes sense in a way, but I saw it more as a warning and less as a failure.Is this something I'm missing as to how NUnit works? Or a potential issue with the test runner itself?I'll look at this in the console runner as well but wanted to put it out there in the meantime.Thanks!</Description>
  </Issue>
  <Issue>
    <IssueID>1854</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>No .msi provided for 3.5</Title>
    <CreatedDate>19/10/2016</CreatedDate>
    <ClosedDate>19/10/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1854</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>1854</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Despite [mention]( of an .msi containing the binaries in the wiki,&gt; This is also the first release where the NUnit Framework will not be included in the installer. Only&gt; the console runner, engine and extensions will be available as an MSI installer. no such file appears to be available for download.</Description>
  </Issue>
  <Issue>
    <IssueID>1853</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Nunit test runner picking up ignored tests (ish) in tfs</Title>
    <CreatedDate>19/10/2016</CreatedDate>
    <ClosedDate>19/10/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:duplicate</Name>
        <IssueID>1853</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Hi,I'm running tests in TFS using the NUnit3TestAdapter nuget package. We have a test fixture that is completely ignored at the class level. We are getting error messages in the output saying: `The specified test case was not found in the current result context (mapping test id to test node).` I can't find any information in the documentation to say that this is not supported and it indeed has been in previous versions of NUnit but I can't explain why this error would happen after the upgrade to the new runner.It should be noted that I don't see this error when running the tests within either Visual Studio, NCrunch or Resharper.This seems to be similar but different to the following issue: #427If anyone can shed any light on this, I would greatly appreciate it.</Description>
  </Issue>
  <Issue>
    <IssueID>1852</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Retrieving a random sample of data from TestCaseSource in NUnit 3.0 attribute doesn't work?</Title>
    <CreatedDate>19/10/2016</CreatedDate>
    <ClosedDate>19/10/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:duplicate</Name>
        <IssueID>1852</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>
        [Test, TestCaseSource(nameof(GetSmallSampleSizeOfTestDataForScratchwork))]
    public void TestMe(string accessionNumber, string loginId)
    {
        var studentAssessmentPage = OpenAdminResetPageAndGoToBookletLocation(accessionNumber, loginId);
        studentAssessmentPage.OpenScratchworkTool();
        Assert.IsTrue(studentAssessmentPage.IsScratchworkToolOpen(), "The scratchwork tool did not open succesfully.");
    }


The implementation of GetSmallSampleSizeOfTestDataForScratchwork() doesn't run any tests whenever I try to execute the test. Even though in debug mode it works as expected.


protected static IEnumerable&lt;string[]&gt; GetSmallSampleSizeOfTestDataForScratchwork()
    {
        var filePath = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);
        filePath = Path.GetFullPath(filePath + @"\TestData\TestData.csv");

        using (var sr = new StreamReader(filePath))
        {
            var reader = new CsvReader(sr);
            IEnumerable&lt;CsvRecord&gt; records = reader.GetRecords&lt;CsvRecord&gt;().OrderBy(x =&gt; Guid.NewGuid());

            foreach (var record in records.Take(10))
            {
                string column1 = record.AccessionNumber;
                string column2 = record.LoginId;
                yield return new[] { column1, column2 };
            }
        }
    }


However, this implementation works just fine and runs all of the tests without a problem.


        protected static IEnumerable&lt;string[]&gt; GetAllTestDataForScratchwork()
    {
        var filePath = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);
        filePath = Path.GetFullPath(filePath + @"\TestData\TestData.csv");

        using (var sr = new StreamReader(filePath))
        {
            var reader = new CsvReader(sr);
            IEnumerable&lt;CsvRecord&gt; records = reader.GetRecords&lt;CsvRecord&gt;();

            foreach (var record in records)
            {
                string column1 = record.AccessionNumber;
                string column2 = record.LoginId;
                yield return new[] { column1, column2 };
            }
        }
    }
`</Code>
    <Description>I'm having a strange issue utilizing this combination of technologies: - Nunit(3.4.1.0)- NUnit 3 Visual Studio Test Adapter- TestCaseSource attributeMy test uses the attribute like this:``The only difference between these 2 methods are that 1 returns a random subset of data and the other returns all of the data. **Therefore, why is it that GetAllTestDataForScratchwork() works just fine when I execute the tests and GetSmallSampleSizeOfTestDataForScratchwork() doesn't run a single test?**</Description>
  </Issue>
  <Issue>
    <IssueID>1851</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>StanEgo</FixedById>
        <IssueID>1851</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>TestCaseSource unable to pass one element byte array</Title>
    <CreatedDate>18/10/2016</CreatedDate>
    <ClosedDate>12/07/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1851</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>1851</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>**NUnit version:**  3.5.0**Runner**: NUnit3TestAdapter 3.4.1**Environment**: Visual Studio 2015 Pro Update 1I'm having troubles using one element byte array passed to NUnit test with `TestCaseSourceAttribute`.How to reproduce:``When you run `TestStuff` it will attempt to test things in seperate tests like this:![nunit](It clearly seems that first element is treated as an `System.Byte` instead of `System.Byte[]`.Error produced by NUnit tells it clearly:&gt; Result Message:System.ArgumentException : Object of type 'System.Byte' cannot be converted to type 'System.Byte[]'Any ideas on fixing this?Thanks!</Description>
  </Issue>
  <Issue>
    <IssueID>1849</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Dll has no TestFixtures</Title>
    <CreatedDate>17/10/2016</CreatedDate>
    <ClosedDate>18/10/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>1849</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>
"C:\dev-tools\NUnit-3.5.0\bin\net-4.5\nunitlite-runner.exe" cs-money.dll
NUnitLite 3.5.0 (.NET 4.5)
Copyright (C) 2016 Charlie Poole

Runtime Environment
   OS Version: Microsoft Windows NT 6.2.9200.0
  CLR Version: 4.0.30319.42000

Test Files
    cs-money.dll

Errors and Failures

1) Invalid : C:/temp/nunit-csharp-samples-master/money/bin/Debug/cs-money.dll
Has no TestFixtures

Run Settings
    Number of Test Workers: 8
    Work Directory: C:\temp\nunit-csharp-samples-master\money\bin\Debug
    Internal Trace: Off

Test Run Summary
  Overall result: Failed
  Test Count: 0, Passed: 0, Failed: 0, Inconclusive: 0, Skipped: 0
  Start time: 2016-10-17 21:42:36Z
    End time: 2016-10-17 21:42:36Z
    Duration: 0.005 seconds

1. Download 3.4.1 zip from https://github.com/nunit/nunit/releases/3.4.1 and run:


"C:\dev-tools\NUnit-3.4.1\bin\net-4.5\nunitlite-runner.exe" cs-money.dll
NUnitLite 3.4.1 (.NET 4.5)
Copyright (C) 2016 Charlie Poole

Runtime Environment
   OS Version: Microsoft Windows NT 6.2.9200.0
  CLR Version: 4.0.30319.42000

Test Files
    cs-money.dll

Run Settings
    Number of Test Workers: 8
    Work Directory: C:\temp\nunit-csharp-samples-master\money\bin\Debug
    Internal Trace: Off

Test Run Summary
  Overall result: Passed
  Test Count: 21, Passed: 21, Failed: 0, Inconclusive: 0, Skipped: 0
  Start time: 2016-10-17 21:44:49Z
    End time: 2016-10-17 21:44:49Z
    Duration: 0.113 seconds
`</Code>
    <Description>This works in 3.4.1 but not 3.51. Clone project 2. Open in VS, build, run tests = OK3. Download nunit 3.5 zip from 4. Run tests``To me this looks like a bug. Nothing in the documentation/change list suggests that the framework has changed; if extra packages are required in order to detect tests from the command line, it should be mentioned in the release notes.</Description>
  </Issue>
  <Issue>
    <IssueID>1844</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>NonGeneric TestFixtures derived from generic TestFixture does not work</Title>
    <CreatedDate>14/10/2016</CreatedDate>
    <ClosedDate>14/10/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:norepro</Name>
        <IssueID>1844</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Hi, the following code does not work as I expectedGiven a base abstract test``Neither base or derived tests appears in the runner, tested with vs runner and nunit-gui , if I remove the attributes in the base class then the derived tests appears.I think this is an issue or I'm missing somethingThanks for the great work</Description>
  </Issue>
  <Issue>
    <IssueID>1843</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Get the time duration of a Test Script in Test TearDown</Title>
    <CreatedDate>14/10/2016</CreatedDate>
    <ClosedDate>14/10/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>1843</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Steps to reproduce:1. Run a test script2. Try to capture the Test duration in **TestScript TearDown** using TestExecutionContext.CurrentContext.CurrentResult(Return type of this object is TestResult) object.Expected: It should show the actual time take to execute a test script.Actual: It is showing the time duration as '0' ms  irrespective of time taken to run the tests.Note: If we use the same object TestExecutionContext.CurrentContext.CurrentResult in **AssemblyCleanup(TestRun TearDown)**, then it is displaying the Time taken to execute a test script. </Description>
  </Issue>
  <Issue>
    <IssueID>1063</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>1063</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Error in Random Test</Title>
    <CreatedDate>24/11/2015</CreatedDate>
    <ClosedDate>26/11/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1063</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>good first issue</Name>
        <IssueID>1063</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>1063</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:low</Name>
        <IssueID>1063</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>The following faiure showed up in one of our Travis CI runs:``We should check the random algorithms for each Type to verify whether a zero value is possible and make sure the tests allow for it correctly.</Description>
  </Issue>
  <Issue>
    <IssueID>1062</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>1062</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Console.WriteLine statements int "OneTimeSetUp" and "OneTimeTearDown" annotated methods are not directed to the console when using nunit3-console.exe runner</Title>
    <CreatedDate>23/11/2015</CreatedDate>
    <ClosedDate>30/11/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1062</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>1062</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>1062</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code> csharp
    [TestFixture]
    public class TestClass
    {
        [OneTimeSetUp]
        public void FixtureSetup ()
        {
            Console.WriteLine ("FixSetUp");
        }

        [SetUp]
        public void SetUp ()
        {
            Console.WriteLine ("SetUp");
        }

        [TearDown]
        public void TearDown ()
        {
            Console.WriteLine ("TearDown");
        }

        [OneTimeTearDown]
        public void FixtureTearDown ()
        {
            Console.WriteLine ("FixTearDown");
        }

        [Test]
        public void Test ()
        {
            Console.WriteLine ("Test");
        }
    }


It would be expected that `Console.WriteLine ("FixSetUp");` and `Console.WriteLine ("FixTearDown");` are correctly printed to the console. However the actual output is as follows:


NUnit Console Runner 3.0.5797 
Copyright (C) 2015 Charlie Poole

Runtime Environment
   OS Version: MacOSX 15.0.0.0 
  CLR Version: 4.0.30319.17020

Test Files
    bin/Debug/XQA.XS.Tests.dll

Test Filters
    Test: XQA.XS.Tests.TestClass.Test

=&gt; XQA.XS.Tests.TestClass.Test
SetUp
Test
TearDown

Run Settings
    WorkDirectory: &lt;omitted&gt;
    NumberOfTestWorkers: 4

Test Run Summary
    Overall result: Passed
   Tests run: 1, Passed: 1, Errors: 0, Failures: 0, Inconclusive: 0
     Not run: 0, Invalid: 0, Ignored: 0, Explicit: 0, Skipped: 0
  Start time: 2015-11-23 20:02:32Z
    End time: 2015-11-23 20:02:32Z
    Duration: 0.063 seconds

Results (nunit3) saved as TestResult.xml
`</Code>
    <Description>Given this test fixture: ``Notice there is no appearance of "FixSetUp" or "FixTearDown" - this is a major issue for build systems that rely on Console output to trigger events (such as the [mono build system](Thanks!</Description>
    <PullRequests />
  </Issue>
  <Issue>
    <IssueID>1061</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>1061</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Nunit30Settings.xml becomes corrupted</Title>
    <CreatedDate>23/11/2015</CreatedDate>
    <ClosedDate>28/11/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1061</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>good first issue</Name>
        <IssueID>1061</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>1061</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>1061</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>While trying to update a project with some failing tests (using NUnitForms), in some cases Nunit30Settings.xml becomes corrupted and is filled with a bunch of "nul"s, which, on the next run of nunit3-console results in the following exception:``As a workaround, one can delete this file, but it is pretty annoying and most importantly it wasn't clear what settings file it was referring to in the first place.</Description>
    <PullRequests />
  </Issue>
  <Issue>
    <IssueID>1060</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>1060</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Remove "Version 3" from NUnit Nuget Package</Title>
    <CreatedDate>23/11/2015</CreatedDate>
    <ClosedDate>25/11/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1060</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>1060</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>1060</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>The title in NuGet shows up as NUnit Version 3 3.0.0 which is redundant and confuses some users looking for 2.6.4.</Description>
  </Issue>
  <Issue>
    <IssueID>1058</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>After version 2.6.1 Remoting client crashes</Title>
    <CreatedDate>23/11/2015</CreatedDate>
    <ClosedDate>04/02/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:norepro</Name>
        <IssueID>1058</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I have tests for a legacy service called via Remoting. After I upgraded NUnit calls to the remote object fail:``I have created [a Gist demonstrating the issue](</Description>
  </Issue>
  <Issue>
    <IssueID>1057</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Does.Contain always passes</Title>
    <CreatedDate>23/11/2015</CreatedDate>
    <ClosedDate>07/12/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>1057</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code> c#
[Test]
public void Test() {
    var address = "https://gist.githubusercontent.com/lbergnehr/56c355d41454855c25a4/raw/f4b95565a2330b695021c3d4b4fb55ff40aa4923/nunit_string_contains_test";
    var result = new System.Net.WebClient().DownloadString(address);
    Assert.That(result, Does.Contain(Guid.NewGuid().ToString()));
}
`</Code>
    <Description>This test always passes for me:``It appears that for some type of strings, `Does.Contain` and other string constraints always gives a pass when they should definitely fail. In the above example, the assert is comparing to a new `Guid` in each test which means the test should never pass.</Description>
  </Issue>
  <Issue>
    <IssueID>1055</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>1055</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>nunit3 console runner --where option does not return error on invalid selection string</Title>
    <CreatedDate>20/11/2015</CreatedDate>
    <ClosedDate>28/11/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1055</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>1055</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>1055</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>The nunit3 console runner --where option does not return an error on an invalid selection string.For a while I was trying to use the following selection string:--where "cat == Pri1 AND cat != WIP"This selection string was not properly filtering out "WIP" tests and was instead just running all "Pri1" tests. After rereading the documentation it occurred to me that "AND" (with all capital letters) is not a valid logical operator in this context. Switching this out for "&amp;&amp;" or "and" results in the expected filtering.My usage of the --where option is technically incorrect, but with this incorrect usage I would have expected an error claiming that my string was not of a valid format. Instead the console runner silently continued with test execution with an incorrect subset of tests.It would also be cool if "AND" (and other similar operators with capital letters) was valid, but that's just my opinion.</Description>
    <PullRequests />
  </Issue>
  <Issue>
    <IssueID>1052</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>NUnit 3.0.0 without nunit.exe</Title>
    <CreatedDate>20/11/2015</CreatedDate>
    <ClosedDate>20/11/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>1052</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>1052</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Mrs, when I donwloaded the last version NUnit (3.0.0), I missed the file nunit.exe. Where are it in this new version?Best Guards.Thks</Description>
  </Issue>
  <Issue>
    <IssueID>1051</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>1051</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Wiki: Add TestStatus NUnit3 migration tips</Title>
    <CreatedDate>20/11/2015</CreatedDate>
    <ClosedDate>20/11/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1051</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:docs</Name>
        <IssueID>1051</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>1051</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Wiki: Please add `TestStatus` NUnit3 migration tipsFrom NUnit2``</Description>
  </Issue>
  <Issue>
    <IssueID>1049</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>1049</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Cannot select Generic tests from command line</Title>
    <CreatedDate>20/11/2015</CreatedDate>
    <ClosedDate>28/11/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1049</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>1049</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>1049</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>When running `NUnit Console Runner 3.0.5797` with a test selection that includes a generic type argument, I get and error an no tests are run:``I can't find any test cases related to parsing generic type arguments, so I don't know if this is expected behaviour.</Description>
  </Issue>
  <Issue>
    <IssueID>1048</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Tests fail in 3.0 when using NUnit Project File</Title>
    <CreatedDate>20/11/2015</CreatedDate>
    <ClosedDate>23/06/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:norepro</Name>
        <IssueID>1048</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I experiencing some problems switching from NUnit 2.6.3 to 3.0.0. We use an NUnit project file in the solution root folder to reference all the test projects.**Project Folder Structure**``While using NUnit 2.6.3 this worked like a charm. When using NUnit 3.0.0 we get a `System.IO.FileNotFoundException` because the production code project assembly `Project1.Core.dll` could not be found. It is searched in `C:\ProjectX\Project1.Core.dll` instead of `C:\ProjectX\Project1.UnitTests\bin\Debug\Project1.Core.dll`Whats different in NUnit 3.0.0?</Description>
  </Issue>
  <Issue>
    <IssueID>1047</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>1047</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Broken link on "Breaking Changes" wiki page</Title>
    <CreatedDate>20/11/2015</CreatedDate>
    <ClosedDate>20/11/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1047</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:docs</Name>
        <IssueID>1047</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>The [Breaking Changes]( page links to  which doesn't exist.It should link to  instead.</Description>
  </Issue>
  <Issue>
    <IssueID>1046</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>1046</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>FloatingPointNumerics.AreAlmostEqualUlps throws OverflowException</Title>
    <CreatedDate>20/11/2015</CreatedDate>
    <ClosedDate>30/11/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1046</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>1046</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>1046</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code> csharp
FloatingPointNumerics.AreAlmostEqualUlps(2.0, -2.0, 1);



Result StackTrace:  
at System.Math.AbsHelper(Int64 value)
   at NUnit.Framework.Constraints.FloatingPointNumerics.AreAlmostEqualUlps(Double left, Double right, Int64 maxUlps)

System.OverflowException : Negating the minimum value of a twos complement number is invalid.
`</Code>
    <Description>``Expected it to return false. </Description>
  </Issue>
  <Issue>
    <IssueID>1045</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>StackOverflowException when running tests with nunit3-console.exe</Title>
    <CreatedDate>20/11/2015</CreatedDate>
    <ClosedDate>23/06/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:norepro</Name>
        <IssueID>1045</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>My apologies in advance if this I'm missing any information here. Please let me know what I can provide to help get to the bottom of this. I am trying to use the nunin3-console.exe runner, but am receiving a stack overflow exception immediately. Interestingly, this works fine on my ElCapitan iMac.``</Description>
  </Issue>
  <Issue>
    <IssueID>1044</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Re-order Test Summary Errors/Failures</Title>
    <CreatedDate>19/11/2015</CreatedDate>
    <ClosedDate>04/12/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1044</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>good first issue</Name>
        <IssueID>1044</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>1044</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>This is a little detail that has always bugged me but I have never fixed. Our current test summary looks like this,``If we do this NUnitLite will probably need to be changed too.</Description>
  </Issue>
  <Issue>
    <IssueID>1043</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Nunit-console.exe and Nunit3-console.exe are 32-bit applications causing /process:Single to fail with 64-bit test assemblies.</Title>
    <CreatedDate>19/11/2015</CreatedDate>
    <ClosedDate>19/11/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>1043</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>When using the /process:Single command-line switch of Nunit-console.exe no nunit-agent is used. However the fact that both nunit-console.exe and nunit-console-x86.exe exist suggests that these applications are themselves 64-bit and 32-bit applications respectively. However when running a 64-bit assembly with the /process:Single switch the run fails with a BadImageFormatException. Looking at the output of dumpbin shows that both nunit-console.exe and nunit3-console.exe are actually 32-bit applications. Could they both be build as 64-bit applications?The /process:Single is handy when debugging a memory problem caused by native code that gets called while running a specific test. Now nunit-agent.exe crashes and nunit-console.exe only reports the fact that it can not reach the process .</Description>
  </Issue>
  <Issue>
    <IssueID>1042</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>1042</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>NUnit2 reports on 3.0 is different than 2.6.4</Title>
    <CreatedDate>19/11/2015</CreatedDate>
    <ClosedDate>26/11/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1042</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>1042</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>1042</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code> xml
  &lt;xsl:template match="test-case/properties"&gt;
    &lt;xsl:for-each select="property[@name!='_CATEGORIES']"&gt;
      &lt;xsl:attribute name="{@name}"&gt;
        &lt;xsl:value-of select="@value"/&gt;
      &lt;/xsl:attribute&gt;
    &lt;/xsl:for-each&gt;

    &lt;categories&gt;
      &lt;xsl:for-each select="property[@name='_CATEGORIES']"&gt;
        &lt;xsl:element name="category"&gt;
          &lt;xsl:attribute name="name"&gt;
            &lt;xsl:value-of select="@value"/&gt;
          &lt;/xsl:attribute&gt;
        &lt;/xsl:element&gt;
      &lt;/xsl:for-each&gt;
    &lt;/categories&gt;
  &lt;/xsl:template&gt;


Example:
NUnit3 repoting v2:

 xml
  &lt;test-case name="Dummy" executed="True" result="Success" success="False" time="5.823" asserts="1"&gt;
     &lt;properties&gt;
        &lt;property name="_DESCRIPTION" value="Dummy" /&gt;
        &lt;property name="_CATEGORIES" value="SmokeTest" /&gt;
      &lt;/properties&gt;


NUnit 2.6.4:

 xml
&lt;test-case name="Dummy" executed="True" result="Success" success="False" time="5.823" asserts="1" description="Dummy"&gt;
    &lt;categories&gt;
        &lt;category name="SmokeTest" &gt;
    &lt;/categories&gt;


**Update:**
     1)
     On NUnitv2 the testcase name contains the full name of the method: 'namespace'.'classname'.'methodname' on NUnitv3 reporting v2 just the method name is displayed.
      This can be fixed by changing the NUnit2XmlResultWriter.cs file at line 214 from:

 C#
xmlWriter.WriteAttributeString("name", result.GetAttribute("name"));


to

 C#
xmlWriter.WriteAttributeString("name", result.GetAttribute("fullname"));



 2)
 The NUnit version attribute on NUnitv2 shows: &lt;environment nunit-version="1.0.0.0"
 Because it is fetching the version from the addin assembly version which is 1.0.0.0
`</Code>
    <Description>NUnit.Framework.DescriptionAttribute and NUnit.Framework.CategoryAttribute are mapped under Properties xml tag. NUnit.Framework.DescriptionAttribute used to be a test-case description attribute and NUnit.Framework.CategoryAttribute used to be under Categories xml tag.This is not critical and the following xslt can be used to transform the xml``</Description>
  </Issue>
  <Issue>
    <IssueID>1041</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>1041</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>NUnit2XmlResult Writer is reporting Sucess when test fails</Title>
    <CreatedDate>19/11/2015</CreatedDate>
    <ClosedDate>28/11/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1041</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>1041</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:critical</Name>
        <IssueID>1041</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>File: nunit/src/NUnitEngine/Addins/nunit-v2-result-writer/NUnit2XmlResultWriter.cs240: if (label != null &amp;&amp; label != string.Empty)241:            resultState += ":" + label;Seems incompatible with the implementation of:244: xmlWriter.WriteAttributeString("result", TranslateResult(resultState, label));This is making a failing tests pass. e.g. resultState=='Failed', label=='Error' ===&gt; Translates to 'Success'</Description>
  </Issue>
  <Issue>
    <IssueID>1040</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Documentation: is there a default timeout for tests?</Title>
    <CreatedDate>19/11/2015</CreatedDate>
    <ClosedDate>19/11/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1040</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:docs</Name>
        <IssueID>1040</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>1040</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I looked here:and here: But what I want to know is if neither of these are specified will the test run forever, or is there a default timeout like ten minutes, or an hour? ( assuming I have a really long running test, or an infinite loop )I am not suggesting that there SHOULD be a default timeout, I just want to know what the behaviour is.</Description>
  </Issue>
  <Issue>
    <IssueID>1039</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>1039</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>NUnit 3 Console runner executes Explicit tests when filtering by category</Title>
    <CreatedDate>19/11/2015</CreatedDate>
    <ClosedDate>30/11/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:norepro</Name>
        <IssueID>1039</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>1039</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>1039</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>NUnit 3 Console runner executes Explicit tests when filtering by category.We're using NUnit3 against 2.5.9 compiled test dlls, and``but we're finding the Explicit tests are getting run.Is there a way to select or not select the Explicit tests using the Test Selection Language to prevent this?(Principle of least surprise, one would expect Explicit tests not to be run, hence raising this as an issue). </Description>
  </Issue>
  <Issue>
    <IssueID>1038</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Partition tests into groups using id  =~</Title>
    <CreatedDate>19/11/2015</CreatedDate>
    <ClosedDate>19/11/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:wontfix</Name>
        <IssueID>1038</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:feature</Name>
        <IssueID>1038</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Currently using regex (=~) with id leads to an error. For non-thread-safe codebases where test fixture parallelization will never be an option, to keep the test duration down we either have to keep splitting and re-splitting the tests into smaller dlls, or manually marking them up into different categories.Ideally we'd like to use the test selection language to 'modulus' the tests into groups. For example all tests with an odd id get run on one machine and all tests with an even id get run on another machine. I.e. we give NUnit all the test assemblies and it runs half of the tests in each of them. This would enable more parallelization as there would be more nunit-agent processes running than if half the dlls were run on one machine and half on another.At the moment it can achieved by partitioning the tests into groups via regexing on the test name, but that's likely to be more lumpy than using id. Very keen to hear suggestions on the 'right' way to partition tests without introducing additional dlls. I'm sure this will not be an uncommon use case.</Description>
  </Issue>
  <Issue>
    <IssueID>1037</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>1037</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Async tests not working on Windows 10 Universal</Title>
    <CreatedDate>18/11/2015</CreatedDate>
    <ClosedDate>25/11/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1037</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>1037</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:critical</Name>
        <IssueID>1037</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Copied from nunit/nunit.xamarin#35 reported by @tofutim. I have confirmed that this is an issue with the portable framework, so may be an issue with other platforms.From the other issueIs this a UWP, nunit, nunit.runners issue? I added this to the tests in this solution after seeing it in mine. This is a result from the UWP emulator (Windows 10 mobile) in VS2015 on Server 2012 R2.``![image](</Description>
  </Issue>
  <Issue>
    <IssueID>1036</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>1036</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>`&amp;quot;` appearing in wiki documentation</Title>
    <CreatedDate>18/11/2015</CreatedDate>
    <ClosedDate>30/11/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1036</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:docs</Name>
        <IssueID>1036</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>1036</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code> csharp
  [TestFixture]
  [Category(&amp;quot;LongRunning&amp;quot;)]
  public class LongRunningTests
  {
    // ...
  }


There are quite a few bits like this actually, e.g. `&amp;lt;` and `&amp;gt` on [Explicit Attribute](https://github.com/nunit/nunit/wiki/Explicit-Attribute):

 vb
Imports System
Imports Nunit.Framework

Namespace Nunit.Tests

  &amp;lt;TestFixture(), Explicit()&amp;gt;
  Public Class ExplicitTests
    &amp;#39; ...
  End Class
End Namespace
`</Code>
    <Description>The documentation has`&amp;quot;` a few times where there should be `"`. For example on [the Category Attribute page]( :``</Description>
  </Issue>
  <Issue>
    <IssueID>1034</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>NUnit Official website is vulnerable with HTML Injection</Title>
    <CreatedDate>18/11/2015</CreatedDate>
    <ClosedDate>15/08/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>1034</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>1034</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>i am able to inject any html code with this vulnerability on this page : the variable "p" is vulnerable .So what i can do with this ? it's easy to help me steal users cookies , by injecting an "img" tag with attribute "src" that reffer to some page i made it to steal cookies .Example :  src="some page"/&gt;</Description>
  </Issue>
  <Issue>
    <IssueID>1033</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>1033</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>"No arguments were provided" with Theory and Values combination</Title>
    <CreatedDate>18/11/2015</CreatedDate>
    <ClosedDate>30/11/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1033</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>1033</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>1033</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Having such test definition I recieve "No arguments were provided" error:``NUnit v3.0, test runner v3.</Description>
  </Issue>
  <Issue>
    <IssueID>1031</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Prerequisite Tests (Feature)</Title>
    <CreatedDate>17/11/2015</CreatedDate>
    <ClosedDate>17/11/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:duplicate</Name>
        <IssueID>1031</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>
public static class Statistics
{
    public static double Average(IEnumerable&lt;double&gt; values)
    {
        double sum = 0;
        double count = 0;
        foreach (var v in values)
        {
            sum += v;
            count++;
        }
        return sum / count;
    }

    public static double MeanVariance(IEnumerable&lt;double&gt; values)
    {
        var avg = Average(values);
        var variance = new List&lt;double&gt;();
        foreach (var v in values)
        {
            variance.Add(Math.Abs(avg - v));
        }
        avg = Average(variance);
        return avg;
    }
}

[TestFixture]
public class TestStatistics
{
    [Test]
    public void Average()
    {
        var list = new List&lt;double&gt; { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 };
        var avg = Statistics.Average(list);
        Assert.AreEqual(4.5, avg);
    }

    [Test]
    //[Prerequisite("TestStatistics.Average")]
    public void MeanVariance()
    {
        //try { this.Average(); } catch { Assert.Ignore("Pre-requisite test 'Average' failed."); }
        var list = new List&lt;double&gt; { 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 };
        var variance = Statistics.MeanVariance(list);
        Assert.AreEqual(0, variance);
    }
}
`</Code>
    <Description>I have a couple of cases where I would like to mark a test as a prerequisite of another test. It would be nice to have an attribute that indicated tests that were prerequisites of the current test.In the case where routines depend on one another, it is possible to know that a given test is going to fail because a sub-routine failed its test. If the test is a long running one, there really isn't any point in running the test if the sub-routine is broken anyway.Contrived Example:``Given the example, if the test `Average` fails, it makes sense to not bother testing `MeanVariance`.I would conceive of this working by chaining the tests (though I can see variations): - if `MeanVariance` is run, `Average` is forced to run first. - If `Average` has already been run, the results can be reused.- If `Average` fails, `MeanVariance` is skipped.May be a duplicate of something that was on the list many years ago:  . </Description>
  </Issue>
  <Issue>
    <IssueID>1030</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>1030</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Should we update Nunit.Runners package to 3.0?</Title>
    <CreatedDate>17/11/2015</CreatedDate>
    <ClosedDate>17/11/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:feature</Name>
        <IssueID>1030</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:critical</Name>
        <IssueID>1030</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Several people have been complaining on twitter because they have updated their projects to use the NUnit 3 framework, but there is no corresponding update for NUnit.Runners. They do not realize that they need to switch to the new NUnit.Console NuGet package.Even when you search NuGet for NUnit, the new NUnit.Console package is the 43'rd entry and on the third page. Most people won't find it. NUnit.Runners is the 2nd entry right after NUnit, so it is what everyone sees.Even if we put the information out on as many channels as we control (mailing list, website, twitter, etc) it will only reach a small fraction of developers who use NUnit.Should we create an update for the NUnit.Runners nuget package that contains the same binaries as the current NUnit.Console package? Once we have additional runners like the GUI, we can include them in that package and leave NUnit.Console as the lightweight, console only package.I think we should deal with this soon. NUnit 3 has only been showing up as a non-prerelease update for a couple of days. I think many people are going to be upgrading soon and running into the same problem.- - </Description>
  </Issue>
  <Issue>
    <IssueID>1029</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Support additional types for built in tolerance</Title>
    <CreatedDate>17/11/2015</CreatedDate>
    <ClosedDate>18/05/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:idea</Name>
        <IssueID>1029</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Sometimes it would be useful if you could use the built-in tolerance mechanism with custom types. At least delta tolerance could be done by looking for subtract operator and less than operator alternatively IComparable/IComparable&lt;T&gt;. </Description>
  </Issue>
  <Issue>
    <IssueID>1028</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>ExpectedException used by TestCase</Title>
    <CreatedDate>17/11/2015</CreatedDate>
    <ClosedDate>17/11/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:wontfix</Name>
        <IssueID>1028</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Hi, just testing out NUnit3 on our testbase, and have encountered something that seems a downgrade from previous versions:[Test][TestCase(0, ExpectedException = typeof(ArgumentException))][TestCase(1)][TestCase(2)]For 'normal' ExpectedExceptions it makes perfect sense to use Assert.Throws&lt;&gt;, but here it feels like something is lost. In Nunit 3 I'm guessing the only option is to split the test method into two with one having test cases that throw an exception and another having test cases that do not. Is there a more elegant way of expressing the above in NUnit3?With kind regards,Giles</Description>
  </Issue>
  <Issue>
    <IssueID>1024</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>1024</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Please add --pause flag to console runner</Title>
    <CreatedDate>14/11/2015</CreatedDate>
    <ClosedDate>28/11/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1024</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:feature</Name>
        <IssueID>1024</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>1024</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>The console runner documentation states there is `--pause` flag. But, this option has magically disappeared in the latest release candidate. I would like to be able to attach a debugger before tests run.</Description>
  </Issue>
  <Issue>
    <IssueID>1023</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>MsTest and xunit compatibility extensions</Title>
    <CreatedDate>14/11/2015</CreatedDate>
    <ClosedDate>25/10/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:wontfix</Name>
        <IssueID>1023</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:idea</Name>
        <IssueID>1023</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>review</Name>
        <IssueID>1023</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I was wondering about the efficacy of providing compatibility extensions/libraries that would allow MsTest and xunit test assemblies to compile and run with nunit.I find myself doing conversions all the time.If it were a simple matter of changing the using statements, and recompiling, it would encourage the migration to nunit.</Description>
  </Issue>
  <Issue>
    <IssueID>1018</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>1018</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>ArgumentException when 2.x version of NUnit Framework is in the bin directory</Title>
    <CreatedDate>12/11/2015</CreatedDate>
    <ClosedDate>08/02/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1018</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>1018</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>1018</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>When testing an assembly with a target framework version which has only 2 fields (say, major = 4 and minor = 5, which is what I am testing now, compiled with mono 4.0.4) the code in NUnit.Engine.Services.TestAgency.LaunchAgentProcess() fails while calling System.Version.ToString(), raising an ArgumentException with message "Argument must be between 0 and 2. Parameter name: fieldCount".I believe the problem to be around lines 204 and 204 of file  nunit/src/NUnitEngine/nunit.engine/Services/TestAgency.cs as of commit 272eadd. There the version is supposed to have at least 3 components, when there may not be that many.</Description>
  </Issue>
  <Issue>
    <IssueID>1017</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>1017</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Remove Assert.Multiple from framework</Title>
    <CreatedDate>12/11/2015</CreatedDate>
    <ClosedDate>13/11/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1017</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>1017</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>1017</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Multiple Asserts are not implemented but this public method - a stub - is visible to the user, causing confusion.</Description>
  </Issue>
  <Issue>
    <IssueID>1016</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Running One Parallelizable selected test in VS2013 gives an error </Title>
    <CreatedDate>12/11/2015</CreatedDate>
    <ClosedDate>12/11/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>1016</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>So am new to the whole NUnit framework so be patient with me . I've contacted the customer service of "Sauce Labs" and they recommended it me to Use NUnit over Mbunit and they gave me an example . I tried to run one selected test , it gave me : System.Reflection.TargetInvocationException, Exception thrown executing tests . but using running all , it works . I asked the customer service he told me , it is a known issue and i can't run one selected Parallelizable  test at a time . Is it true ?!!- P.S  I attached the file here , thanks :)   [example.docx](</Description>
  </Issue>
  <Issue>
    <IssueID>1015</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>1015</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Specifying .nunit project and --framework on command line causes nunit3-console.exe to crash.</Title>
    <CreatedDate>10/11/2015</CreatedDate>
    <ClosedDate>13/11/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1015</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>1015</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>1015</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>The command line that is run:``I am not certain if this is by design, and NUnit is simply missing a guard condition to not allow .nunit projects to not be specified with the framework option.Should the framework command be allowed to be specified with a nunit project, or is this an invalid test of the feature? I also have a sense that the error being reported is a path issue with the tests files themselves. </Description>
  </Issue>
  <Issue>
    <IssueID>1014</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>1014</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Ensure NUnit API assembly updates with MSI installs</Title>
    <CreatedDate>09/11/2015</CreatedDate>
    <ClosedDate>26/11/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1014</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:feature</Name>
        <IssueID>1014</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:critical</Name>
        <IssueID>1014</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>We are currently versioning the assembly at 3.0.0.0  with the intention that the API will not change. The internals may change occasionally, but if the version doesn’t change, then the MSI won’t update it.We’ll need to figure out how to ensure it gets updated. I can think of a few ways;- Force uninstall on install in the MSI. - Continually increment the third digit of the file version and just leave the assembly version the same.- Don't distribute the console/engine as an MSI- Use a different installer like NSIS</Description>
  </Issue>
  <Issue>
    <IssueID>1013</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Exception Invalid filter element: test</Title>
    <CreatedDate>09/11/2015</CreatedDate>
    <ClosedDate>10/11/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:duplicate</Name>
        <IssueID>1013</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>1013</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>When I run tests using NUnit console 3 beta 5 with the arg --testlist I get the following exception in the case when I my tests referenced to nunit.framework, Version 2.6.4.14350.-- Create a list of testsSystem.ArgumentException: Invalid filter element: testarameter name: xmlNodeerver stack trace:  at NUnit.Engine.Drivers.NUnit2FrameworkDriver.FromXml(XmlNode xmlNode)  at NUnit.Engine.Drivers.NUnit2FrameworkDriver.FromXml(XmlNode xmlNode)  at NUnit.Engine.Drivers.NUnit2FrameworkDriver.CountTestCases(String filter)  at NUnit.Engine.Runners.DirectTestRunner.CountTests(TestFilter filter)  at System.Runtime.Remoting.Messaging.StackBuilderSink._PrivateProcessMessage(IntPtr md, Object[] args, Object server, Object[]&amp; outArgs)  at System.Runtime.Remoting.Messaging.StackBuilderSink.SyncProcessMessage(IMessage msg)xception rethrown at [0]:  at System.Runtime.Remoting.Proxies.RealProxy.HandleReturnMessage(IMessage reqMsg, IMessage retMsg)  at System.Runtime.Remoting.Proxies.RealProxy.PrivateInvoke(MessageData&amp; msgData, Int32 type)  at NUnit.Engine.ITestEngineRunner.CountTestCases(TestFilter filter)  at NUnit.Engine.Runners.MasterTestRunner.RunTests(ITestEventListener listener, TestFilter filter)  at NUnit.Engine.Runners.MasterTestRunner.NUnit.Engine.ITestRunner.Run(ITestEventListener listener, TestFilter filter)  at NUnit.ConsoleRunner.ConsoleRunner.RunTests(TestPackage package, TestFilter filter)  at NUnit.ConsoleRunner.Program.Main(String[] args)</Description>
  </Issue>
  <Issue>
    <IssueID>1011</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>1011</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Packaging the Engine</Title>
    <CreatedDate>09/11/2015</CreatedDate>
    <ClosedDate>16/11/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1011</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:feature</Name>
        <IssueID>1011</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>1011</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>It would help us with our runners, as well as authors of third-party runners, to have the engine available as a NuGet package.The adapter needed the bare engine, with no addins. Other folks might want that or they might want specific addins. Some design is needed.For now, we may just want to create a bare engine package, consisting of nunit.engine, nunit.engine.api and Mono.Cecil.</Description>
  </Issue>
  <Issue>
    <IssueID>1010</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>1010</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Need to control engine use of extensions</Title>
    <CreatedDate>09/11/2015</CreatedDate>
    <ClosedDate>22/05/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1010</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:feature</Name>
        <IssueID>1010</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>1010</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>When starting the engine, it should be possible to determine what extensions are loaded and to disable/enable extensions individually. There should also be a global way to turn off all extensions.</Description>
  </Issue>
  <Issue>
    <IssueID>1009</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Cecil exceptions from engine</Title>
    <CreatedDate>08/11/2015</CreatedDate>
    <ClosedDate>15/08/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>1009</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>1009</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>The engine can throw exceptions due to errors in Cecil Resolve(). I discovered this when working with the NUnit 3 VS Adapter. The errors are very hard to locate and occur when Cecil cannot resolve the item requested. The code assumes null will be returned rather than an exception being thrown.We should find every place where we do a Resolve in the engine code and 1. Catch it and take appropriate action2. Try to set up the resolver correctly so it doesn't occur.</Description>
  </Issue>
  <Issue>
    <IssueID>1008</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>1008</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>NUnitLite namespace not updated in the NuGet Packages</Title>
    <CreatedDate>08/11/2015</CreatedDate>
    <ClosedDate>08/11/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>1008</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>1008</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>We changed the NUnitLite namespace from nunitlite.runner to nunitlite, but didn't update the template files in the nunitlite nuget package. Using those NuGet packages now causes a compile error.I am going to fix and test on the release branch.</Description>
  </Issue>
  <Issue>
    <IssueID>1004</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>oznetmaster</FixedById>
        <IssueID>1004</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Poor formatting of results for Assert.AreEqual(DateTimeOffset, DateTimeOffset)</Title>
    <CreatedDate>07/11/2015</CreatedDate>
    <ClosedDate>24/02/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1004</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>good first issue</Name>
        <IssueID>1004</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>1004</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>1004</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>This test fails as expected:``I don't have time to write a PR for this right now, hence this issue.</Description>
  </Issue>
  <Issue>
    <IssueID>1000</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>JustinRChou</FixedById>
        <IssueID>1000</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Support multiple Author attributes per test</Title>
    <CreatedDate>06/11/2015</CreatedDate>
    <ClosedDate>13/01/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>1000</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>1000</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:low</Name>
        <IssueID>1000</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Support multiple Author attributes per testNote: you can currently only have one Author attribute per fixture or test.</Description>
  </Issue>
  <Issue>
    <IssueID>999</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Support multiple TestOf attributes per test</Title>
    <CreatedDate>06/11/2015</CreatedDate>
    <ClosedDate>07/10/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>999</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>good first issue</Name>
        <IssueID>999</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>999</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:low</Name>
        <IssueID>999</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Support multiple TestOn attributes per testNote: you can currently only have one TestOf attribute per fixture or test.</Description>
  </Issue>
  <Issue>
    <IssueID>995</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>995</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
      <IssueAssignee>
        <FixedById>ChrisMaddock</FixedById>
        <IssueID>995</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Enable Warning as Error</Title>
    <CreatedDate>06/11/2015</CreatedDate>
    <ClosedDate>01/07/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>995</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:build</Name>
        <IssueID>995</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>995</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>We constantly have new warnings creeping into the code, often because of missing XML documents, or unused variables on one platform or another. We should fix these warnings, then enable warning as error on all projects to prevent new ones from being introduced.</Description>
  </Issue>
  <Issue>
    <IssueID>994</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Add max number of Agents to the NUnit project file</Title>
    <CreatedDate>05/11/2015</CreatedDate>
    <ClosedDate>18/11/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>994</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>994</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>994</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Since it's possible to specify the process model in the project file, it should also be possible to specify how many agents can run at one time using an agents attribute. Otherwise, all the assemblies will run simultaneously when Process=Multiple.</Description>
  </Issue>
  <Issue>
    <IssueID>991</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>991</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Mono.Options should not be exposed to public directly</Title>
    <CreatedDate>05/11/2015</CreatedDate>
    <ClosedDate>05/11/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>991</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>good first issue</Name>
        <IssueID>991</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>991</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>991</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>nunit3 adopts `Mono.Options` classes.However, this leads to namespace collision of the library user.The user's app may also ship another copy of `Mono.Options` classes.Since class `CommandLineOptions` relies on inheriting `Mono.Options` classes,I suggest to rename the namespace to something like `NUnit.Options` to avoid namespace collision.</Description>
  </Issue>
  <Issue>
    <IssueID>990</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>990</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>V2 driver is passing invalid filter elements to NUnit V2</Title>
    <CreatedDate>05/11/2015</CreatedDate>
    <ClosedDate>05/11/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>990</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>good first issue</Name>
        <IssueID>990</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>990</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:critical</Name>
        <IssueID>990</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Here's the output I get:``It does work when filtering on the category (`cat == XXX`).</Description>
  </Issue>
  <Issue>
    <IssueID>989</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>NUnit Engine 3 beta5 fails for parallel IO read</Title>
    <CreatedDate>05/11/2015</CreatedDate>
    <ClosedDate>29/06/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:norepro</Name>
        <IssueID>989</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code>
39) Error : EyeDoc.Forms.Tests.FormSettings.ConditionsTest.TestConditionsFromSettingsXml("ConditionsSignedAndSent.xml",30,4400,True)
System.IO.DirectoryNotFoundException : Could not find a part of the path 'd:\jenkins\worksp\FormSettings\SettingsXml\ConditionsSignedAndSent.xml'.
   at System.IO.__Error.WinIOError(Int32 errorCode, String maybeFullPath)
   at System.IO.FileStream.Init(String path, FileMode mode, FileAccess access, Int32 rights, Boolean useRights, FileShare share, Int32 bufferSize, FileOptions options, SECURITY_ATTRIBUTES secAttrs, String msgPath, Boolean bFromProxy, Boolean useLongPath, Boolean checkHost)
   at System.IO.FileStream..ctor(String path, FileMode mode, FileAccess access, FileShare share, Int32 bufferSize)
   at System.Xml.XmlDownloadManager.GetStream(Uri uri, ICredentials credentials, IWebProxy proxy, RequestCachePolicy cachePolicy)
   at System.Xml.XmlUrlResolver.GetEntity(Uri absoluteUri, String role, Type ofObjectToReturn)
   at System.Xml.XmlTextReaderImpl.OpenUrlDelegate(Object xmlResolver)
   at System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(TryCode code, CleanupCode backoutCode, Object userData)
   at System.Threading.CompressedStack.Run(CompressedStack compressedStack, ContextCallback callback, Object state)
   at System.Xml.XmlTextReaderImpl.OpenUrl()
   at System.Xml.XmlTextReaderImpl.Read()
   at System.Xml.XmlLoader.Load(XmlDocument doc, XmlReader reader, Boolean preserveWhitespace)
   at System.Xml.XmlDocument.Load(XmlReader reader)
   at System.Xml.XmlDocument.Load(String filename)
   at EyeDoc.Forms.Tests.FormSettings.Helper.GetSettingsXml(String xmlFileName) in d:\jenkins\workspace\DailyEyeDoc\Forms\trunk\EyeDoc.Forms.Tests\FormSettings\Helper.cs:line 50
   at EyeDoc.Forms.Tests.FormSettings.ConditionsTest.TestConditionsFromSettingsXml(String xmlFileName, Int32 caseStatus, Int64 bitStatus, Boolean expectedResult) in d:\jenkins\workspace\DailyEyeDoc\Forms\trunk\EyeDoc.Forms.Tests\FormSettings\ConditionsTest.cs:line 36


After adding `File.Exists(xmlPath)`, in my test code, with a `FileNotFoundException` exception.


39) Error : EyeDoc.Forms.Tests.FormSettings.ConditionsTest.TestConditionsFromSettingsXml("ConditionsSignedAndSent.xml",30,4400,True)
System.IO.FileNotFoundException : The settings XML is missing. (d:\jenkins\worksp\FormSettings\SettingsXml\ConditionsSignedAndSent.xml)
   at EyeDoc.Forms.Tests.FormSettings.Helper.GetSettingsXml(String xmlFileName) in d:\jenkins\workspace\DailyEyeDoc\Forms\trunk\EyeDoc.Forms.Tests\FormSettings\Helper.cs:line 50
   at EyeDoc.Forms.Tests.FormSettings.ConditionsTest.TestConditionsFromSettingsXml(String xmlFileName, Int32 caseStatus, Int64 bitStatus, Boolean expectedResult) in d:\jenkins\workspace\DailyEyeDoc\Forms\trunk\EyeDoc.Forms.Tests\FormSettings\ConditionsTest.cs:line 37
`</Code>
    <Description>### BackgroundI'm trying to run all test in parallel, after tip from @CharliePoole. We have some tests that’s reads XML-files from disk. First I thought it was the test code, using a `StringBuilder` to combine the filename parts, so I changed to `Path.Combine`, but still IO exception, in `XmlDocument.Load`.### TestsThe test is using several `TestCase`, and in Visual Studio we still use NUnit 2.6.3 Nuget package. I guess using the `[Parallelizable(ParallelScope.Self)]` attribute is only available in NUnit 3?### FailureIn the log you can see that the path to the file is corrupted, i.e. `ace\DailyEyeDoc\Forms\trunk\EyeDoc.Forms.Tests\` is missing. When only runing this test-dll, the path is correct from `var xmlPath = Path.Combine(baseDirectory, SettingsXmlBaseDirectory, xmlFileName);`.``### WorkaroundRemove the test-dll from the `nunit`-file, and run it separately.### Relates to- [NUnit Engine Tests fail if not run from test directory #938](- [Cannot run NUnit Console from another directory #853](- [Run the tests parallel #985](- [ParallelizableAttribute - NUnit](</Description>
  </Issue>
  <Issue>
    <IssueID>988</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>988</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Don't run portable tests from NUnit Console</Title>
    <CreatedDate>05/11/2015</CreatedDate>
    <ClosedDate>07/11/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>988</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>988</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>988</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Spawned from #948We don't want tons of issues reported when users try to run tests compiled against the portable library and it fails to run. Better to have the driver look at the nunit.framework.dll and determine if it is portable before running it. If it is portable, give a message that portable tests must be run with platform specific runners or nunitlite.</Description>
  </Issue>
  <Issue>
    <IssueID>987</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>987</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Re-Rename nunit-console runner?</Title>
    <CreatedDate>04/11/2015</CreatedDate>
    <ClosedDate>13/11/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:wontfix</Name>
        <IssueID>987</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:critical</Name>
        <IssueID>987</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>In resolving issue #929 we renamed nunit-console to nunit3-console. We did it pretty fast and not everyone is 100% happy. We have had some discussion but it's still hanging.I'm creating this issue to force us to make a decision about the name before RC2, which is due out in a few days. I don't want to make the change past RC2, so a decision is critical.Pros  and Cons of the original rename: (Feel free to edit this comment with more of them)PRO It's a different program, with differnet options, let's give it a different name.It will help some tools.We have renamed some nuget packages, so we should rename the exe.CONCommand-line users are used to typing nunit-console and know how to set the path.It will hurt some tools.We have renamed some nuget packages, so that should be sufficient.We have not renamed other things, like nunitlite or the framework.If I were doing this for me, based on personal preference, I'd revoke the change. We know that @NikolayPianikov was bothered by it. Feel free to include personal preferences.If you don't care, I'm taking that as an indication we should not have changed it.</Description>
  </Issue>
  <Issue>
    <IssueID>986</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>986</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Update docs for parallel execution</Title>
    <CreatedDate>04/11/2015</CreatedDate>
    <ClosedDate>08/11/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>986</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:docs</Name>
        <IssueID>986</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>986</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>We should review these completely. There may be a need for a general section about parallel execution, which could be taken from material in the dev wiki. We should clearly state that parallelism below the fixture level is not yet available.</Description>
  </Issue>
  <Issue>
    <IssueID>985</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Run the tests parallel</Title>
    <CreatedDate>04/11/2015</CreatedDate>
    <ClosedDate>05/12/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:duplicate</Name>
        <IssueID>985</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>HI,am using Nunit.3.0 rc, to run tests parallelwhile running the tests using  [Parallelizable(ParallelScope.Children)] at test method, test are running one by oneplease suggest me how to run the tests parallel one each another, below is my code namespace NunitTestProject{    [TestFixture]    [Parallelizable(ParallelScope.Fixtures)]    public class TestSet001    {        [Test]        [TestCase("2")]        [TestCase("3")]        [TestCase("4")]        [Parallelizable(ParallelScope.Children)]        public void TestSet001Test001(string dataRow)        {          SeleniumTest.RunSeleniumTestInLocalChrome(dataRow);        }``}</Description>
  </Issue>
  <Issue>
    <IssueID>983</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>983</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Inconsistent return codes depending on ProcessModel</Title>
    <CreatedDate>03/11/2015</CreatedDate>
    <ClosedDate>06/11/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>983</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>983</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>983</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Per @NikolayPianikov...&gt; When --process=InProces, nunit returns -100 for StackOverflow exception&gt; but when --process=Multiple or Separate, nunit returns 0. Is it possible to return -100? TeamCity looks at the negative exit code to raise a build problemand...&gt; When --process=InProces, nunit returns -100 for OutOfMemory exception&gt; but when --process=Multiple or Separate, nunit returns 1 for one failed test.&gt; It will be better if nunit console returns the same exit codeWhen a separate agent is used, it's the agent process that terminates with -100. We used to detect that the agent had died and terminate the console with -100 as well.However, in NUnit 3.0, we wanted to continue in order to report tests from any other agents, so we trapped the exception that causes us to terminate. We report the problem with the terminated assembly in the XML and on the console output.That's all well and good, but we need to somehow reflect the failure in the return code as well.@NikolayPianikov Imagine two assemblies running in two agents. One of them runs to completion with two failures - the normal return code would be 2. The other gets an OutOfMemoryException - the normal return code would be -100. What should nunit-console return?</Description>
  </Issue>
  <Issue>
    <IssueID>982</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Document relation of assembly versions to release packages</Title>
    <CreatedDate>03/11/2015</CreatedDate>
    <ClosedDate>05/11/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>982</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:docs</Name>
        <IssueID>982</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:low</Name>
        <IssueID>982</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>We need a page that matches up assembly versions with the various release packages.</Description>
  </Issue>
  <Issue>
    <IssueID>981</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>981</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Define NUnit Versioning for post-3.0 Development</Title>
    <CreatedDate>03/11/2015</CreatedDate>
    <ClosedDate>04/03/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>981</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:build</Name>
        <IssueID>981</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:critical</Name>
        <IssueID>981</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>We can't push any code for post-3.0 changes without first deciding on future assembly versioning, at least if we think we may want to change away from use of 3.x._._ That makes this an immediate priority, since some of us are working on 3.0 stuff already!Our package versioning is only slightly less critical. We can push but we can't create any CI, nightly or weekly packages until we decide about it. So I'm dealing with both types hereASSEMBLY VERSIONSWe currently define assembly versions as 3.0._._ for most assemblies. The sole exception is nunit.engine.api, which uses 3.0.0.0 for all releases. We can change this only for 3.1 and subsequent versions, because changing it for 3.0 would mess up the ordering of versions.QUESTION: Do we want to start controlling the third digit of assembly version with 3.1 as has been suggested by @oznetmaster ?PACKAGE VERSIONS:We have so far put out packages numbered 3.0.0, with various suffixes. We will eventually put out our final release packages as "3.0.0"QUESTION: What do we want to call bug fix releases of 3.0?QUESTION: What will we call packages that we generate in CI? We know they will start with 3.1, but what comes after that? QUESTION: Do we want any other development packages like nightly, weekly? What will we call them? It has to be consistent with the CI packages but also clearly distinguished, perhaps by a suffix.QUESTION: What about the 3.2 release? We won't get to it for a few months but how do we want to version it. Is what we are doing for 3.0 OK or will it be something else? Obviously, this question is not critical immediately, but we may want to know where we are going in advance.</Description>
  </Issue>
  <Issue>
    <IssueID>980</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>System.NullReferenceException Writing Results to File with Named Ignore in TestCase</Title>
    <CreatedDate>03/11/2015</CreatedDate>
    <ClosedDate>03/11/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:wontfix</Name>
        <IssueID>980</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>980</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Environment: NUnit 2.6.4 (GUI and command-line)We recently added a named-ignore to a test-case attribute. We changed `[TestCase("C1")]` to `[TestCase("C1", Ignore = true)]`We also run NUnit with command-line parameters to write out the results to an XML file. This change resulted in this exception stack:``This behaviour occurs both with the GUI client and with running from the command-line.</Description>
  </Issue>
  <Issue>
    <IssueID>979</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Console closes immediately</Title>
    <CreatedDate>03/11/2015</CreatedDate>
    <ClosedDate>03/11/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>979</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Hello Guys,i am new here and have a problem with the NUnit Console.Everytime i want to start it just closes without an error message.Is there anything else i need to install except the NUnit Framework and the developement environment?I hope that you can help a newbieregardsEvosoul</Description>
  </Issue>
  <Issue>
    <IssueID>978</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>978</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>It should be possible to determine version of NUnit using nunit console tool</Title>
    <CreatedDate>03/11/2015</CreatedDate>
    <ClosedDate>04/11/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>978</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>978</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>978</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Currently nunit console started without arguments outputs NUnit version. But it does not look like a reliable way to obtain version as this default behavior can easily change in the future. It would be great to have dedicated argument for the version.</Description>
  </Issue>
  <Issue>
    <IssueID>977</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>977</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Improper packaging of the Framework NuGet package</Title>
    <CreatedDate>03/11/2015</CreatedDate>
    <ClosedDate>05/11/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>977</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I have been working on getting the Xamarin runners ready for release, but they are not working with the current nuget package. I think the dotnet directory that I added to lib for DNX is conflicting with Android and iOS.I need to double check my work in the Xamarin solution and make sure all the NuGet references are correct, but I wanted to enter this issue to inform the @nunit/core-team that there may be issues. AFAIK, If there is an issue, it is a nuget packaging issue, not a code issue.I need to test creating the following from the NuGet package and make sure they all reference the correct assembly in the package.- DNX test project- Android test project,- iOS test project- WinPhone 8.1 test project</Description>
  </Issue>
  <Issue>
    <IssueID>976</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>The NUnit 3 breaks integration with the TeamCity</Title>
    <CreatedDate>02/11/2015</CreatedDate>
    <ClosedDate>03/11/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:wontfix</Name>
        <IssueID>976</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>As you probably know, TeamCity has pretty decent integration with NUnit, and this year we released a version which integrates with NUnit3 beta. Unfortunately, after recent release of NUnit3 beta 5 our integration is no longer working. While this is understandable risk, when you're providing an integration with beta version of some tool, still we think that some problems could be easily removed. Also beta in the name usually means the tool will not change much, as it is going to be released really soon. Sadly this was not the case here. So, speaking about our problems:1) First and foremost - NUnit still does not have proper ways to detect its version. We propose to add -version argument or some similar approach. We're aware that nunit-console.exe started without arguments will output version, but what if you change this in the future versions? Is it reliable? Clear approach to versioning will allow vendors, who integrate with the tool, at least to fail gracefully providing user friendly error messages.2) NUnit 3 beta 5 removed filtering of tests by categories. Corresponding command line arguments were replaced with -where. Given that previous versions of NUnit3 supported these arguments, and we already released a version which works with these versions, we had to workaround this problem with proper using of -where. This sounds like not a big deal, but -where argument has not been supported by previous versions, so now we have to detect the version of the tool, see point 1. 3) Parallel tests are now on by default. For us, it looks like a dangerous approach, which potentially can cause unnecessary problems to users. Users who did not have any problems with performance can face instability problems with tests after upgrade to new NUnit. Moreover, our users (those who run tests on TeamCity build agents) often run tests on virtual machines having 1 core, and for such users it does not make much sense to enable parallelization by default. So they will not benefit from parallelization, but chances are high that they will suffer from instability problems. Currently we have to workaround this problem too, by providing --workers=1 argument by default.4) nunit-console.exe is now called nunit3-console.exe. Well for us, those who look at the project from outside, this change does not look like justified. Sure there are some incompatibilities with command line and people will have problems with their scripts where they call nunit-console.exe directly. But, some incompatibilities, like removed filtering of tests, could be easily fixed. Others, like parallelization by default, also have issues, and could be re-thought. Also such a change raises questions about future versions. Are we going to see nunit4-console.exe soon? What about minor versions, do you plan to have nunit31-console.exe? Is this now official approach to versioning? Does it mean that people will have to fix their build scripts and CI server configuration, each time when you change executable name?And as a general note, for vendors like us, command line arguments are like API, and as it makes sense to preserve compatibility with API, it also makes sense to preserve it with command line. Note, that we're all for new tools, new features, etc. But changes in API should be justified, and vendors and your users should have clear understanding why they need to fix their tools. And just to make our point more clear. It's not that we insist on backward compatibility, we understand that tool should evolve. It's just that sometimes, backward compatibility can be preserved with relatively small effort. And this small effort can save days or months of work of other people. It would be great if NUnit team paid a little bit more attention to compatibility issues in the future.</Description>
  </Issue>
  <Issue>
    <IssueID>974</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>974</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Add Contributing.md file</Title>
    <CreatedDate>02/11/2015</CreatedDate>
    <ClosedDate>05/12/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>974</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:docs</Name>
        <IssueID>974</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Add a file to the project with information on how to contribute and how to build the solution.- Include links to our coding guidelines.- Include information on how to build on each platform. For example, Linux needs to download the latest version of MonoDevelop and the PCL components from the Xamarin feed. See #784 - Include information on how to build and run all tests from the command line- Add links to the various developer documentation in nunit/dev like how to package a releaseThis document should be mentioned and linked to directly from the README.md which serves as the front page of the GitHub repo.</Description>
  </Issue>
  <Issue>
    <IssueID>973</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Update Contributors.md</Title>
    <CreatedDate>02/11/2015</CreatedDate>
    <ClosedDate>12/12/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>973</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>good first issue</Name>
        <IssueID>973</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:docs</Name>
        <IssueID>973</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Contributors.md was not updated for the RC release. New contributors should be added.Should we move this to the foot of README.md so it is more visible? Also Contributors.md could be confused with the common CONTRIBUTING.md which give instructions on contributing to the project.</Description>
  </Issue>
  <Issue>
    <IssueID>971</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>971</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Create a cmd file for running the silverlight tests</Title>
    <CreatedDate>01/11/2015</CreatedDate>
    <ClosedDate>21/12/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:wontfix</Name>
        <IssueID>971</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:build</Name>
        <IssueID>971</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:low</Name>
        <IssueID>971</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>If possible, it should look in the registry to find where sllauncher.exe is installed.</Description>
  </Issue>
  <Issue>
    <IssueID>970</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>970</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Define PARALLEL in CF build of nunitlite</Title>
    <CreatedDate>01/11/2015</CreatedDate>
    <ClosedDate>02/11/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>970</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>good first issue</Name>
        <IssueID>970</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>970</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>970</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Is the PARALLEL build being officially supported in nunitlite?If so, setting it cause a build error in the CF build.I had not noticed earlier because I always have supported it in my CF builds.Specifically, in DisplayRunSettings: Environment.ProcessorCount is not supported in CF.</Description>
  </Issue>
  <Issue>
    <IssueID>967</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>967</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Run Settings Report is not being displayed.</Title>
    <CreatedDate>01/11/2015</CreatedDate>
    <ClosedDate>01/11/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>967</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>967</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>967</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>The console runner has a run settings report, which is not being displayed for some reason. In addition, it was intended that this report would also be in the nunitlite runner but it is not.</Description>
  </Issue>
  <Issue>
    <IssueID>963</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Access list of included / excluded categories programmatically during test time</Title>
    <CreatedDate>30/10/2015</CreatedDate>
    <ClosedDate>31/10/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:duplicate</Name>
        <IssueID>963</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Feature request.Operations in `SetUpFixture` allows a one-time setup for all test fixtures. However, there may be some operations that we want to ignore if certain test categories are excluded.For example, we may want to generate less data if certain categories are unused.Accessing the list of included / excluded categories during a test run would help make decisions at runtime.</Description>
  </Issue>
  <Issue>
    <IssueID>961</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Special message for options not supported in a particular NUnitLite build</Title>
    <CreatedDate>30/10/2015</CreatedDate>
    <ClosedDate>25/04/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:wontfix</Name>
        <IssueID>961</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>961</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>961</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Some options (e.g. --workers) are not supported in the portable build. They simply show up as "invalid option" which may be confusing - it confused me anyway.We would ideally like to give a special message for these, indicating that they are not supported in the portable build.While doing this, it would make sense to review just why some options are not supported and consider re-instating them.</Description>
  </Issue>
  <Issue>
    <IssueID>960</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>960</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Intermittent failure of CategoryFilterTests</Title>
    <CreatedDate>30/10/2015</CreatedDate>
    <ClosedDate>31/10/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>960</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>960</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>960</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>This test sometimes fails because it's a parameterized test with two instances running in parallel. Each instance uses the same fake tests and tries to add the same keys to the test property set. I got this from a stack trace and haven't checked the code but i suspect that some static field in the test needs to be made into an instance field.</Description>
  </Issue>
  <Issue>
    <IssueID>959</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>959</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Restore filter options for NUnitLite portable build</Title>
    <CreatedDate>30/10/2015</CreatedDate>
    <ClosedDate>30/10/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>959</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>959</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>959</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>We aren't sure just when or how, but filtering using --test and --where is not enabled for the NUnitLite portable build. They should be restored as options and the display of any filtering options included in the console output as it is for other builds.</Description>
  </Issue>
  <Issue>
    <IssueID>958</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Exception will throw in the vs debug mode though assert it will throw</Title>
    <CreatedDate>30/10/2015</CreatedDate>
    <ClosedDate>30/10/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>958</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I use nunitlite to run tests. There are some tests that assert some code will throw specific exception. But since I assert that it will throw, VS still will break at that exception in debug mode. Which is really annoying.</Description>
  </Issue>
  <Issue>
    <IssueID>545</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>545</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>TestContext.CurrentContext properties are null</Title>
    <CreatedDate>18/03/2015</CreatedDate>
    <ClosedDate>20/03/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>545</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>We are trying to use a test `[TearDown]` attribute to log results from a test run.We're having an issue where the properties on `TestContext.CurrentContext` are throwing `NullReferenceExceptions`.We have created a simple test solution in which we have the following code:``We are getting a `NullReferenceException` coming from `TestContext.CurrentContext.TestDirectory`.</Description>
  </Issue>
  <Issue>
    <IssueID>544</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>544</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>AsyncTestMethodTests for 4.5 Framework fails frequently on Travis CI</Title>
    <CreatedDate>18/03/2015</CreatedDate>
    <ClosedDate>14/07/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>544</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>544</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>544</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>The following test fails frequently on Travis. We should investigate and fix if possible.``</Description>
  </Issue>
  <Issue>
    <IssueID>541</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>541</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Console help doesn't indicate defaults</Title>
    <CreatedDate>18/03/2015</CreatedDate>
    <ClosedDate>19/03/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>541</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>541</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>541</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>The info displayed by nunit-console --help shows several parameters for which there are multiple options without indicating the defaults. We should tell folks!Options affected are --process, --domain, --framework, --work.</Description>
  </Issue>
  <Issue>
    <IssueID>539</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>539</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Truncation of string arguments</Title>
    <CreatedDate>17/03/2015</CreatedDate>
    <ClosedDate>23/06/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>539</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>539</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>539</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>In MethodHelper.cs, we truncate any string arguments of parameterized tests to a max of 20 characters. I've observed that this is much too short in practice. For example, in the tests of the VS adapter, there is a test for which all argumetns are reduced to the same initial string   "&lt;test-case resul=..."even though the actual args are all different.As a quick fix, lets use a larger value, like 40 or 50.Even better would be to add the id of the test as a suffix to the name.</Description>
  </Issue>
  <Issue>
    <IssueID>538</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>538</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Potential bug using TestContext in constructors</Title>
    <CreatedDate>17/03/2015</CreatedDate>
    <ClosedDate>19/04/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>538</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>538</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>538</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I ran into this while debugging a problem with a test class that contained the following declaration:static readonly string MockAssembly Path =    Path.Combine(TestContext.CurrentContext.TestDirectory, "mock-nunit-assembly.exe");This declaration worked OK in one test class but caused a second one to simply disappear from the discovered tests.  It turned out that the second class contained a method marked with TestCaseSource, with the data defined in the same class.The result of this insidious combination is that TestContext.CurrentContext.TestDirectory is executed at a time when it is not expected to be executed: when no tests are being run. That means that no TestExecutionContext has been set up and the the statement throws a null reference exception while tests are being loaded. In my case, there was no indication of a problem, other than  the fact that the entire fixture was missing from the displayed tests.This should be investigated and a check introduced so that attempting to access the TestContext at a time when no test is being executed causes a prominent error message.</Description>
  </Issue>
  <Issue>
    <IssueID>535</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>NUnit should provide navigation data for tests</Title>
    <CreatedDate>16/03/2015</CreatedDate>
    <ClosedDate>25/10/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:idea</Name>
        <IssueID>535</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>As suggested in #534 it would be desireable for NUnit to provide the file and line number of the source where a test is defined.</Description>
  </Issue>
  <Issue>
    <IssueID>534</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>534</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Add class name and method name to test result xml</Title>
    <CreatedDate>16/03/2015</CreatedDate>
    <ClosedDate>18/03/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>534</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:feature</Name>
        <IssueID>534</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>534</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>This will allow runners like our VS adapter to figure out the file and line number where the test is defined. This is what NUnit v2 has done for the past few releases. This is high priority for beta 1 because we want to release a version of the adapter with it.Note that some tests (e.g. fixtures) don't have an associated method name and some (e.g. assemblies) don't have a class name. NUnit v2 handles this in the Test object hierarchy and we should handle it in the same way for 3.0.In the long term, it would be great if NUnit itself could figure out the file and line number and provide that to runners. I'll create another issue for that.</Description>
  </Issue>
  <Issue>
    <IssueID>533</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>533</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Separate NUnitLite runner and autorunner</Title>
    <CreatedDate>12/03/2015</CreatedDate>
    <ClosedDate>21/12/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>533</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:feature</Name>
        <IssueID>533</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>533</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Changes in PR #526 included a new AutoRun class, for use by self-running tests. However, the class still includes some elements from the old runner, which are not appropriate for an autorunner. In particular, other input files are still accepted on the command line although they are ignored with a warning.We should have a separate runner class for use in running one or more tests under nunitlite. We may want this to be in a separate assembly (an exe) as well.Additionally, each runner should only accept the options that are relevant to it, which may involve some refactoring of the ConsoleOptions class.</Description>
  </Issue>
  <Issue>
    <IssueID>532</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>532</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Batch runner for Silverlight tests</Title>
    <CreatedDate>12/03/2015</CreatedDate>
    <ClosedDate>21/12/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>532</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:feature</Name>
        <IssueID>532</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>532</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Prior to its 1.0 release, NUnitLite had a batch runner that allowed the CI build to run Silverlight tests. We should revive that feature and make it work for 3.0.</Description>
  </Issue>
  <Issue>
    <IssueID>531</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>531</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Display text output from tests in Silverlight runner</Title>
    <CreatedDate>12/03/2015</CreatedDate>
    <ClosedDate>12/03/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>531</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:feature</Name>
        <IssueID>531</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>531</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Adding this issue to document feature already added in PR #526 for beta 1 release.</Description>
  </Issue>
  <Issue>
    <IssueID>530</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>530</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Color display for Silverlight runner</Title>
    <CreatedDate>12/03/2015</CreatedDate>
    <ClosedDate>12/03/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>530</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:feature</Name>
        <IssueID>530</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>530</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Adding this issue to document feature already added by PR #526 for the Beta1 Milestone</Description>
  </Issue>
  <Issue>
    <IssueID>528</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>528</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>V2 Framework Driver does not make use of passed in TestFilter</Title>
    <CreatedDate>12/03/2015</CreatedDate>
    <ClosedDate>18/03/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>528</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>528</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>528</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>The V2 framework driver always calls the V2 core with an empty filter, no matter what has been passed to the run method.This issue is being broken out from issue #517, which deals with the TestEventListener.The TestFilter that is passed to the V2 driver is ignored and all tests are currently run.This needs to be reviewed to see how much work is involved but if possible we should include it in the first beta release.</Description>
  </Issue>
  <Issue>
    <IssueID>527</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Apply a list of constraints to a list of values</Title>
    <CreatedDate>10/03/2015</CreatedDate>
    <ClosedDate>20/11/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:wontfix</Name>
        <IssueID>527</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:idea</Name>
        <IssueID>527</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>This idea popped up when I was working on testing the content of multi-line messages, created as an array of strings. When an exact match is desired, it's simple to write``Clearly, various alternative syntax is possible for this feature but the basic idea is to apply a list of constraints, created in various ways, to a list of values.I'm marking this as just an "idea" so we an all comment on it.</Description>
  </Issue>
  <Issue>
    <IssueID>525</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>v3 Test Results xml &lt;test-run&gt; Attribute "errors" is missing from v3</Title>
    <CreatedDate>09/03/2015</CreatedDate>
    <ClosedDate>10/03/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>525</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Greetings. I was trying out an XML - HTML Report generator from  and it crashed with a null reference errror (not your problem) when trying to parse the `"errors"` attribute in the `&lt;test-results&gt;`  node (their Program.cs line 180, fwiw).The `"errors"` attribute is in the V2 writer @ `&lt;test-results&gt;` `NUnit2XmlOutputWriter.cs` line 101 and `NUnit2XmlResultWriter.cs` line 91 but not in `NUnit3XmlOutputWriter.cs` lines 93-115Is this omission deliberate and permanent? Should I drop the "errors" attribute from the Report Generator code? I just thought I'd mention it in case "oh, sh..".As a completely unrelated aside, I got NUnitLite V3 to run inside AutoCAD:  ...because mocking AutoCAD no way.</Description>
  </Issue>
  <Issue>
    <IssueID>524</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>michal-franc</FixedById>
        <IssueID>524</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>int and char do not compare correctly?</Title>
    <CreatedDate>08/03/2015</CreatedDate>
    <ClosedDate>05/06/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>524</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>524</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>char c = '\u0000';Assert.AreEqual (0, c) fails.Yet, if you cast c to an int, it has the value of 0.Shouldn't 0 and '\u0000' be equal?</Description>
  </Issue>
  <Issue>
    <IssueID>523</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>oznetmaster</FixedById>
        <IssueID>523</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Investigate Generic Usage in CF builds</Title>
    <CreatedDate>04/03/2015</CreatedDate>
    <ClosedDate>14/10/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>523</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>There seems to be some discrepancies between the actual implementation of generics (and generic related reflection) in CF and the documentation of that implementation.There is a need to reconcile the two so that the maximum functionality around generics is available in the CF build.</Description>
  </Issue>
  <Issue>
    <IssueID>522</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>522</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>After version 2.6.1 Remoting stop working from tests.</Title>
    <CreatedDate>03/03/2015</CreatedDate>
    <ClosedDate>14/09/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:wontfix</Name>
        <IssueID>522</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I am writing system tests agains legacy api that uses remoting, however after updated Nunit any remote call will fail to:``</Description>
  </Issue>
  <Issue>
    <IssueID>521</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>521</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>provide a option to disable shadowcopy in nunit v3</Title>
    <CreatedDate>03/03/2015</CreatedDate>
    <ClosedDate>17/03/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>521</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>good first issue</Name>
        <IssueID>521</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:feature</Name>
        <IssueID>521</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>521</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>from vs test runner i get thisNUnit 1.2.0.1 executing tests is EnableShutdown set to TrueNUnit 1.2.0.1 executing tests is startedShadowCopyFiles is set to :FalseLoading tests from Run started: NUnit 1.2.0.1 executing tests is finishedbut in command line i dont see any switch to allow me to disable shadowcopy</Description>
  </Issue>
  <Issue>
    <IssueID>520</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>where can i find the nunit test runner adapter for vs 2013</Title>
    <CreatedDate>28/02/2015</CreatedDate>
    <ClosedDate>13/04/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>520</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
  </Issue>
  <Issue>
    <IssueID>519</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Warning: No tests found in *.dll</Title>
    <CreatedDate>28/02/2015</CreatedDate>
    <ClosedDate>21/07/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:norepro</Name>
        <IssueID>519</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I have a simple test assembly dependent on NUnit 3 Beta 1 nuget package.I have the "NUnit3 Beta 1"  Framework package installed on my computer.My Test class is:``No exception is being thrown.Why weren't my tests found?</Description>
  </Issue>
  <Issue>
    <IssueID>518</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>how is --teamcity supposed to work</Title>
    <CreatedDate>28/02/2015</CreatedDate>
    <ClosedDate>28/02/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>518</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>hi,having issues trying to show teamcity messages, i was expecting once we set --temacity to display test progress with teamcity service messges. but i dont see anything. this is the only thing showing upNUnit Console Runner 3.0.5509Copyright (C) 2014 Charlie PooleTest Files:    E:\prod\src\work\BuildDrop\Work\bin_x64\test\Test..dllRuntime Environment   OS Version: Microsoft Windows NT 6.3.9600.0  CLR Version: 4.0.30319.0Options    ProcessModel: Default    DomainUsage: Default    Execution Runtime: Not Specified    Work Directory: E:\prod\trimble-connect-desktop\Source    Internal Trace: Off    Display TeamCity Service MessagesAgent process 12092 startingRunning under version 4.0.30319.0, Net 4.5nothing else... can someone tell me how this works?thanks in advance</Description>
  </Issue>
  <Issue>
    <IssueID>517</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>517</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>V2 Framework Driver does not make use of passed in TestEventListener</Title>
    <CreatedDate>26/02/2015</CreatedDate>
    <ClosedDate>12/03/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>517</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>517</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>517</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>The V2 framework driver always calls the V2 core with a null eventlistener, no matter what has been passed to the run method.This was first reported on the nunit-discuss list as the --teamcity option not working on v2 tests, but it impacts all features that make use of the events generated by a test run. In particular, it causes text output from the test itself to be lost.This needs to be reviewed to see how much work is involved but if possible we should include it in the first beta release.</Description>
  </Issue>
  <Issue>
    <IssueID>515</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>515</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>OSPlatform.IsMacOSX doesn't work</Title>
    <CreatedDate>23/02/2015</CreatedDate>
    <ClosedDate>06/10/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>515</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>515</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>515</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>The implementation of OSPlatform.IsMacOSX depends on Environment.OSVersion.Platform == 6 on MacOSX.  As of Mono 2.2, the implementation changed to NOT return this value:"Notice that as of Mono 2.2 the version returned on MacOS X is still 4 for legacy reasons, too much code was written between the time that the MacOSX value was introduced and the time that we wrote this text which has lead to a lot of user code in the wild to not cope with the newly introduced value."Here is a discussion about this issue and a solution to call uname libc function to determine Mac vs. Linux. </Description>
  </Issue>
  <Issue>
    <IssueID>514</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>nunit console 2.6.4.14.350 crashed- System.Net.Sockets.SocketException</Title>
    <CreatedDate>23/02/2015</CreatedDate>
    <ClosedDate>15/09/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:duplicate</Name>
        <IssueID>514</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Irrespective of nunit console version, it is crashed, means this is observed in older versions also.But it is working with NUnit UI application.Unhandled Exception:System.Net.Sockets.SocketException: An existing connection was forcibly closed by the remote hostServer stack trace:   at System.Net.Sockets.Socket.Receive(Byte[] buffer, Int32 offset, Int32 size, SocketFlags socketFlags)   at System.Runtime.Remoting.Channels.SocketStream.Read(Byte[] buffer, Int32 offset, Int32 size)   at System.Runtime.Remoting.Channels.SocketHandler.ReadFromSocket(Byte[] buffer, Int32 offset, Int32 count)   at System.Runtime.Remoting.Channels.SocketHandler.BufferMoreData()   at System.Runtime.Remoting.Channels.SocketHandler.Read(Byte[] buffer, Int32 offset, Int32 count)   at System.Runtime.Remoting.Channels.SocketHandler.ReadAndMatchFourBytes(Byte[] buffer)   at System.Runtime.Remoting.Channels.Tcp.TcpSocketHandler.ReadAndMatchPreamble()   at System.Runtime.Remoting.Channels.Tcp.TcpSocketHandler.ReadVersionAndOperation(UInt16&amp; operation)   at System.Runtime.Remoting.Channels.Tcp.TcpClientSocketHandler.ReadHeaders()   at System.Runtime.Remoting.Channels.Tcp.TcpClientTransportSink.ProcessMessage(IMessage msg, ITransportHeaders requestHeaders, Stream requestStream, ITransportHeaders&amp; responseHeaders, Stream&amp; responseStream)   at System.Runtime.Remoting.Channels.BinaryClientFormatterSink.SyncProcessMessage(IMessage msg)Exception rethrown at [0]:   at System.Runtime.Remoting.Proxies.RealProxy.HandleReturnMessage(IMessage reqMsg, IMessage retMsg)   at System.Runtime.Remoting.Proxies.RealProxy.PrivateInvoke(MessageData&amp; msgData, Int32 type)   at System.IDisposable.Dispose()   at NUnit.Core.ProxyTestRunner.Dispose()   at NUnit.Util.ProcessRunner.Dispose()   at NUnit.ConsoleRunner.ConsoleUi.Execute(ConsoleOptions options)   at NUnit.ConsoleRunner.Runner.Main(String[] args)</Description>
  </Issue>
  <Issue>
    <IssueID>512</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>512</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Drop the .NET 3.5 build</Title>
    <CreatedDate>21/02/2015</CreatedDate>
    <ClosedDate>26/02/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>512</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:feature</Name>
        <IssueID>512</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>512</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>@rprouse proposed this via email:I've been looking at the .NET 3.5 version of the framework. As far as I can tell, the only additional functionality that it provides is the Assert/Assume.That which takes a Lambda returning Boolean.If I am right, I propose that we drop the .NET 3.5 version of the framework. It seems like a very small increment in functionality compared to maintaining the six projects.</Description>
  </Issue>
  <Issue>
    <IssueID>509</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>509</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Under Linux, not all mono profiles are listed as available</Title>
    <CreatedDate>20/02/2015</CreatedDate>
    <ClosedDate>20/02/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>509</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>509</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>509</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Under a linux build, the Mono 3.5 and 4.5 profiles are not listed as available. Only 2.0 and 4.0 are shown because there's no code to detect the other two!This has been going unnoticed because of issue #508 </Description>
  </Issue>
  <Issue>
    <IssueID>508</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>508</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Travis builds with failure in engine tests show as successful</Title>
    <CreatedDate>20/02/2015</CreatedDate>
    <ClosedDate>20/02/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>508</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>508</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:critical</Name>
        <IssueID>508</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>This has been going on for a while. If the engine test fails, we continue on with other tests and the failed test only shows up as a warning at the end of the log. This can be seen in many recent logs because of an undetected failure in nunit.engine.tests.dll.</Description>
  </Issue>
  <Issue>
    <IssueID>505</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Question about reusing TestDataSource attribute for reading different csv files of same format</Title>
    <CreatedDate>12/02/2015</CreatedDate>
    <ClosedDate>13/02/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>505</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Hello: I have a C# test solution in which I need to write 10 test cases in NUnit. Each test case reads from a different csv file. Each csv file consists of 2 columns (one input and one output) but many rows (&gt;1000). I am using the TestDataSource attribute such as:[Test][TestCaseSource(typeof(GetTestData), "TestData")]public void Test1(GetTestData data){…}with the following GetTestData class:public class GetTestData{  public string CSVFileName { get; set; }  public double input { get; set; }  public double output { get; set; }  public IEnumerable TestData  {    get    {      using (var inputStream = new FileStream(CSVFileName, FileMode.Open, FileAccess.Read))      {        using (var streamReader = new StreamReader(inputStream))        {          string inputLine;          while ((inputLine = streamReader.ReadLine()) != null)          {            var data = inputLine.Split(',');            yield return new GetTestData            {              Intput = Convert.ToDouble(data[0]),              output = Convert.ToDouble(data[1]),            };          }          }      }    }  }}I want to reuse the GetTestData class in all the test cases since all csv files have the same format. Since the CSVFileName is hardcoded in the class it looks like I will have to create a get data class for each test (GetTestData1, GetTestData2, …), although they all share the same code except for the definition of CSVFileName. My question is: How can I take out the CSVFileName variable outside of the class definition so I can reuse the GetTestData class for different csv files? If this is possible, how would the call for each different test look like?In MSTest all you need to do is add the file name as part of the attribute, as in here:[TestMethod,DataSource("Microsoft.VisualStudio.TestTools.DataSource.CSV",           "CSVFileName1.CSV",            "CSVFileName1#CSV",            DataAccessMethod.Sequential),DeploymentItem("CSVFileName1.csv")]public void Test1(){…}[TestMethod,DataSource("Microsoft.VisualStudio.TestTools.DataSource.CSV",           "CSVFileName2.CSV",            "CSVFileName2#CSV",            DataAccessMethod.Sequential),DeploymentItem("CSVFileName2.csv")]public void Test2(){…}…How can I achieve such simplicity with NUnit?Help will be much appreciated!</Description>
  </Issue>
  <Issue>
    <IssueID>504</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>504</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Option --workers:0 is ignored</Title>
    <CreatedDate>12/02/2015</CreatedDate>
    <ClosedDate>20/02/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>504</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>good first issue</Name>
        <IssueID>504</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>504</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>504</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Code in ConsoleRunner.cs does not pass on a setting for the number of worker threads unless it's greater than zero. This is a holdover from earlier versions where zero was the default.There's a subtle point here, which we should keep in mind. The runner should not really depend on assumptions of what the engine defaults are, since they can change. If the runner wants to enforce a particular default, then it should always provide the setting. Some settings have a value named Default. When that is used, it means "let the engine decide."In this case, the engine default is based on the number of processors available. If we want to tell the engine not to use any threads or to use a specific number of threads, then we have to pass a setting.</Description>
  </Issue>
  <Issue>
    <IssueID>502</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Separate assembly for constraints</Title>
    <CreatedDate>10/02/2015</CreatedDate>
    <ClosedDate>02/12/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:wontfix</Name>
        <IssueID>502</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>and nuget package, obviously. Are there any chances of this happening? Any way I can help?</Description>
  </Issue>
  <Issue>
    <IssueID>500</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Are you aware of the Gitter chat thing?</Title>
    <CreatedDate>08/02/2015</CreatedDate>
    <ClosedDate>26/05/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:wontfix</Name>
        <IssueID>500</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:idea</Name>
        <IssueID>500</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Sample:I think only members of the project can create the room.</Description>
  </Issue>
  <Issue>
    <IssueID>497</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>497</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Framework installer should register the Portable Framework</Title>
    <CreatedDate>08/02/2015</CreatedDate>
    <ClosedDate>09/02/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>497</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>497</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>497</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>The framework installer currently registers the Framework assemblies in the registry so that they appear in the add references dialog of Visual Studio. This is done by adding them to `HKMU\Software\Microsoft\.NETFramework\v4.5\AssemblyFoldersEx`.All of the standard frameworks (2.0, 3.5, etc) are registered, but I do not know what to use for the portable framework, nor can I find any information online.</Description>
  </Issue>
  <Issue>
    <IssueID>495</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>495</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Resolve possible dependency to nunit in nunitlite package</Title>
    <CreatedDate>07/02/2015</CreatedDate>
    <ClosedDate>23/09/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>495</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>NUnitLite package does not have dependency to NUnit package. If create empty console application and add NUnitLite package solution won't compile, you have to add manually NUnit package too. If NUnitLite package had the dependency to NUnit package it would be added automatically.</Description>
  </Issue>
  <Issue>
    <IssueID>494</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>nunitlite exception: couldn't load type "NUnitLite.Runner.TextUI"</Title>
    <CreatedDate>07/02/2015</CreatedDate>
    <ClosedDate>08/02/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>494</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Not sure if it's bug or expected behaviour.Create the empty console project named "nunitlite". Add nuget package "NUnitLite" to it. Compile and run. The exception will be raised  `couldn't load type "NUnitLite.Runner.TextUI"`. The exception is raised because the type is loaded from `nunitlite.exe` file, not `nunitlite.dll`. As a simple workaround just rename output assembly from "nunitlite.exe" to "nunitlite1.exe" and nunitlite will run as expected.</Description>
  </Issue>
  <Issue>
    <IssueID>493</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>List of classes that have been tested</Title>
    <CreatedDate>06/02/2015</CreatedDate>
    <ClosedDate>25/10/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:wontfix</Name>
        <IssueID>493</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:idea</Name>
        <IssueID>493</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>review</Name>
        <IssueID>493</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Is it possible to get a list of classes that have been tested after a test run? </Description>
  </Issue>
  <Issue>
    <IssueID>488</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>simoneb</FixedById>
        <IssueID>488</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Async setup and teardown still don't work</Title>
    <CreatedDate>02/02/2015</CreatedDate>
    <ClosedDate>03/02/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>488</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>488</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>488</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>As reported in #447, async setup and teardown still do not work because there's a check still in place for setup and teardown methods' return types which doesn't allow non-void return types.</Description>
  </Issue>
  <Issue>
    <IssueID>487</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>487</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>NUnitLite can't load assemblies by their file name</Title>
    <CreatedDate>02/02/2015</CreatedDate>
    <ClosedDate>04/02/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>487</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>487</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>487</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Create new console project 'test', add nunitlite nuget package to the project, compile and run the project:`test.exe test.exe`There will be an error: `the file or assembly "test.exe" could not be loaded`. nunitlite requires to pass assembly name instead of file name as parameter, and this does not allow to pass assemblies which are located in other directories and differs from behaviour of nunit-console, which requires to pass file names in command line. More info in #481</Description>
  </Issue>
  <Issue>
    <IssueID>486</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Running NUnit from "Gallio Iracus" runner</Title>
    <CreatedDate>02/02/2015</CreatedDate>
    <ClosedDate>02/02/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>486</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Hi,I am trying to run my nunit tests with gallio runner, and the "TestContext.CurrentContext.Test.FullName" property is throwing null reference exception. Do you familiar with this issues ? is it possible to fix it some how ?Thx</Description>
  </Issue>
  <Issue>
    <IssueID>485</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>485</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Can't run v2 tests with nunit-console 3.0</Title>
    <CreatedDate>02/02/2015</CreatedDate>
    <ClosedDate>03/02/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>485</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>485</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:critical</Name>
        <IssueID>485</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I made a test project which uses nunit.framework 2.6.4 from stable nuget package. Then I try to run it using nunint-console 3.0.0-alpha-5a, installed from nuget package and I've got an error:``The project reference: Logs with error:</Description>
  </Issue>
  <Issue>
    <IssueID>484</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>484</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Missing file in NUnit.Console nuget package</Title>
    <CreatedDate>02/02/2015</CreatedDate>
    <ClosedDate>02/02/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>484</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>484</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:critical</Name>
        <IssueID>484</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>install NUnit.Console 3.0.0-alpha-5 from nuget`nuget install NUnit.Console -pre`then run `nunit-console test.exe` where test.exe is non-existing fileYou'll get the error message (could not find Mono.Addins):``Expected result: error message that `test.exe` could not be found.OS: Windows 7Comments: Looks like there is a missing dependency to Mono.Addins in nunit-console 3a5. I copied Mono.Addins to `tools` folder and the error has gone.</Description>
  </Issue>
  <Issue>
    <IssueID>482</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>482</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>nunit-console has multiple errors related to -framework option</Title>
    <CreatedDate>01/02/2015</CreatedDate>
    <ClosedDate>08/02/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>482</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>482</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>482</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>If you run `nunit-console.exe --framework=net-4.159 assembly.dll` (set the framework version to non-existing one)you'll see the header output, and test will be run`Execution runtime: net-4.159`expected result: there should be an error "The net-4.159 framework is not available"</Description>
  </Issue>
  <Issue>
    <IssueID>481</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>481</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Testing multiple assemblies in nunitlite</Title>
    <CreatedDate>31/01/2015</CreatedDate>
    <ClosedDate>19/04/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:duplicate</Name>
        <IssueID>481</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:feature</Name>
        <IssueID>481</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>There are two issues for me in the nunitlite.runner1. Why not to use Assembly.LoadFrom here?      It's more convenient to pass path in command line (ablosute or relative) to assembly instead of it's name. At my user experience I couldn't deternime the reason "assebmly could not be found" for a while before I have run the "strace" command and found that the nunitlite tries to load "myassembly.dll.dll" file. This behaviour also differs from nunit-console behaviour, when your pass the path to the assemlby in command line.2. Why it runs tests only for the first assembly in the assemblies list?       It's looking strange. Here is use-case example: I have a project with four test assemblies: asm1, asm2, asm3, asm4. I want to run tests without additional components installation, so I decided to create the exe project, which runs all of these assemblies and pushes the result to CI server. Now I can't do this, because only first assembly will be tested and I have to write the script, which iterates over the assemblies and then have to write XML-merging tool to aggregate the result. Why not to do this inside the nunitlite.runner? </Description>
  </Issue>
  <Issue>
    <IssueID>480</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Slow performance of nunit-console</Title>
    <CreatedDate>31/01/2015</CreatedDate>
    <ClosedDate>18/05/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:norepro</Name>
        <IssueID>480</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>confirm</Name>
        <IssueID>480</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I've noticed, that tests are being run in nunit-console  performing much slower than running them in Visual Studio or in simple console application. nunit-console performs 4-5 times slower on some tests.  I've tested this with NUnit 2.6.4, NUnit 3.0.0-alpha4 (from nuget packages) and with NUnit compiled from master branch (with changes from 2.0 target framework to 4.0 target framework of nunit-console and other projects). I tried various settings of --domain and --process parameters, they didn't help.Here is the project which demonstrates the issue:test  `UnitTest.GenericsTests.GenericInheritance` takes 15-17 seconds on my machine if run it from Visual Studio tests or make a simple console application, which calls this method.When I run it from nunit-console, it takes about 80 seconds. Also I wrote a small app, which can be used to investigate the issue. When I run test from Visual Studio or console or with nunitlite it takes 22 seconds to run. If I run it using nunit-console it takes 36 seconds. However I can't be sure for 100% that the app shows the same issue as the first one.The test case, I test: This is critical issue, because it does not allow to run unit-tests on build machines with limited build time (like appveyor service).Also I am looking for a workaround how I can run unit tests on the build machine and get the results on time with current versions of nunit libraries. I tried to use nunitlite but seems that all tests must be located in the *.exe assembly, and nunitlite can't load tests from other assemblies (no matter are they references or don't referenced by nunitlited exe). If it were able to load assemblies I would have create the console app with references to current tests and run them from command line.</Description>
  </Issue>
  <Issue>
    <IssueID>478</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>478</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>RepeatAttribute</Title>
    <CreatedDate>29/01/2015</CreatedDate>
    <ClosedDate>17/04/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>478</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:feature</Name>
        <IssueID>478</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>478</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>NUnit 2.6 has a RepeatAttribute. It's currently #ifed out of our 3.0 source. We need to decide if we are going to implement it as is or make some changes. People ask for it (sometimes for bad reasons) so I don't think it should be simply dropped.Current semantics are that the test is run n times or until it fails, whichever comes first. IOW, it has to pass all n times in order to pass.We have had requests in the past for only repeating the test in the case of failure. IOW, it would be more like a Retry attribute.Conceivably, we could generalize this to repeating the test up to n times subject to some rules specified in additional arguments. We could expose the options to the user if we liked or we could simply use such a generalized repeat facility as a base class for various attributes.We also have a request for ThreadedRepeat, which would run the tests n times on different threads. See #5.I'm marking this issue as status:design. We should first come up with a spec for what we are going to support and then incorporate the result into 3.0.</Description>
  </Issue>
  <Issue>
    <IssueID>477</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>477</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Assert does not work with ArraySegment</Title>
    <CreatedDate>29/01/2015</CreatedDate>
    <ClosedDate>10/02/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>477</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>477</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>477</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Reported by @xplicit in nunit/nunitv2#39, moved here because we will not fix it in 2.6This code throws an exception on .NET, while it should be passed. With mono 3.12 it works. The same issue with NUnit v 3.0``</Description>
  </Issue>
  <Issue>
    <IssueID>476</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Multiple TestFixtureAttributes on Base class are not run</Title>
    <CreatedDate>28/01/2015</CreatedDate>
    <ClosedDate>02/09/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>476</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>476</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>The following was submitted in error to the defunct nunit-console project by @britianoates:When we compile and run the following from nunit console, we only see the double version of the test.  We have seen both types run in Visual Studio.  We have rechecked our expectations against the documentation at ``Expected:  2 tests to be ranActual:   1 tests is ran</Description>
  </Issue>
  <Issue>
    <IssueID>475</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>[Parallelizable] attribute at textfixture level is not running test parallel - Followup question in comment.</Title>
    <CreatedDate>28/01/2015</CreatedDate>
    <ClosedDate>28/01/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>475</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I have updated to NUnit3.0 and added [Parallelizable] attribute to 2 test fixtures at same level . When I run them in my local machine and when checked using Resharper unit test sessions they are running one after the other not starting parallel. What am I missing?  Could you please assist. Please do let me know if you require additional details. </Description>
  </Issue>
  <Issue>
    <IssueID>474</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>TypeHelperTests.cs is orphaned</Title>
    <CreatedDate>28/01/2015</CreatedDate>
    <ClosedDate>30/12/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>474</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:refactor</Name>
        <IssueID>474</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:low</Name>
        <IssueID>474</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>PR #434 Created a new test file TypeHelperTests.cs but never added it to any of the projects.</Description>
  </Issue>
  <Issue>
    <IssueID>473</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Expression-based Has.Property</Title>
    <CreatedDate>27/01/2015</CreatedDate>
    <ClosedDate>21/02/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:duplicate</Name>
        <IssueID>473</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:idea</Name>
        <IssueID>473</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>It would be great if `Has.Property` would have expression-based version (to avoid strings):``</Description>
  </Issue>
  <Issue>
    <IssueID>472</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>472</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Overflow exception and DivideByZero exception from the RangeAttribute</Title>
    <CreatedDate>27/01/2015</CreatedDate>
    <ClosedDate>20/06/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>472</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>472</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:low</Name>
        <IssueID>472</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Specific data values fed to the RangeAttribute can trigger a DivideByZero exception and/or an OverflowException. These values have been pointed out by the Smart Unit Tests feature from Visual Studio 2015, and an image with the data values is attached.The DivideByZero may happen by the user entering 0 as a step value.The OverflowException is more serious as it highlights an implicit constraint saying “to &gt; from” that is not stated anywhere. There should there be any need for that.![exceptions](These issues are seen for all the RangeAttribute overloads.Please let me know if you need any further information.Pratap Lakshman</Description>
  </Issue>
  <Issue>
    <IssueID>468</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>468</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Change default domain usage to multiple</Title>
    <CreatedDate>25/01/2015</CreatedDate>
    <ClosedDate>26/01/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>good first issue</Name>
        <IssueID>468</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>468</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>468</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Benefits of this change:- It's consistent with how we handle the process model- It provides the highest level of isolation as a default- It avoids failures when running a v2 test assembly together with a  v3 assembly</Description>
  </Issue>
  <Issue>
    <IssueID>465</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>nunit.engine project is not built before projects that have dependency</Title>
    <CreatedDate>19/01/2015</CreatedDate>
    <ClosedDate>23/01/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>465</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Repro steps:1. Open solution in VS20132. Clean build3. BuildBuild errors are seen.</Description>
  </Issue>
  <Issue>
    <IssueID>464</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Async delegate assertions</Title>
    <CreatedDate>18/01/2015</CreatedDate>
    <ClosedDate>20/01/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>464</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:feature</Name>
        <IssueID>464</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>464</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>All assertions that take TestDelegate should have correlating methods that take an asynchronous equivalent (Task AsyncTestDelegate()). E.g., Assert.Throws(TestDelegate) should have a matching Assert.ThrowsAsync(AsyncTestDelegate) or Assert.Throws(AsyncTestDelegate). This would enable this kind of usage:``Also, some synchronous assertion code has outdated code; e.g., Assert.Throws will try to create an AsyncInvocationRegion that will never succeed, since AIR (correctly) rejects async void methods and TestDelegate returns void. Ideally, AIR should only be used when executing the [Test] methods themselves, not within any other code.</Description>
  </Issue>
  <Issue>
    <IssueID>460</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Portable version of NunitLite shouldn't reference System.Windows</Title>
    <CreatedDate>15/01/2015</CreatedDate>
    <ClosedDate>26/05/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:duplicate</Name>
        <IssueID>460</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>The PCL version of NUnitLite (in 3.0 alpha 3 from nuget) currently references System.Windows.dll, and includes the Silverlight TestPage runner.  This should be removed to provide a truly portable runner that can be used for all platforms, including Xamarin.</Description>
  </Issue>
  <Issue>
    <IssueID>459</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>459</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Remove the Mixed Platforms build configuration</Title>
    <CreatedDate>14/01/2015</CreatedDate>
    <ClosedDate>23/01/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>459</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:build</Name>
        <IssueID>459</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>459</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>The solution keeps adding either a Mixed Platforms platform or an Any CPU platform when we add projects because of the projects that target x86/x64. To fix,-  Move the C++ test projects out to their own solution. We can build and test with them when needed.- Remove the nunit.agent.x86 project from the solution.- Build nunit.agent.x86.exe from the nunit.agent.exe project using MSBuild in NUnit.proj. We do this in NUnit 2.6.4.</Description>
  </Issue>
  <Issue>
    <IssueID>454</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>voloda</FixedById>
        <IssueID>454</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Rare registry configurations may cause NUnit to fail</Title>
    <CreatedDate>09/01/2015</CreatedDate>
    <ClosedDate>30/04/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>454</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>454</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>454</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Having recently upgraded my NUnit version on one of my old machines I got``Looking through the code and then at the registry, I found that I still had the .net 4 Beta 2 Windows Update Opt-in Key `HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\NET Framework Setup\NDP\v4B2WU` (see While this particular case may affect about one other person who forgot to delete this key, it suggests that there may in future be other legitimate instances where keys beginning v may not be followed by a version number; and such keys should be skipped (possibly with a warning logged).</Description>
  </Issue>
  <Issue>
    <IssueID>452</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Deprecate the existing Chocolatey framework package</Title>
    <CreatedDate>09/01/2015</CreatedDate>
    <ClosedDate>19/07/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>452</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:build</Name>
        <IssueID>452</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>452</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>452</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>[Chocolatey]( is becoming a popular way of setting up development machines and installing software using PowerShell. People have already released NUnit 2 Chocolatey packages,  but we should be releasing official verified versions.I am marking this low priority since NuGet is our major distribution channel, but with Chocolatey's recent successful KickStarter campaign, it is going to become even more popular.Information on creating packages is available at </Description>
  </Issue>
  <Issue>
    <IssueID>451</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Add the ability to stop a run in NUnitLite</Title>
    <CreatedDate>08/01/2015</CreatedDate>
    <ClosedDate>22/09/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:wontfix</Name>
        <IssueID>451</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:feature</Name>
        <IssueID>451</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>451</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>NUnitTestAssemblyRunner has the ability to stop a run currently in progress.  However, that ability is not invokable in NUnitLite.  Currently, only the FrameworkController calls the Runner.StopRun method.The ability to cleanly stop a run in progress should be added to the NUnitLite runner.This may mean running the NUnitLite runner on another thread so that additional console input can be given while the tests are running.This is what my current Crestron CF build in fact does.</Description>
  </Issue>
  <Issue>
    <IssueID>450</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>450</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Create master install that includes the framework, engine and console installs</Title>
    <CreatedDate>07/01/2015</CreatedDate>
    <ClosedDate>23/02/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>450</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:build</Name>
        <IssueID>450</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>450</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>For an example on creating merge modules, see </Description>
  </Issue>
  <Issue>
    <IssueID>449</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>NUnit 2.6.3 ExpectedException</Title>
    <CreatedDate>05/01/2015</CreatedDate>
    <ClosedDate>05/01/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>449</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Hi there,I was using NUnit 2.4.8 framework. I tried to migrate this 2.4.8 to 2.6.3, and just by doing that my tests with ExcpectedException started to fail (not passing, raising the exception instead of "hiding" it).I searched a lot and couldn't find any change in the framework that could lead to the change of my code.All my tests look like:``Any ideas about this?Thanks!</Description>
  </Issue>
  <Issue>
    <IssueID>335</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>335</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Re-introduce 'Classic' NUnit syntax in NUnitLite</Title>
    <CreatedDate>04/11/2014</CreatedDate>
    <ClosedDate>07/11/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>335</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:feature</Name>
        <IssueID>335</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>335</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>The following 'classic' syntax asserts are excluded from NUnitLite:- IsNaN- IsEmpty- IsNotEmpty- IsAssignableFrom- IsNotAssignableFrom- IsAssignableTo- IsNotAssignableTo- IsInstanceOf- IsNotInstanceOf- Greater- Less- GreaterOrEqual- LessOrEqual- ContainsThey should be re-introduced, possibly in a separate namespace. If a separate namespace is used, the same change should apply to the full NUnit framework.The following classes are also excluded:- StringAssert- CollectionAssert- FileAssert- DirectoryAssertThey should be added as well, on platforms that support them. FileAssert and DirectoryAssert should be excluded on any platform that excludes the file-related constraints, such as Silverlight.Design issues:- Should we use a separate namespace for classic asserts?- Should we use a separate namespace for MsTest-compatible asserts?- Should we use a separate assembly for either of the above?</Description>
  </Issue>
  <Issue>
    <IssueID>334</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>334</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Include File-related constraints and syntax in NUnitLite builds</Title>
    <CreatedDate>04/11/2014</CreatedDate>
    <ClosedDate>05/11/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>334</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:feature</Name>
        <IssueID>334</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>334</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Builds of NUnitLite exclude file-related constraints and assertion syntax. As a step toward unifying NUnit and NUnitLite, these items should be included based on platform or excluded on platforms that don't support them. Currently, they should be supported for all desktop builds and for the compact framework.</Description>
    <PullRequests />
  </Issue>
  <Issue>
    <IssueID>333</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>333</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Add parallel execution to desktop builds of NUnitLite</Title>
    <CreatedDate>04/11/2014</CreatedDate>
    <ClosedDate>05/11/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>333</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:feature</Name>
        <IssueID>333</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>333</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>As a part of #284 we decided that NUnitLite builds for platforms that can support parallel execution should allow it. Currently, this only means the desktop .NET builds.At least for the time being, we can add a define of PARALLEL to the desktop builds and eliminate the use of !NUNITLITE. This is one step toward removing the NUNITLITE distinction from the framework.</Description>
    <PullRequests />
  </Issue>
  <Issue>
    <IssueID>332</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>dicko2</FixedById>
        <IssueID>332</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Add CF to the Appveyor CI build</Title>
    <CreatedDate>04/11/2014</CreatedDate>
    <ClosedDate>06/03/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>332</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:build</Name>
        <IssueID>332</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:low</Name>
        <IssueID>332</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>As indicated by #331 we keep breaking the compact framework build without realizing it. We need to at least compile it in our CI and if possible run the tests. Without installing a bunch of stuff in Appveyor, we'll probably only be able to run it using assembly unification under desktop .NET for now.</Description>
  </Issue>
  <Issue>
    <IssueID>331</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>331</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Alpha 2 CF does not build</Title>
    <CreatedDate>04/11/2014</CreatedDate>
    <ClosedDate>05/11/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>331</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>331</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:critical</Name>
        <IssueID>331</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>It gets a compile error in src/NUnitFramework/tests/Constraints/DelayedConstraintTests.cs in the Delay method.NETCF does not have a WaitHandle.WaitOne (timeout) overload.</Description>
  </Issue>
  <Issue>
    <IssueID>330</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>330</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Create Test and TestResult objects in the engine for use by runners</Title>
    <CreatedDate>03/11/2014</CreatedDate>
    <ClosedDate>16/11/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:wontfix</Name>
        <IssueID>330</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:idea</Name>
        <IssueID>330</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>330</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>This task is in support of a number of other issues: #254, #265, #281, #286, #294 Currently, the engine result is not in the form of an object but is an Xml node. We need to create a wrapper object for the Xml, which has properties for the commonly used elements and attributes as well as a way of getting additional attributes as needed.The Test and TestResult objects should implement interfaces, most likely the same ITest and ITestResult that are used in the framework. The interfaces will need to be shared at the source code level, since the engine cannot have a reference to the framework.</Description>
    <PullRequests />
  </Issue>
  <Issue>
    <IssueID>329</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>329</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>(CLI) Runner does not report AppDomain unloading timeout</Title>
    <CreatedDate>03/11/2014</CreatedDate>
    <ClosedDate>20/06/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>329</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>329</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>329</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Currently `DomainManager.DomainUnloader.Unload` is silently\* timing `AppDomain.Unload(domain)` out after 30 seconds.- an entry like `09:35:36.420 Error [ 1] DomainManager: Unable to unload AppDomain test-domain-FOOBAR.dll, Unload thread timed out` is logged to the NUnit trace log (%AppData%..\Local\NUnit\logs.[msdn]( states that&gt;  If a thread does not abort, for example because it is executing unmanaged code, or because it is executing a finally block, then after a period of time a CannotUnloadAppDomainException is thrown in the thread that originally called Unload. If the thread that could not be aborted eventually ends, the target domain is not unloaded. Thus, in the .NET Framework version 2.0 domain is not guaranteed to unload, because it might not be possible to terminate executing threads. To sum it up:- the `AppDomain` is not necessarily unloaded when `DomainUnloader.Unload` finishes  - could this lead to issues when running other test assemblies subsequently?  - it is still unloaded, however, when the process is exited (which is still possible)- the issue is not made visible to the user.- There is no statement made by microsoft how long `.Unload(domain)` takes before it times out with an `CannotUnloadAppDomainException`- `CannotUnloadAppDomainException` may indicate serious issues in either productive or test code  - i don't know about the part "for example because it is executing unmanaged code"... i think when a unit test ends, so should all processing of the unit under test.Also see </Description>
    <PullRequests />
  </Issue>
  <Issue>
    <IssueID>328</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>328</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Use .NET Stopwatch class for compact framework builds</Title>
    <CreatedDate>02/11/2014</CreatedDate>
    <ClosedDate>06/11/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>328</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:feature</Name>
        <IssueID>328</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>328</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>We currently use our own inplementation of Stopwatch in CF builds. We should use that of .NET. Tests should be fixed so we no longer test our implementation under the compact framework and the duration of tests should be calculated using stopwatch ticks.</Description>
    <PullRequests />
  </Issue>
  <Issue>
    <IssueID>327</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>oznetmaster</FixedById>
        <IssueID>327</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Allow Generic test methods in the compact framework</Title>
    <CreatedDate>02/11/2014</CreatedDate>
    <ClosedDate>14/11/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>327</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:feature</Name>
        <IssueID>327</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>327</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Generic methods were not implemented in the compact framework build due to some differences in how they are implemented in CF. Essentially, it's not possible to work with open generic types in CF the way it is in the desktop versions of .NET. Consequently, a lot of what we do has to be done differently.Neil has a build that includes generics, so I'll merge in his code with ours to get it to work.</Description>
    <PullRequests />
  </Issue>
  <Issue>
    <IssueID>326</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>326</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Add TimeoutAttribute to compact framework build</Title>
    <CreatedDate>02/11/2014</CreatedDate>
    <ClosedDate>14/11/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>326</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:feature</Name>
        <IssueID>326</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>326</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Include tests as well.</Description>
  </Issue>
  <Issue>
    <IssueID>325</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>325</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Add RegexConstraint to Compact Framework build</Title>
    <CreatedDate>02/11/2014</CreatedDate>
    <ClosedDate>07/11/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>325</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:feature</Name>
        <IssueID>325</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>325</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>The constraint is currently #if'd out of NETCF builds. It should be included, as well as its tests and the associated "Matches" syntax.</Description>
  </Issue>
  <Issue>
    <IssueID>322</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>322</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Remove Stopwatch tests where they test the real .NET stopwatch</Title>
    <CreatedDate>30/10/2014</CreatedDate>
    <ClosedDate>30/10/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>322</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>good first issue</Name>
        <IssueID>322</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:refactor</Name>
        <IssueID>322</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>322</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Except for CF and Silverlight, our tests are testing the actual .NET Stopwatch. This would not be a problem except that we get failures on some of these tests due to timing uncertainties.We should leave the tests in for those builds where the Stopwatch being tested is our own implementation. For the other builds, we should either remove them entirely or add a single test that checks that Stopwatch is the actual .NET class.</Description>
  </Issue>
  <Issue>
    <IssueID>321</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>321</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Rationalize how we count tests</Title>
    <CreatedDate>30/10/2014</CreatedDate>
    <ClosedDate>22/06/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>321</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:docs</Name>
        <IssueID>321</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>321</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>We need to have one central statement and, if possible, one central bit of code, which counts tests in various categories. Right now, it's pretty adhoc and the code is distributed in several places in the framework, engine and console.Particular issues to resolve:- Do we count invalid tests as errors or as not run?- How do we count child test cases of  - an invalid fixture (including SetUpFixtures)  - an ignored fixture (either using an attribute or via Assert.Ignore)  - a fixture that fails or errors in its OneTimeSetUp  - a fixture that fails or errors in a Before action- How do we count (or should count) Explicit tests and child tests of Explicit fixtures- How are those counts reported  - on the Xml reports (nunit3 and nunit2)  - on the console reports (nunit-console and nunitlite)- What detail is shown in the console reportsTo resolve this issue, I think we need a spec written, reviewed and implemented.</Description>
  </Issue>
  <Issue>
    <IssueID>320</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>320</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>No Tests found: Using parametrized Fixture and TestCaseSource</Title>
    <CreatedDate>30/10/2014</CreatedDate>
    <ClosedDate>14/05/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>320</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>320</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>320</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Using: NUnit Console Runner 3.0.5378The following construct seems to make problems. The nunit runner doesn't find any tests in an assembly if the following TestFixture is implemented in the test assembly.``</Description>
  </Issue>
  <Issue>
    <IssueID>319</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>319</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>CI builds are not treating test failures as failures of the build</Title>
    <CreatedDate>30/10/2014</CreatedDate>
    <ClosedDate>02/11/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>319</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>319</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:critical</Name>
        <IssueID>319</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>This applies to both the Travis and the Appveyor builds. The problem is in the NUnit.proj MsBuild script. The script is written to ignore test failures in order to force all the tests to run. We need to keep track of whether any tests have failed and error the build at the end if that's the case.I've made some attempts to do this and some of the infrastructure is still present in the script. There seems to be an issue with the scope of MsBuild items and properties, which I don't understand.</Description>
  </Issue>
  <Issue>
    <IssueID>318</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>318</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>TestActionAttribute: Retrieving the TestFixture</Title>
    <CreatedDate>30/10/2014</CreatedDate>
    <ClosedDate>18/03/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>318</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>318</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>318</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>In NUnit 2.6.3 it was possible to access the TestFixture in a TestActionAttribute through TestDetails.Fixture.The new ITest interface, which is used e.g. in the BeforeTest Method, seems not the have the possibility to retrieve the TestFixture. Is there some way to achieve this?</Description>
  </Issue>
  <Issue>
    <IssueID>316</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>316</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>NUnitLite TextUI Runner</Title>
    <CreatedDate>29/10/2014</CreatedDate>
    <ClosedDate>22/04/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>316</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>316</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>316</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Currently, the TextUI runner loads the alternative assembly specified on the command line by calling Assembly.Load (assemblyName).  This requires that the specified assembly be either in the same directory as the executable, or on the probing path.It would seem useful to allow the alternative assembly to be located anywhere.  The Assembly.LoadFrom (assemblyFile) allows the assembly to be located anywhere, since assemblyFile is "The name or path of the file that contains the manifest of the assembly".I have found this to be very useful in my CF implementation, allowing me to put the assemblies containing tests in their own subdirectory.  I check the provided name for a directory separator character or an extension, and call the LoadFrom method if name has either.  Otherwise, I call the normal Load method. This is definitely a non-necessary enhancement.  Just a convenience.</Description>
  </Issue>
  <Issue>
    <IssueID>315</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>315</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>NUnit 3.0 alpha: Cannot run in console on my assembly</Title>
    <CreatedDate>29/10/2014</CreatedDate>
    <ClosedDate>31/10/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>315</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>315</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:docs</Name>
        <IssueID>315</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:critical</Name>
        <IssueID>315</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I tried to run tests on my assembly in console mode. I worked with NUnit 2.6.3 (using nunit-console-x86.exe version), but it didn't work using NUnit 3.0 alpha's nunit-console.exe.Here's the output:NUnit Console Runner 3.0.5378 Copyright (C) 2014 Charlie PooleRuntime Environment   OS Version: Microsoft Windows NT 6.1.7601 Service Pack 1  CLR Version: 4.0.30319.18444Options    ProcessModel: Default    DomainUsage: Default    Execution Runtime: Not Specified    Worker Threads: 8    Work Directory: C:\s-backup\workspace1\CFF\90.Base.NUnit3\RegressionTests\BusinessLogicTests\bin\Debug    Internal Trace: OffCould not load file or assembly 'BusinessLogicTests, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null' or one of its dependencies. An attempt was made to load a program with an incorrect format.</Description>
  </Issue>
  <Issue>
    <IssueID>312</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>NUnit assembly name</Title>
    <CreatedDate>26/10/2014</CreatedDate>
    <ClosedDate>26/10/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:wontfix</Name>
        <IssueID>312</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Any chances that new NUnit version will include assembly name change from nunit.framework to NUnit.Framework or even NUnit? Just for consistency sake with all other .NET assemblies out there and the namespace.</Description>
  </Issue>
  <Issue>
    <IssueID>311</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>nunit-console.exe throws exception</Title>
    <CreatedDate>26/10/2014</CreatedDate>
    <ClosedDate>23/01/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:duplicate</Name>
        <IssueID>311</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>design</Name>
        <IssueID>311</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>311</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>This was originally an nunit-console issue...nunit-console.exe throws the following error while i tried to execute from Mapped Network DriveUnhandled Exception: System.TypeInitializationException: The type initializer for 'NUnit.ConsoleRunner.Runner' threw an exception. ---&gt; System.Security.SecurityException: That assembly does not allow partially trusted callers. at NUnit.ConsoleRunner.Runner..cctor() The action that failed was: LinkDemand The assembly or AppDomain that failed was: nunit-console-runner, Version=2.6.3.13283, Culture=neutral, PublicKeyToken=96d09a1eb7f44a77 The method that caused the failure was: NUnit.Core.Logger GetLogger(System.Type) The Zone of the assembly that failed was: Internet The Url of the assembly that failed was: file:///Z:/jenkinsworkspace/workspace/FlashUpload/tools/NUnit/lib/nunit-console-runner.DLL --- End of inner exception stack trace --- at NUnit.ConsoleRunner.Runner.Main(String[] args) at NUnit.ConsoleRunner.Class1.Main(String[] args)i tried the following methods to fix.added loadFromRemoteSources enabled="true" in nunit-console.exe.configBut the change did not solve the problem.</Description>
  </Issue>
  <Issue>
    <IssueID>310</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Target framework not specified on the AppDomain when running against .Net 4.5</Title>
    <CreatedDate>26/10/2014</CreatedDate>
    <ClosedDate>03/07/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>310</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>310</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>310</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>This issue was originally written against the nunit-console project:It seems that the target framework is not specified on the AppDomain when running tests against _.Net 4.5_. This causes some code to revert back to the old _4.0_ behaviour.For example `Uri.IsWellFormedUriString(" UriKind.RelativeOrAbsolute)`returns - `False` in _4.0_ - `True` in _4.5_ with TargetFramework _4.5_- `False` in _4.5_ with no TargetFramework specifiedThe only way I found to work around this issue is to compile the _agent_ using the _4.5_ framework.</Description>
  </Issue>
  <Issue>
    <IssueID>309</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>309</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>NUnit-Console should support incremental output under TeamCity</Title>
    <CreatedDate>26/10/2014</CreatedDate>
    <ClosedDate>23/11/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>309</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:feature</Name>
        <IssueID>309</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>309</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Issue moved from nunit-console project. See  for full description and comments.</Description>
  </Issue>
  <Issue>
    <IssueID>308</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>308</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Early disposal of runners</Title>
    <CreatedDate>26/10/2014</CreatedDate>
    <ClosedDate>19/11/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>308</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>308</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>308</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>In some situations, it may be necessary to dispose of each runner after the tests have been executed. This arises from the problem described in the following Launchpad bug:As explained in one of the comments on the above bug, it's not so simple as always releasing the runners after each run. The gui, at least in NUnit 2.x, assumes that the runners are available once loaded.All options to resolve this issue involve adding a setting to the TestPackage, which will cause subordinate runners to be released once they have returned a result. This is probably only possible for synchronous runs.As an initial solution, we can simply have the console runner use the new setting, while the Gui will leave it to default.We could consider a more dynamic solution for the gui. This would involve re-creating the runners if they have been released and reloading the assembly. There would be interaction between this feature and the "Reload on Run" feature we currently support, so we would have to deal with that. Let's do the simple fix first and then decide if the more complex fix is needed. If so, it should become an issue on the nunit-gui project.</Description>
  </Issue>
  <Issue>
    <IssueID>306</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>306</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Assure NUnit can write resultfile</Title>
    <CreatedDate>25/10/2014</CreatedDate>
    <ClosedDate>20/11/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>306</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>306</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>306</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>This was originally filed under the nunit-console repo. See description and comments there:</Description>
  </Issue>
  <Issue>
    <IssueID>305</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Interpretation of include/exclude options should be made clearer.</Title>
    <CreatedDate>25/10/2014</CreatedDate>
    <ClosedDate>15/11/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>305</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>305</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>305</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>The console runner output should use wording that indicates aaa-bbb is a category expression rather than a simple category.More info at Note that this will no longer be an issue if the syntax we use for the new nunit-console doesn't use '-' as an operator.</Description>
  </Issue>
  <Issue>
    <IssueID>304</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Run test Assemblies in parallel</Title>
    <CreatedDate>25/10/2014</CreatedDate>
    <ClosedDate>17/09/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>304</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:feature</Name>
        <IssueID>304</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>304</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Implement parallel execution of test assemblies in the engine, as detailed in the spec at Originally at </Description>
  </Issue>
  <Issue>
    <IssueID>301</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>oznetmaster</FixedById>
        <IssueID>301</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>command line length</Title>
    <CreatedDate>24/10/2014</CreatedDate>
    <ClosedDate>05/12/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>301</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:feature</Name>
        <IssueID>301</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>301</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I have had an interesting problem occur that may be unique to the S#/Crestron environment.  It has a console command line maximum length of 800 characters.  This severely limits how many tests can be specified on a nunitlite command line.I am adding a new command line option "-testlist:PATH", where PATH is the path to a file containing a list of tests to run.  The test names can be separated by any white space characters, including new line, and/or commas.  The file is read and the tests are added exactly as if they were  specified by the "-test:testname" option.I wonder if this is a useful option to add to general nunitlite/nunit command line options?</Description>
  </Issue>
  <Issue>
    <IssueID>300</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>300</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Create an NUnit Visual Studio Template</Title>
    <CreatedDate>24/10/2014</CreatedDate>
    <ClosedDate>13/12/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>300</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:feature</Name>
        <IssueID>300</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>From the discussion in nunit/nunit-vs-adapter#51See that issue for the discussion on including the service tag the Visual Studio automatically adds to NUnit projects.``If we did a template, I would probably publish it as a Visual Studio extension and install it with the regular NUnit install. I've done a few templates for work including a test template. They aren't too hard, just a bit fiddly.Installing is easy, you just need to copy the Zip file into every supported version of Visual Studio at,C:\Users{user}\Documents\Visual Studio {version}\Templates\ProjectTemplates\Visual C#If we put the template into a subdirectory like NUnit or Test, it will appear under that node in the New Project dialog.</Description>
  </Issue>
  <Issue>
    <IssueID>299</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>oznetmaster</FixedById>
        <IssueID>299</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>No full path to assembly in XML file under Compact Framework</Title>
    <CreatedDate>24/10/2014</CreatedDate>
    <ClosedDate>22/12/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>299</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>299</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>299</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>The &lt;test-suite type="Assembly"&gt; element in the XML file does not contain the full path to the assembly under the compact framework. This is caused by conditional code in DefaultTestAssemblyBuilder.</Description>
  </Issue>
  <Issue>
    <IssueID>298</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>nunitlite and eliminated assertions</Title>
    <CreatedDate>24/10/2014</CreatedDate>
    <ClosedDate>24/10/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:duplicate</Name>
        <IssueID>298</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>A lot of useful assertions were removed from nunitlite.  It makes it difficult to run tests written for nunit in the nunitlite framework.None of these removed assertions seem to need to be eliminated from nunitlite.   They do not seem to address conditions that that would not be present in an nunitlite environment.Was this done for size reasons only?Should they be put back in as part of potential nunit&lt;-&gt;nunitlite integration?</Description>
  </Issue>
  <Issue>
    <IssueID>297</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>297</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>3.0 Xml Output additions</Title>
    <CreatedDate>23/10/2014</CreatedDate>
    <ClosedDate>27/06/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>297</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:feature</Name>
        <IssueID>297</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>297</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>The current 3.0 Xml output includes the environment element which details the information about the version of the os and the verison of nunit used for the test.It does not include any information about the test assembly/assemblies used for the tests.It would seem very useful if the output included the full name of the tested assembly (which includes its version), and the created/modified date/time information.  Perhaps the load path for the assembly as well?</Description>
  </Issue>
  <Issue>
    <IssueID>294</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Provide XSL Transform of XML Results to HTML</Title>
    <CreatedDate>21/10/2014</CreatedDate>
    <ClosedDate>29/06/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:wontfix</Name>
        <IssueID>294</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:idea</Name>
        <IssueID>294</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>NUnit 2 ships with a simple XML -&gt; Text XSL transform, but the results are nearly unreadable. They are just a wall of black text. Here is a small clipped example. This goes on for a thousand lines.![nunit-transform](I am in the process of converting our unit tests over from MbUnit to NUnit 2, but the other devs are really pushing back, mainly because of the reports that are produced. MbUnit ships with really good XSL transforms which we use to produce the web reports from our continuous build server and they are included in the emails that get sent out with every build.Developers also use them when running from the console. MbUnit has a **show report** command line switch and a **report type** switch (text, xml, html, xhtml, etc). The report is then generated in the desired format and launched using a process start to the default application.Here are some examples of the reports that I've taken from our CI server,![mbunit-header](The details for the run contain a great deal of detail, but are easily readable. MbUnit ships with two transforms, full and condensed. Full shows all unit tests, condensed just shows ignored or failed tests. This example is of an ignored test, thus the grey bars as opposed to green.Notice each section and level is collapsible, making it easier to work with the report.![mbunit-details](Here is an example of a failed test. One cool feature is the ReSharper like error bar down the right side. The top shows the overall result, green or red, then below it are red lines for failed tests. You can click on those lines and they will take you to the failed tests. There are also grey lines for ignored tests.Also notice that in the stack trace, user source files are linked. Gallio installs a handler for `gallio:` which will open the source file and navigate to the given line in Visual Studio. Of course this only works if your source is in the same location, but it is very handy when running from the GUI runner. The GUI runner uses an HTML control to display the report as the tests are run and this allows you to quickly jump to the source in Visual Studio for the failing tests.`gallio:navigateTo?path=e:\Source\DotNet\TestingInfrastructure\TestFramework\FileAssert.cs&amp;line=57`![mbunit-failures](</Description>
  </Issue>
  <Issue>
    <IssueID>293</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>oznetmaster</FixedById>
        <IssueID>293</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>CF does not have a CurrentDirectory</Title>
    <CreatedDate>21/10/2014</CreatedDate>
    <ClosedDate>25/11/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>293</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>293</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>293</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>There is no concept of CurrentDirectory in CF.  This means that any I/O operation that uses a relative path for file or directory access will throw an exception.However, many of the tests use relative file paths, or just file or directory names with no paths.These will work without a problem in the normal .NET framework, since the CurrentDirectory is always used to convert relative to absolute paths.I am not sure how these tests have ever run successfully on CF?  Am I missing something?My S# version explicitly converts all relative paths/names to absolute ones for all tests that have them (e.g. FileAssertTests).</Description>
  </Issue>
  <Issue>
    <IssueID>290</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>290</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>StackTrace still displays too many items</Title>
    <CreatedDate>20/10/2014</CreatedDate>
    <ClosedDate>22/10/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>290</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>290</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>290</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>The new StackFilter works fine, and the new StackFilterTests confirms that.  However, the StackFilter is only being applied in a single place, in CompositeWorkItem.SkipFixture.Non-filtered stacks are still being recorded for most failures;at NUnit.Framework.Assert.That[TActual](ResultState actual, IResolveConstraint expression, String message, Object[] args)   at NUnit.Framework.Assert.That[TActual](ResultState actual, IResolveConstraint expression, String message)   at NUnit.Framework.Attributes.TimeoutTests.TimeoutCanBeSetOnTestFixture()   at System.Reflection.RuntimeMethodInfo.InternalInvoke(RuntimeMethodInfo rtmi, Object obj, BindingFlags invokeAttr, Binder binder, Object parameters, CultureInfo culture, Boolean isBinderDefault, Assembly caller, Boolean verifyAccess, StackCrawlMark&amp; stackMark)   at System.Reflection.RuntimeMethodInfo.InternalInvoke(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture, Boolean verifyAccess, StackCrawlMark&amp; stackMark)   at System.Reflection.RuntimeMethodInfo.Invoke(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)   at System.Reflection.MethodBase.Invoke(Object obj, Object[] parameters)   at i.Invoke(Object A_0, Object[] A_1)It seems that StackFilter needs to be applied in a number of other places where Result.SetResult is being called.</Description>
  </Issue>
  <Issue>
    <IssueID>288</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>288</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Set up Appveyor CI build</Title>
    <CreatedDate>20/10/2014</CreatedDate>
    <ClosedDate>28/10/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>288</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:build</Name>
        <IssueID>288</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>288</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Set up a build under Appveyor similar to Travis CI so we are testing in Windows as well as Linux.</Description>
  </Issue>
  <Issue>
    <IssueID>284</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>284</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>NUnitLite Unification</Title>
    <CreatedDate>19/10/2014</CreatedDate>
    <ClosedDate>23/11/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>284</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:refactor</Name>
        <IssueID>284</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>284</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>There is no single point where all the differences are listed. We need this in order to decide about future support for NUnitLite.</Description>
  </Issue>
  <Issue>
    <IssueID>283</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>What should we do when a user extension does something bad?</Title>
    <CreatedDate>19/10/2014</CreatedDate>
    <ClosedDate>23/08/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>283</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:question</Name>
        <IssueID>283</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>NUnit 3.0 leaves lots of room for users to extend things. For example...New attributes may be definedNew ResultStates may be createdThe user-created stuff has to follow certain rules. For example, a ResultState must have a Status value that matches one of our TestStatus enumeration and the generated XML must contain a result attribute with one of those values.Suppose a user messes up and attempts to define a new TestStatus. This is not allowed since NUnit won't know whether or not the test passed. Or suppose the user messes up by overriding the Xml generation and puts a bad value there. What do we think should happen in these cases?Currently BTW the code treats an invalid status as Passed. I don't think this is good, but I don't like any of the alternative assumptions any better. Should we be throwing? If so, at what point?</Description>
  </Issue>
  <Issue>
    <IssueID>282</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Get tests for NUnit2XmlOutputWriter working</Title>
    <CreatedDate>19/10/2014</CreatedDate>
    <ClosedDate>20/10/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>282</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:refactor</Name>
        <IssueID>282</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>282</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I imported tests for this class from the old NUnitLite project and found they didn't build right away because of differences between the old and the new TestResult. The test class is now included in the nunitlite tests, but is #iffed out. Somebody should get it working.</Description>
  </Issue>
  <Issue>
    <IssueID>281</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>XSD for Version 3 output format</Title>
    <CreatedDate>19/10/2014</CreatedDate>
    <ClosedDate>15/08/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:feature</Name>
        <IssueID>281</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>281</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Is there an XSD for the 3.0 output format?  If not, should there be one?</Description>
  </Issue>
  <Issue>
    <IssueID>280</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Is NUnit2XmlOutput the right solution to backward compatibility?</Title>
    <CreatedDate>18/10/2014</CreatedDate>
    <ClosedDate>29/06/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:wontfix</Name>
        <IssueID>280</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:idea</Name>
        <IssueID>280</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Rather then having to maintain NUnit2XmlOutput code in both nunitlite and nunit-console, perhaps it would be better to just write an xslt that converts the NUnit3XmlOutput format to the older format.If there is a well defined xsd for each format, there are even tools which will generate the xslt for you.Applying the xslt to the output xml file is usually a single .NET statement. It could either be applied in the runner if the older format is requested, or just provided to the user to apply if desired and remove the backward compatibility from both nunitlite and nunit-console.If someone extends any aspect of the 3.0 output, then backward compatibility is simply a modification to the xslt.</Description>
  </Issue>
  <Issue>
    <IssueID>278</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>278</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>New result states (ChildFailure and SetupFailure) break NUnit2XmlOutputWriter</Title>
    <CreatedDate>18/10/2014</CreatedDate>
    <ClosedDate>19/10/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>278</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>278</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:critical</Name>
        <IssueID>278</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>The new result states have not been added to the dictionary that maps them to the NUnit2 format, and they cause a KeyNotFound exception.Also SetUpError and TearDownError</Description>
  </Issue>
  <Issue>
    <IssueID>276</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>276</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>NUnit.Console should not reference nunit.framework</Title>
    <CreatedDate>16/10/2014</CreatedDate>
    <ClosedDate>21/10/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>276</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>276</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>276</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I have a Visual Studio solution with a NuGet dependency on NUnit.Console 3.0.0-alpha, and I have a .NET Framework v4.5.2 project with a NuGet dependency on NUnit 3.0.0-alpha. I have added a custom MSBuild task to dynamically resolve the path to and execute the nunit-console.exe from the NuGet package. MSBuild successfully executes nunit-console.exe, but nunit-console.exe fails with the following error:&gt; Could not load file or assembly 'nunit.framework, Version=3.0.5378.31152, Culture=neutral, PublicKeyToken=2638cd05610744eb' or one of its dependencies. The system cannot find the file specified.The problem is that my project only includes a copy/reference to nunit.framework.dll for the .NET Framework 4.5 runtime (version 3.0.5378.31154). nunit-console.exe has a dependency on the .NET Framework 2.0 runtime version of nunit.framework.dll (version 3.0.5378.31152). The error no longer occurred after manually copying the .NET Framework 2.0 runtime version of nunit.framework.dll to the NUnit.Console package folder.Should the .NET Framework 2.0 runtime version of nunit.framework.dll be included in the NUnit.Console NuGet package?</Description>
  </Issue>
  <Issue>
    <IssueID>275</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>275</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>NUnitEqualityComparer fails to compare IEquatable&lt;T&gt; where second object is derived from T</Title>
    <CreatedDate>15/10/2014</CreatedDate>
    <ClosedDate>19/09/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>275</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>275</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>275</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Collections that contain objects that implement IEquatable&lt;&gt; might not be compared correctly by the CollectionAssert.AreEqual method.See this post for more details:</Description>
  </Issue>
  <Issue>
    <IssueID>274</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Command line options should be case insensitive</Title>
    <CreatedDate>15/10/2014</CreatedDate>
    <ClosedDate>22/10/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>274</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>good first issue</Name>
        <IssueID>274</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>274</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>The command line options are all lowercase, but most of their options have initial capitals like `--process=Multiple`.Because of this, I often mistype the command line options like `--Process=Multiple` or `--process=multiple`. It is pretty minor, but it is annoying and it is probably a pretty easy fix to support case insensitive options.</Description>
  </Issue>
  <Issue>
    <IssueID>272</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Test order and TestCase order</Title>
    <CreatedDate>14/10/2014</CreatedDate>
    <ClosedDate>14/10/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:duplicate</Name>
        <IssueID>272</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Is there an equivalent (in NUnit alpha 3) of MbUnit's order parameter applied on Test or TestCase?With MbUnit, you can do:[Row("a", Order = 1)][Row("b", Order = 2)][Row("c", Order = 3)]and[Test(Order = 3)]I would like to see that in NUnit if there is nothing similar yet. Thank you.</Description>
  </Issue>
  <Issue>
    <IssueID>271</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>271</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Invalid tests should be treated as errors</Title>
    <CreatedDate>14/10/2014</CreatedDate>
    <ClosedDate>26/10/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>271</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>271</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>271</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Invalid (NotRunnable) tests result from mistakes in writing the test. For example, no constructor for a fixture or the wrong number of arguments for a method. NUnit marks these tests as NotRunnable and never tries to run them.Because they are never run, we treat them as Skipped. ResultState.NotRunnable is defined as Skipped:Invalid. We count them as skipped and display them in the "not run" report rather than the "errors and faiures" report.We should recode this ResultState as Failed:Invalid and count them as errors. They should display in red in the errors report. They are errors, even though they are not _execution_ errors. In fact, if NUnit did run them, they would show up as errors.This change makes sense in the current code and will also be helpful when we create a Gui.</Description>
  </Issue>
  <Issue>
    <IssueID>270</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>270</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>OneTimeSetUp Failure results in too much output</Title>
    <CreatedDate>14/10/2014</CreatedDate>
    <ClosedDate>20/10/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>270</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:feature</Name>
        <IssueID>270</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>270</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>When OneTimeSetUp fails for a fixture, the console reports (both nunit-console and nunitlite) list the failure together with any message and stacktrace. Then it lists every test case within that fixture as failing, using the message from the setup failure but without a stack trace.This is too much info. Obviously, what has to be fixed is the failure in OneTimeSetUp.We should continue to mark the individual cases as failed and count them in our tally of failed cases, but they don't need to be listed in the output.Up for discussion:Should the failed test case have a message at all? The message takes up space in the XML and says the same thing as the actual failure. The test case will have attributes result="Failed" and site="Parent" to distinguish it. OTOH, having some kind of message may help in transforming the XML if the transform is only looking at the &lt;test-case&gt; elements. If we are unsure, we can leave it for now and ask for feedback in the next alpha.</Description>
  </Issue>
  <Issue>
    <IssueID>269</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>269</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Add manifest to nunit-console and nunit-agent</Title>
    <CreatedDate>12/10/2014</CreatedDate>
    <ClosedDate>21/10/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>269</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>269</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>269</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>From the NUnit Discuss mailing list, hi, i have a problem because i cannot test same code where i'm using the native windows job object.the problem is that job objects cannot work if windows 7 or later is using pac for the exe, the solution is to add a manifest to nunit.exe/nunit-agent.exe to explicitly declare vista/windows 7 support so the os will not use the compatibility assistant for the nunit process. I don't think that there are contraindications because nunit process doesn't need any pca feature as registry virtualization/etc.this it's the app.manifest that i'm using in my application``</Description>
  </Issue>
  <Issue>
    <IssueID>267</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Differentiate between test case Timeout and test Timeout</Title>
    <CreatedDate>07/10/2014</CreatedDate>
    <ClosedDate>24/06/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:wontfix</Name>
        <IssueID>267</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>There is significant inconsistency in the current Timeout attribute results.  Timeout is currently applied to the entire test case : SetUp+Test+TearDown.  However, if a timeout does occur, the results are unpredictable depending on where in the process it actually occurs.  Each of the three pieces (five if BeforeTest and AfterTest actions are included) can be run completely, partially, or not at all.It seems like there need to be two different timeouts, with different result guarantees.The first would be the current "test case" timeout (specified by the Timeout attribute, or from the command line -timeout), which would encompass all phases of the test case, but would guarantee no specific result.  When the timeout occurred, a failure would be reported, but there would be no attempt to complete any remaining phases of the test.The second would be implemented similarly to the current Assert.Throws and Assert.That ... Throws constraints.  There would be an Assert.TimesOut (timeout, delegate) and an Assert.DoesNotTimeOut (timeout, delegate) assertion, and a TimesOut (timeout) and a DoesNotTimeout(timeout) constraint.This would allow the exact timeout condition to be tested, and other assertions to be made before and after the timeout (including other Timeout), in the same fashion as currently happens with exceptions.  This would also allow a guarantee the all SetUp and TearDown actions would occur even if there is a timeout.</Description>
  </Issue>
  <Issue>
    <IssueID>266</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>266</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Pluggable framework drivers</Title>
    <CreatedDate>07/10/2014</CreatedDate>
    <ClosedDate>24/01/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>266</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>266</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>266</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>It should be possible to add framework drivers as a plugin. Our own NUnit 2.x driver should be the first one.</Description>
  </Issue>
  <Issue>
    <IssueID>265</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>265</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Reorganize console reports for nunit-console and nunitlite</Title>
    <CreatedDate>07/10/2014</CreatedDate>
    <ClosedDate>04/12/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>265</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>265</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>265</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Redefining this issue. Since #330 is closed:wontfix, we will not have a common object model to use for the reports. They can't really be combined in the sense of using the same code. However, it will still be useful to have them use the same structure and they obviously have to create the same output for a given assembly.Notes:1. ~~In order to do this, NUnit-console will have to use ITestResult from Common and we will need to create a TestResult object to wrap the xml result. The interface should be in nunit.engine.api and the result object in nunit.engine.~~ ReportWriter.cs in both nunit-console and nunitlite.runner should have the same structure. That is, methods that do the same thing should have the same name. Differences due to using XML output in one case and the object model in another should be relegated to the individual reports as much as possible.2. We have no tests for console reports. It's probably easiest to do this by making each individual report (summary, error, etc.) into a separate testable object.</Description>
  </Issue>
  <Issue>
    <IssueID>264</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>264</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Stacktrace displays too many entries</Title>
    <CreatedDate>07/10/2014</CreatedDate>
    <ClosedDate>20/10/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>264</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>264</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>264</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>This has been particularly observed under NUnitLite but may be also in the console runner. The code for StackTraceFilter should be common anyway.Notes:1. If trace is from an Assert, Assume, etc. the first line displayed should be the user code that made the assert. Below that line, display all entries until you reach a line of NUnit code.1. For an unexpected exception in user code, display all lines down to the NUnit code that invoked the user code.2. For an unexpected exception in NUnit itself, don't filter the stack trace. Of course, this should never occur, but the trace will be useful for the bug report.</Description>
  </Issue>
  <Issue>
    <IssueID>261</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>261</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Add portable nunitlite build</Title>
    <CreatedDate>03/10/2014</CreatedDate>
    <ClosedDate>10/11/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>261</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:feature</Name>
        <IssueID>261</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>261</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>If we create a portable build, it will also probably resolve #1 and #9.Both of those issues refer to Portable.NUnitLite, which was previously on NuGet but has been delisted by the author.</Description>
  </Issue>
  <Issue>
    <IssueID>260</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Test State</Title>
    <CreatedDate>03/10/2014</CreatedDate>
    <ClosedDate>29/06/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:wontfix</Name>
        <IssueID>260</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>design</Name>
        <IssueID>260</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:idea</Name>
        <IssueID>260</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Feature request:  a dictionary of user state that is cleared after each test is finished.A similar feature exists in SpecFlow, called ScenarioContext:  This is useful for setting up mock data that should be reset per test, which is used by several different test fixtures in the same way.  Currently the only way I can accomplish this is to set up a static class containing the mock data, and telling it to reset in each fixture by creating a [SetUp] method.  Unfortunately this is easy to miss, and if we do, the test may be invalidated by using data defined in other test runs.</Description>
  </Issue>
  <Issue>
    <IssueID>257</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>257</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>TestCase attirbute should not require parameters with default values to be specified.</Title>
    <CreatedDate>01/10/2014</CreatedDate>
    <ClosedDate>20/01/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>257</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>257</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:low</Name>
        <IssueID>257</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code> csharp
        [TestCase("va1")] // this does not work
        [TestCase("val1", false)] // this works
        public void Test1(
            string a,
            bool b = true)
        {
            Assert.Pass();
        }
`</Code>
    <Description>TestCase attribute requires all test parameters to be specified, even the ones with default values.Try this example test``The test above will say "Wrong number of arguments provided".BTW. I'm using NUnit 2.6.3I know this is not the best idea from the purity standpoint but still this would be occasionally useful.I leave this to your decision as you have more experience and skills.</Description>
  </Issue>
  <Issue>
    <IssueID>256</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>256</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>ContainsConstraint break when used with AndConstraint</Title>
    <CreatedDate>30/09/2014</CreatedDate>
    <ClosedDate>16/10/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>256</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>256</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>256</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>3.0 Alpha3Given a constraint: Does.StartWith ("Could not load").And.Contains (MISSING_FILE)AndConstraint has the following code:``if leftResult.IsSuccess is false, then the Right.ApplyTo is never called.  However, ContainsConstraint requires that its ApplyTo method be called to properly initialize its _realConstraint field.  Since it is not being called, the ConstraintResult constructor fails when trying to access Right.Description, which refers to the uninitialized _realConstraint field.</Description>
  </Issue>
  <Issue>
    <IssueID>255</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>255</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Add new result states for more precision in where failures occur</Title>
    <CreatedDate>30/09/2014</CreatedDate>
    <ClosedDate>17/10/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>255</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>255</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>255</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>NUnit 2.x recorded FailureSite as part of a TestResult. We could add this to the ResultState if it seemed appropriate, but initially, let's try creating some new ResultStates:ResultState.ChildFailure =&gt; Failed:ChildResultState.SetUpFailure =&gt; Failed:SetUpResultState.TearDownFailure =&gt; Failed:TearDownAdditionally, we should redefine ResultState.NotRunnable:ResultState.NotRunnable =&gt; Failed:Invalid (currently Skipped:Invalid)The new results will initially only be used on test suites. If it proves necessary, we can also report SetUpFailure and TearDownFailure on individual tests, but we have always treated SetUp+Test+TearDown as a single unit in the past and this seems to simplify things.ChildFailure on a suite indicates that one or more child tests failed. Usually, we can ignore this type of failure in error reports, because the individual test will be reported.SetUpFailure on a suite means that the one time setup failed. As a result, the child tests are not actually run but currently we simulate failure on all of them. Their failure messages simply refer to the failed one time setup and are not useful. We should list SetUpFailures in error reports, giving the associated message and stack trace. We may then want to stop listing the individual skipped tests.TearDownFailure means that the one time teardown failed. Individual tests may have all passed,or one or more of them may have failed, in which case those failures are listed individually. We should list the TearDownFailure separately in any error reports.NotRunnable means that the class or method is not correctly defined for NUnit to be able to treat it as a test. Examples are methods requiring a parameter where none is supplied and classes without a valid constructor. Currently, we report them as skipped, but both the console and gui runners do extra work to show them as errors. Technically, they are not run but they are still errors on the part of the programmer and would result in an Error result if we actually tried to run them. Reporting them as Failed:Invalid amounts to treating them as what they are in practice.Questions to resolve:- Should these failures be shown differently in our future Gui? (just something to think about)- How should we handle child tests, which are not run due to SetUpFailures or NotRunnable fixtures? Should we continue to count them as failures? Skip them?</Description>
  </Issue>
  <Issue>
    <IssueID>254</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>254</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Finalize XML Format for Test Results</Title>
    <CreatedDate>30/09/2014</CreatedDate>
    <ClosedDate>12/10/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>254</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:feature</Name>
        <IssueID>254</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>254</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Get comments from the community.Specific issues:- Document the schema- How to record result state: two attributes or one?</Description>
  </Issue>
  <Issue>
    <IssueID>252</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>NUnit 3.0 - nunitlite-netcf-3.5.csproj</Title>
    <CreatedDate>28/09/2014</CreatedDate>
    <ClosedDate>28/09/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:duplicate</Name>
        <IssueID>252</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>It appears that nunitlite-netcf-3.5.csproj has not been updated to the current build structure.  Many source files that it references are missing:error CS1504: Source file 'C:\Projects\NUnit\NUnit 3.0 - 2014-09-29\NUnitFramework\framework\Internal\Execution\WorkItemDispatcher.cs' could not be opened ('Unspecified error ')error CS1504: Source file 'C:\Projects\NUnit\NUnit 3.0 - 2014-09-29\NUnitFramework\framework\Internal\Execution\EventListenerTextWriter.cs' could not be opened ('Unspecified error ')error CS1504: Source file 'C:\Projects\NUnit\NUnit 3.0 - 2014-09-29\NUnitFramework\framework\Interfaces\ITestAssemblyRunner.cs' could not be opened ('Unspecified error ')error CS1504: Source file 'C:\Projects\NUnit\NUnit 3.0 - 2014-09-29\NUnitFramework\framework\Internal\Commands\SetUpTearDownList.cs' could not be opened ('Unspecified error ')error CS1504: Source file 'C:\Projects\NUnit\NUnit 3.0 - 2014-09-29\NUnitFramework\framework\Internal\Commands\CommandDecoratorList.cs' could not be opened ('Unspecified error ')error CS1504: Source file 'C:\Projects\NUnit\NUnit 3.0 - 2014-09-29\NUnitFramework\framework\Internal\Execution\Log4NetCapture.cs' could not be opened ('Unspecified error ')error CS1504: Source file 'C:\Projects\NUnit\NUnit 3.0 - 2014-09-29\NUnitFramework\framework\Interfaces\ICommandDecoratorSource.cs' could not be opened ('Unspecified error ')error CS1504: Source file 'C:\Projects\NUnit\NUnit 3.0 - 2014-09-29\NUnitFramework\framework\Interfaces\TestOutput.cs' could not be opened ('Unspecified error ')error CS1504: Source file 'C:\Projects\NUnit\NUnit 3.0 - 2014-09-29\NUnitFramework\framework\Internal\Execution\LogCapture.cs' could not be opened ('Unspecified error ')error CS1504: Source file 'C:\Projects\NUnit\NUnit 3.0 - 2014-09-29\NUnitFramework\framework\Runner\ConsoleWriter.cs' could not be opened ('Unspecified error ')error CS1504: Source file 'C:\Projects\NUnit\NUnit 3.0 - 2014-09-29\NUnitFramework\framework\Api\DefaultTestAssemblyRunner.cs' could not be opened ('Unspecified error ')error CS1504: Source file 'C:\Projects\NUnit\NUnit 3.0 - 2014-09-29\NUnitFramework\framework\Interfaces\ITestAssemblyBuilder.cs' could not be opened ('Unspecified error ')error CS1504: Source file 'C:\Projects\NUnit\NUnit 3.0 - 2014-09-29\NUnitFramework\framework\Internal\Commands\SetUpTearDownNode.cs' could not be opened ('Unspecified error ')error CS1504: Source file 'C:\Projects\NUnit\NUnit 3.0 - 2014-09-29\NUnitFramework\framework\Constraints\NullOrEmptyStringConstraint.cs' could not be opened ('Unspecified error ')</Description>
  </Issue>
  <Issue>
    <IssueID>247</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>247</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Eliminate trace display when running tests in debug</Title>
    <CreatedDate>27/09/2014</CreatedDate>
    <ClosedDate>30/09/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>247</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:feature</Name>
        <IssueID>247</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>247</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>NUnit 2.x displays a test report using Trace when running attached to a debugger. We are dropping this feature in 3.0 and it should be removed. The code is in the console runner.</Description>
  </Issue>
  <Issue>
    <IssueID>246</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>246</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>C++ Tests do not compile in VS2013</Title>
    <CreatedDate>26/09/2014</CreatedDate>
    <ClosedDate>10/10/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>246</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>246</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>246</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>The C++ test assemblies use the Visual Studio 2012 toolchain, so they will not compile in 2010 or 2013 if 2012 is not installed on the machine. I am not sure how we can fix this, but one possibility is to add msbuild conditionals to the project files to select the newest toolchain that is installed.</Description>
  </Issue>
  <Issue>
    <IssueID>245</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>245</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Multiple targets on action attributes not implemented</Title>
    <CreatedDate>26/09/2014</CreatedDate>
    <ClosedDate>30/09/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>245</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>245</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>245</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Action attributes Target property is a Flags enum and is intended to allow specifying combined settings like ActionTargets.Test | ActionTargets.Suite. Based on a review of code, this is not implemented. The value is simply tested for equality rather than masking it.Add a test and make it pass!</Description>
  </Issue>
  <Issue>
    <IssueID>244</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>244</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>NUnit should properly distinguish between .NET 4.0 and 4.5</Title>
    <CreatedDate>23/09/2014</CreatedDate>
    <ClosedDate>25/06/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>244</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:feature</Name>
        <IssueID>244</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>244</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>This issue came up in discussing #237. See comments there.The problem:NUnit-console is normally compiled to target .NET 2.0 and when it sees an assembly built with .NET 4.0/4.5 it runs tests in another process. This worked well through .NET 4.0 but 4.5 and subsequent releases introduced several problems, which we'd like to resolve in this issue. All these problems are basically caused by the fact that 4.5 is a _replacement_ for 4.0 on any machine where it is installed, as opposed to being installed side by side. (That's a Good Thing because side-by-side has it's own problems, but it is the root of the problems we are seeing.)1. When examining the assembly, NUnit only looks at the version of the framework that it targets. Because 4.0 and 4.5 use the same version number, it treats everything as 4.0.2. When NUnit looks for what runtimes are installed on a machine, it is able to detect 4.5. (This appears to work correctly, but should be verified. If it sees 4.5, then it offers (in the Gui menu) to run the tests under either 4.0 or 4.5. If it only sees 4.0, then it only offers 4.0. (This also seems to work correctly, but should be verified)3. When creating a process in which to invoke nunit-agent, NUnit uses an environment variable to ask for a runtime using the version number. If only 4.0 is installed on the machine, we get 4.0 behavior If 4.5 is installed, we get 4.5 behavior. That's a problem when 4.5 is installed and the user has asked to target 4.0. Either we should not promise 4.0 behavior in item 2 above, or we should issue a warning, or we should give the user true 4.0 behavior.We didn't deal with this in the past, primarily because it didn't come up as an issue, but also because it was thought that there is no way to give 4.0 behavior once 4.5 is installed. Rob's research on #237 indicates that there is a way to tell the 4.5 assemblies - or at least some classes - to emulate 4.0 behavior at the time the AppDomain is created. We should do that to the extent possible and also document to what extent it is possible.</Description>
  </Issue>
  <Issue>
    <IssueID>243</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>243</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Create solution for Linux</Title>
    <CreatedDate>23/09/2014</CreatedDate>
    <ClosedDate>27/09/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>243</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>good first issue</Name>
        <IssueID>243</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:build</Name>
        <IssueID>243</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>243</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>The NUnit solution now contains a number of projects that will not build on Linux: the silverlight builds of the framework and the managed C++ test files used in testing the engine. It's inconvenient that these don't load when loading the standard nunit.solution file.We should have a separate solution for use on Linux. This should not be a big problem in terms of updating, since we don't add new projects that often, but as part of completing this issue, let's add a technical note to the wiki on How to Add a Project to NUnit.</Description>
  </Issue>
  <Issue>
    <IssueID>241</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Remove reference to Microsoft BCL packages</Title>
    <CreatedDate>23/09/2014</CreatedDate>
    <ClosedDate>21/10/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>241</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:build</Name>
        <IssueID>241</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>241</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>We should remove these references from projects that don't need them... e.g.: .NET 2.0 / 3.5 / 4.5.It's a small task but I'm making an issue so we don't forget it.Obviously, we have to test thoroughly to be sure.</Description>
  </Issue>
  <Issue>
    <IssueID>240</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>240</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Document software requirements for building NUnit</Title>
    <CreatedDate>22/09/2014</CreatedDate>
    <ClosedDate>24/06/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:build</Name>
        <IssueID>240</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:low</Name>
        <IssueID>240</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>What compilers and other tools, what versions, etc. Alternatives where possibleDocument on Wiki?Process to follow to ensure that we don't break the build for those using older tools... e.g.: always add new projects to the solution using some particular IDE, etc.</Description>
  </Issue>
  <Issue>
    <IssueID>239</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>System.Uri .ctor works not properly under Nunit #237 mistakelly close</Title>
    <CreatedDate>22/09/2014</CreatedDate>
    <ClosedDate>22/09/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:duplicate</Name>
        <IssueID>239</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Simply try create Uri anywhere instead of Test under NUnit - it KEEPS all dots in Path:1.  In Console APPvar uri = new Uri("Console.WriteLine(uri.ToString()); //  will be written (dot after path)if(" != uri.ToString()) throw new Exception("failed"); //it will be passednow try it under NUNitvar uri = new Uri("Console.WriteLine(uri.ToString()); //  will be written (no dot after path)Assert.AreEqual(" uri.ToString()); // it will failPlease do not close tickets further if have not reproduce problem it describes.</Description>
  </Issue>
  <Issue>
    <IssueID>238</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>238</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Improvements to running 32 bit tests on a 64 bit system</Title>
    <CreatedDate>22/09/2014</CreatedDate>
    <ClosedDate>11/11/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>238</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>238</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>238</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>This is a followup to issue #215 which was resolved for the first alpha release. Additional work is needed, as outlined in the comments on pull request #218.In particular...1. The bitness test needs to be done separately for each assembly.2. It needs to be done at a higher level, so it can be used to select the proper runner or runners.3. We should either default to multiple processes or at least run under multiple processes when the assemblies have different framework or bitness requirements.4. Since we don't recursively check references in the test assembly, we still need to either have an nunit-console-x86 executable or (preferably) a command line option to run as 32 bits.</Description>
  </Issue>
  <Issue>
    <IssueID>237</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>System.Uri .ctor works not properly under Nunit</Title>
    <CreatedDate>22/09/2014</CreatedDate>
    <ClosedDate>25/06/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>237</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>237</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>237</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>.NET Version 4.5, Nunit version 2.6.2 and 2.6.3 (same behavior)Reproduced under ReSharper, from GUI-Runner, from NUnit-ConsoleTested on :Win 7 Pro, all updates, Ru-ru locale - reproducedWin Server 2012, all updates En-us locale - reproducedTry this:``EXPECTED:Uri not changed and " returnedACTUAL:Cropped " returnedNOTES: 1) This behavior never occured in production and cannot be catched except under NUNIT run.2) Have compared all loaded assemblies versions and codebase - all exactly match with production3) Have tested Internet on this issue - nothingWish you could reproduce.</Description>
  </Issue>
  <Issue>
    <IssueID>236</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>C# selenium tests not running properly nunit-console</Title>
    <CreatedDate>21/09/2014</CreatedDate>
    <ClosedDate>25/09/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>236</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I'm trying to setup CI testing at a new job using c#, selenium, and nunit, I was previously in java land using junit and using maven to trigger my test runs. I'm able to get my tests to run stably in my c# solution project and also stable using the project .dll from the nunit GUI, however when I try to point to the same .dll from the command line the tests are flakey and don't run properly.The browser will just open and close a few seconds later either not reporting any error or reporting unhelpful errors..I'm going to try to see if I can upgrade my nunit version, it's currently 2.something and I'll see if there's a run in debug mode. Anyone else ever seen anything like this on a high level when switching to the console?I'll report back findings as I investigate, just wanted to reach out and report this as it's super frustrating given it works fine in the nunit GUI.</Description>
  </Issue>
  <Issue>
    <IssueID>68</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>68</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Customization of test case name generation</Title>
    <CreatedDate>09/12/2013</CreatedDate>
    <ClosedDate>26/10/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>68</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:feature</Name>
        <IssueID>68</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>68</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>It's definitely more a feature request than a bug... but nonetheless:I have a TestCaseSource that returns a collection of XElements, i.e. XML nodes. Because by default the test case generation calls ToString on each parameter, the final test name looks quite ugly:DoSth(&lt;Element myAttribute="MyTestCaseName"/&gt;) ... or worseSo, to overwrite this behaviour I thought I'd encapsulate my data in TestCaseData:new TestCaseData(myXElement).SetName(myXElement.@myAttribute)However, this not only overwrites the argument, but the whole name, including the method name:myTestCaseNameSo all tests that reference this TestCaseSource end up with the same set of names. This is ugly, because obviously each test is defined via its test data AND its test behaviour.If I could imitate the original test name layout, this would be no problem. But the TestContext isn't set when reading the TestCaseSource.So my guess is: the test case generator uses some algorithm to create the test name, and TestCaseData.SetName breaks this behaviour.So, it would be nice if either .SetName would be handled the same way as the default .ToString implementation, or if the test case name creation would be customizable somehow.</Description>
  </Issue>
  <Issue>
    <IssueID>67</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>67</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Allow Expected Result on simple tests</Title>
    <CreatedDate>08/12/2013</CreatedDate>
    <ClosedDate>21/02/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>67</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:feature</Name>
        <IssueID>67</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>67</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>It's possible to specify an expected return result for a test case but not on a simple (public void no args) test marked by [Test].We should allow this.From </Description>
    <PullRequests />
  </Issue>
  <Issue>
    <IssueID>66</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>66</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Parallel Test Execution Within Test Assemblies</Title>
    <CreatedDate>08/12/2013</CreatedDate>
    <ClosedDate>05/08/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>66</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:feature</Name>
        <IssueID>66</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>66</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>NUnit 3.0 already includes provision for running tests in parallel but we have no way to control which tests may be run in this way. This feature involves implementing the spec defined at </Description>
  </Issue>
  <Issue>
    <IssueID>65</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>65</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Update NUnit Wiki to show the new location of samples</Title>
    <CreatedDate>05/12/2013</CreatedDate>
    <ClosedDate>09/12/2013</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>65</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:docs</Name>
        <IssueID>65</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>65</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Hi,thank you for such a nice tool, NUnit looks great so far.As a newcomer, I was puzzled by the absence of sample code in the installation, although it is mentioned here:After some search I found out the samples are located at GitHub here:Maybe it would be more newcomer-friendly to update the Sample page with information like:"The samples are no longer part of the official installation, but you can download them at NUnit GitHub page:C#C++F#VB .NET"Have a nice day,Petr Schreiber, jr.</Description>
  </Issue>
  <Issue>
    <IssueID>64</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>simoneb</FixedById>
        <IssueID>64</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>AsyncStateMachineAttribute should only be checked by its name</Title>
    <CreatedDate>05/12/2013</CreatedDate>
    <ClosedDate>14/03/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>64</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>good first issue</Name>
        <IssueID>64</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>64</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>64</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I'm using some async tests with NUnit 2.6.3 in a .NET 4.0 project. The projects uses the [Microsoft.Bcl.Async]( NuGet package to enable the usage of `async`/`await` keywords without targeting .NET 4.5.However, NUnit searches for the `AsyncStateMachineAttribute` using `Type.GetType`, which looks only in `mscorlib`: the attribute isn't found since it resides in another assembly. As a result, none of the async methods are detected correctly.I think that the attribute presence should only be checked by its full name.</Description>
    <PullRequests />
  </Issue>
  <Issue>
    <IssueID>63</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>simoneb</FixedById>
        <IssueID>63</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Async support should handle Task return type without state machine</Title>
    <CreatedDate>05/12/2013</CreatedDate>
    <ClosedDate>23/03/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>63</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>63</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>63</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Test methods returning a `Task` should be handled as async, whether they have an `AsyncStateMachineAttribute` or not. For example, the two following pieces of code have the same behavior, but one is treated as a valid test method while the other is not.The fact that the asynchronous method is implemented using the keyword async or not should be irrelevant in this case. (`void` methods are a different matter though, the trick used by NUnit to detect and wait for them is really nice.)``</Description>
    <PullRequests />
  </Issue>
  <Issue>
    <IssueID>62</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>62</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Matches(Constraint) does not work as expected.</Title>
    <CreatedDate>03/12/2013</CreatedDate>
    <ClosedDate>05/12/2013</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>62</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>62</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code> csharp

Assert.That(mapper.Node, 
Has.Property("Text").EqualTo("SomeText")
&amp; Has.Property("Nodes").Matches(Is.Unique.And.Count.EqualTo(2)));




Expected: property Text equal to "SomeName" and property Nodes equal to 2
  But was:  &lt; &lt;TreeNode: Node 6bc35351-14d1-469a-9439-f3afb56a0c85&gt;, &lt;TreeNode: Node 15d8f7f7-aecd-4f15-9d5a-f291f8e6ee33&gt; &gt;


Notice how the output it seems to disregard Unique and Count and just jumb to the "Equal" constraint, and obviously 2 and a list of nodes are not equal.

Simplified fully self-contained example without dependencies to windows forms etc:

 csharp
using System.Collections.Generic;
using System.Linq;
using NUnit.Framework;

namespace NUnitStuff
{
    [TestFixture]
    public class Test
    {
        [Test]
        public void Bug()
        {
            var unit = new Unit();

            Assert.That(unit,
                Has.Property("Name").EqualTo("Unit")
                &amp; Has.Property("Items").Matches(Has.Count.EqualTo(10)));
        }

    }

    public class Unit
    {
        public List&lt;int&gt; Items { get; private set; }
        public string Name { get; private set; }
        public Unit()
        {
            Name = "Unit";
            Items = new List&lt;int&gt;(Enumerable.Range(0,10));
        }
    }
}



Expected: property Name equal to "Unit" and property Items equal to 10
  But was:  &lt; 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 &gt;
`</Code>
    <Description>I am trying to write an Assert that tests that a TreeNode has a number of children and a specific text.What I was doing was something like: ``</Description>
  </Issue>
  <Issue>
    <IssueID>61</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>More Info on Ignored tests </Title>
    <CreatedDate>29/11/2013</CreatedDate>
    <ClosedDate>09/09/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:wontfix</Name>
        <IssueID>61</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>61</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>When using the [Ignore] - attribute, is it possible for NUnit to obtain sourcefilename and linenumber and output this info in the result-report?</Description>
  </Issue>
  <Issue>
    <IssueID>60</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>simoneb</FixedById>
        <IssueID>60</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>NUnit should support async setup, teardown, fixture setup and fixture teardown</Title>
    <CreatedDate>23/11/2013</CreatedDate>
    <ClosedDate>03/01/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>60</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>60</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>60</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>This does not work as expected. Tests are still run as if fixture setup was OK.``Only relevant for .NET 4.5 and later, which supports await/async C# identifiers.</Description>
  </Issue>
  <Issue>
    <IssueID>59</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>59</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Length of generated test names should be limited</Title>
    <CreatedDate>22/11/2013</CreatedDate>
    <ClosedDate>26/10/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>59</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:feature</Name>
        <IssueID>59</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>59</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Since NUnit uses the value of a string argument to a test as part of the name, it's possible for the names to be arbitrarily long. This causes problems, particularly in the Gui, where GDI+ exceptions may be thrown and in the VS adapter, which may either reject the name or truncate it arbitrarily.Names generated in the framework should be limited to a reasonable length &lt;= 449 characters, the length that is enforced by the adapter. However, we don't want to simply truncate the name after generating it. Ideally, each individual parameter should be truncated in a way that limits the overall length of the name while preserving the general outline of FixtureName(args).TestName(args). Since any  truncation may cause duplicate names, which NUnit itself does not mind but which can break some clients like TestExplorer, name generation should include adding a unique value like the test id where needed. Note that it would be possible to use the test id alone for a unique name, but that this would not result in a good user experience in runners (TestExplorer again) that use the test name as a display name.We may want to provide the raw materials for separating the display name from the "real" unique test name for those runners that want to take advantage of it.</Description>
    <PullRequests>
      <PullRequest>
        <RepoID>nunitWebScrap</RepoID>
        <IssueID>59</IssueID>
        <PullRequestID>469</PullRequestID>
        <Title>Truncate string arguments in test names in order to limit the length</Title>
        <Description>This is a partial fix for issue #59. Truncating string arguments to test cases and fixture constructors will eliminate the major cause of name overflows that have been troubling us. We can keep the issue open for a while to see if further changes are needed.The code in MethodHelper and TypeHelper, which deal with generating names for test cases and fixtures respectively, could be combined but I haven't done it here.</Description>
        <CreatedDate>25/01/2015</CreatedDate>
        <ClosedDate>26/01/2015</ClosedDate>
        <PullRequestLabels>
          <PullRequestLabel>
            <Name>closed:done</Name>
            <IssueID>59</IssueID>
            <PullRequestID>469</PullRequestID>
            <RepoID>nunitWebScrap</RepoID>
          </PullRequestLabel>
          <PullRequestLabel>
            <Name>is:feature</Name>
            <IssueID>59</IssueID>
            <PullRequestID>469</PullRequestID>
            <RepoID>nunitWebScrap</RepoID>
          </PullRequestLabel>
        </PullRequestLabels>
        <PullRequestAssignees>
          <PullRequestAssignee>
            <FixedById>CharliePoole</FixedById>
            <PullRequestID>469</PullRequestID>
            <IssueID>59</IssueID>
            <RepoID>nunitWebScrap</RepoID>
          </PullRequestAssignee>
        </PullRequestAssignees>
      </PullRequest>
    </PullRequests>
  </Issue>
  <Issue>
    <IssueID>58</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Full name (test details) incomplete when using abstract classes with parameterized test-cases</Title>
    <CreatedDate>20/11/2013</CreatedDate>
    <ClosedDate>09/09/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>58</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>58</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>NUnit 2.6.3.In our test environment we are using abstract classes to write all the test-cases. We use multiple derived classes to execute these test-cases on different fixtures. A small example:``</Description>
  </Issue>
  <Issue>
    <IssueID>55</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>55</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Incorrect XML comments for CollectionAssert.IsSubsetOf</Title>
    <CreatedDate>07/11/2013</CreatedDate>
    <ClosedDate>24/01/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>55</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>good first issue</Name>
        <IssueID>55</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>55</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>The XML comments for `CollectionAssert.IsSubsetOf` currently reads "Asserts that superset is a subset of subset.", but I think it should read "Asserts that subset is a subset of superset."Also, comment for parameters `subset` and `superset` are swapped around.Detected in version 2.6.3.13283 (using VS 2013)</Description>
    <PullRequests />
  </Issue>
  <Issue>
    <IssueID>54</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>54</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Store message and stack trace in `TestContext` (for use in `[TearDown]`)</Title>
    <CreatedDate>07/11/2013</CreatedDate>
    <ClosedDate>09/09/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>54</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:feature</Name>
        <IssueID>54</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>54</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Right now, in, e.g., NUnit 2.5.10, inside of a `[TearDown]` method I can use `TestContext.CurrentContext.Result.Status` to see whether the test has failed/passed/skipped.It would be really cool if I could also get all the other information which is logged in the console output, or in result XML, too... particularly the message and stack traces!</Description>
    <PullRequests />
  </Issue>
  <Issue>
    <IssueID>52</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>stevenaw</FixedById>
        <IssueID>52</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Self-contained item in array causes stack overflow</Title>
    <CreatedDate>03/11/2013</CreatedDate>
    <ClosedDate>26/01/2020</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>52</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>52</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:low</Name>
        <IssueID>52</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>See Fix needs to be checked to see if it applies to nunit 3.0 and, if so, ported.</Description>
  </Issue>
  <Issue>
    <IssueID>50</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>explicit and ignore</Title>
    <CreatedDate>28/10/2013</CreatedDate>
    <ClosedDate>12/10/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>50</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:feature</Name>
        <IssueID>50</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:low</Name>
        <IssueID>50</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>First the problem:We make a test, that could not be satisfied up to now, because the implementation of the functionality is not ready. We give him the attribute explicit, so the developer can run the test while he implements the functionality. But for the person who looks at the tests, he didn't see the test. So we make a empty copy of the test and give hin the attribute ignore.If we give the test both attributes, explicit and ignore, the test is not runable under the gui.A possibility would be that ignored tests can be run if a special option is set (perhaps on the tab for categories or command line).This would be a very nice feature!See discussion at </Description>
  </Issue>
  <Issue>
    <IssueID>49</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>PostTestAttribute</Title>
    <CreatedDate>28/10/2013</CreatedDate>
    <ClosedDate>25/06/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:idea</Name>
        <IssueID>49</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>NUnit version 2.5.7Runner: Console and GUIFeature Request:I'd love to have the ability to override a test's result (e.g. Pass/Fail/Error) in the [TearDown] method along with the option to overwrite the error message.Some more background:I just started with a team that uses NUnit for running for automation testing. Given that NUnit is specifically built for unit testing, I've been surprised just how well it meets our needs. The only hangup I currently have is that we have certain classes of errors that only occur on threads other than the main thread. Without going into details, it's basically impossible for us respond to these errors on the main thread without adding code everywhere to poll if any of these errors have occurred, and if so, Assert.Fail(). Without detecting the errors at all, our code ends up asserting or throwing an exception for something else on the main thread which just ends up obfuscating the real problem in the resulting TestResult.xml file.I understand why NUnit doesn't pick up assertions/exceptions on different threads, but we could easily workaround this if we had the ability to override the test result and error message in the [TearDown] method. At that point we'd know if any of these errors had occurred and could signal the test as failing and give a more appropriate message.See discussion at </Description>
  </Issue>
  <Issue>
    <IssueID>48</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>48</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Explicit seems to conflict with Ignore</Title>
    <CreatedDate>28/10/2013</CreatedDate>
    <ClosedDate>21/04/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>48</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>good first issue</Name>
        <IssueID>48</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>48</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>48</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I have a test fixture marked with:[TestFixture][Explicit, Category("SomeCategory")]Tests in this fixture are run when the console runner specifies "SomeCategory".The tests in this fixture CONTINUE to be run when I add [Ignore] to the class. They only stop being run when I remove the [Explicit] attribute.From </Description>
    <PullRequests />
  </Issue>
  <Issue>
    <IssueID>47</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>47</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Extensions to RangeAttribute</Title>
    <CreatedDate>28/10/2013</CreatedDate>
    <ClosedDate>28/06/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>47</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>47</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>47</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Having parameterized tests is a very nice feature. Some additional possibilities for the attributes are needed:Range with DateTime and Step as TimeSpan: Range (DateTime, DateTime, TimeSpan)Range (long, long) without Step (implicitly 1) - or does this make conflicts with Range (int, int)?unsigned variantsRange (Type sourceType, string sourceName, int start, int end) might also be nice. Than it is easy to use the same data for multiple tests, if sourceName implements IList. (like ValueSourceAttribute)Range (string sourceName, int start, int end) see aboveRandom for long and floatunsigned variantsSee discussion at </Description>
  </Issue>
  <Issue>
    <IssueID>46</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>AssemblyVersion needed</Title>
    <CreatedDate>28/10/2013</CreatedDate>
    <ClosedDate>16/01/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:wontfix</Name>
        <IssueID>46</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>46</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>A nice feature would be a Version as a Attribute. When the assembly version is at least the value, the test is active. If the assembly version is to low, the test will be ignored.The version could be the version of the assembly which contains the test or delivered by a public static class from a special property (as it is in testcasesource).Testcase and Testfixture and so on must also have this feature.See discussion at </Description>
  </Issue>
  <Issue>
    <IssueID>45</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>45</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Need of Enddate together with Ignore</Title>
    <CreatedDate>28/10/2013</CreatedDate>
    <ClosedDate>21/02/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>45</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:feature</Name>
        <IssueID>45</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>In our framework we have a feature that is very important for us: Ignore can has two parameters description and enddate. When enddate is less then the current date, the test is not longer be igrnored and (normally) displayed as a test with error.Currently, there is more than one part to change, because Ignore ist also used with TestCase, TestFisture and so on.Ignore, IgnoreReason, IgnoreUpto, IgnoreReasonUppto will then be needed.See discussion at </Description>
  </Issue>
  <Issue>
    <IssueID>44</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Add a [KnownBug] attribute to tests</Title>
    <CreatedDate>28/10/2013</CreatedDate>
    <ClosedDate>13/04/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:wontfix</Name>
        <IssueID>44</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:idea</Name>
        <IssueID>44</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>In many cases a bug is reported to a project along with the unit test. The unit test needs to be integrated, but it may take some time before it can be resolved. In this case, it isn't clear what its state should be:- If it is integrated as is, the unit test fails and causes the whole build to fail. This hinders development on other features and bugs - it's hard to know whether a red unit test represents a regression or just an unrelated open bug.- [Ignore] seems like the current best solution, but is semantically unclear. Tests can be [Ignore]d for many reasons (temporary breakage) and sometimes remain that way for a long time.A [KnownBug] mark would semantically handle this, and would effectively create an "open bug list" within the test suite. It would also allow GUIs to visually indicate the state as distinct from [Ignore].If this seems like a good idea I'll be happy to submit a patch.See discussion at </Description>
    <PullRequests />
  </Issue>
  <Issue>
    <IssueID>43</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Add an [Issue] attribute to tests</Title>
    <CreatedDate>28/10/2013</CreatedDate>
    <ClosedDate>13/04/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:wontfix</Name>
        <IssueID>43</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:idea</Name>
        <IssueID>43</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>It seems like having an [Issue] attribute, with the URL pointing to a bug tracker page related to the test, would be a useful thing...See discussion at </Description>
  </Issue>
  <Issue>
    <IssueID>42</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>NUnit does not show custom exceptions when running tests in a separate AppDomain</Title>
    <CreatedDate>28/10/2013</CreatedDate>
    <ClosedDate>01/12/2016</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:norepro</Name>
        <IssueID>42</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:feature</Name>
        <IssueID>42</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:low</Name>
        <IssueID>42</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>If a test throws one of our custom exception types (e.g., InterfaceBrokerException) and you're running tests via the NUnit GUI, then NUnit shows the following instead of the exception that was actually thrown:An unhandled System.Runtime.Serialization.SerializationException was thrown while executing this test : Unable to find assembly 'Profitstar.Library, Version=2008.2.338.27793, Culture=neutral, PublicKeyToken=null'.This is because the tests get run in one AppDomain, and then the results are marshaled to the main AppDomain via .NET serialization; but the Profitstar.Library assembly isn't loaded into the main AppDomain (nor should it be, because then it couldn't be unloaded), so it can't deserialize the exception.So we end up with no stack trace, no original exception message, and no idea of even what exception type got thrown.Is there any way to circumvent the use of a separate AppDomain when using the NUnit GUI? If not, can something be added to configure that feature?See discussion at </Description>
  </Issue>
  <Issue>
    <IssueID>41</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>41</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>check for zeroes in assert messages</Title>
    <CreatedDate>28/10/2013</CreatedDate>
    <ClosedDate>09/09/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>41</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>41</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:low</Name>
        <IssueID>41</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>It happened to us that somehow there was a zero in an assertion message. This zero within the message, even embedded into a cdata-section within the resultfile caused a crash to all applications that tried to create a DOM, .NET XmlDocument class and eben XmlSpy application crashed. Of course a zero is not allowed in a xml file but this zero came from the assertion message and so went into the NUnit resultfile. NUnit should check if messages are really valid strings and if there is a disallowed zero, escape it or convert it to its string representation.From </Description>
    <PullRequests />
  </Issue>
  <Issue>
    <IssueID>40</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Option to temporarily pause the run from the test code</Title>
    <CreatedDate>28/10/2013</CreatedDate>
    <ClosedDate>16/01/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:wontfix</Name>
        <IssueID>40</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Add a method to Assert or TestContext to allow the user to cause the run to be paused while external action is taken. This is a general facility and will make it easier to do a number of things, including:- Taking a dump- Attaching a debugger- Checking the status of external devicesSee discussion at </Description>
  </Issue>
  <Issue>
    <IssueID>38</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Timeout Attribute don't work for SetUpFixture</Title>
    <CreatedDate>28/10/2013</CreatedDate>
    <ClosedDate>16/01/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:wontfix</Name>
        <IssueID>38</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>setting Timeout Attribute for SetUpFixture has no effect.We have a class which handle some preconditions for all tests, so timeout might be possible attribute too.From </Description>
  </Issue>
  <Issue>
    <IssueID>37</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Multiple SetUp Fixtures should be permitted on same namespace</Title>
    <CreatedDate>28/10/2013</CreatedDate>
    <ClosedDate>29/12/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>37</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>37</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>37</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>In V2, when there are multiple SetUpFixtures, all but one is ignored. They should all be run, even if the order of execution is indeterminate.See </Description>
    <PullRequests />
  </Issue>
  <Issue>
    <IssueID>36</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>36</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Make RequiresThread, RequiresSTA, RequiresMTA inheritable</Title>
    <CreatedDate>22/10/2013</CreatedDate>
    <ClosedDate>04/02/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>36</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>good first issue</Name>
        <IssueID>36</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>36</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>36</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>[This issue maps to Launchpad bug Currently the RequiresThread, RequiresSTA, RequiresMTA are all marked as not inheritable. In my case I have a base class for tests related to the UI, where I have a TestFixtureSetup method to make everything run. For this to work, however, the tests have to run in an STA thread. However, since the attributes are marked as not inheritable, this means I need to set them on every TestFixture. Much easier would be setting it once on the base class, and make the derived test fixture classes inherit that attribute.</Description>
    <PullRequests />
  </Issue>
  <Issue>
    <IssueID>34</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>jnm2</FixedById>
        <IssueID>34</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Async testing with F#</Title>
    <CreatedDate>20/10/2013</CreatedDate>
    <ClosedDate>17/11/2019</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>34</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>34</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:low</Name>
        <IssueID>34</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I have been trying to find on how to test asynchronous code from F# without having to manually unwrap the async value, but rather having the test framework do that for you.Since it seems 3.0 will bring with it improvements to async as well as the ability to parallelise tests, it would be great if there was some guidance on how to use the project with F#.My question is simpler than this however; how do I create tests with F# that are async without wrapping them in TPL?</Description>
    <PullRequests>
      <PullRequest>
        <RepoID>nunitWebScrap</RepoID>
        <IssueID>34</IssueID>
        <PullRequestID>3268</PullRequestID>
        <Title>Support F#'s Async type</Title>
        <Description>Closes #34.</Description>
        <CreatedDate>27/05/2019</CreatedDate>
        <ClosedDate>17/11/2019</ClosedDate>
        <PullRequestLabels>
          <PullRequestLabel>
            <Name>awaiting:review</Name>
            <IssueID>34</IssueID>
            <PullRequestID>3268</PullRequestID>
            <RepoID>nunitWebScrap</RepoID>
          </PullRequestLabel>
        </PullRequestLabels>
        <PullRequestAssignees />
      </PullRequest>
    </PullRequests>
  </Issue>
  <Issue>
    <IssueID>33</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>TestCaseSource cannot refer to a parameterized test fixture</Title>
    <CreatedDate>20/10/2013</CreatedDate>
    <ClosedDate>06/08/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>33</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>33</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>33</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>TestCaseSource always instantiates the object providing data using the default constructor. Parameterized fixtures usually don't have one and adding one would mean that no parameters were available to generate data.From </Description>
    <PullRequests />
  </Issue>
  <Issue>
    <IssueID>32</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>constructor-igor</FixedById>
        <IssueID>32</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>TestFixtureTearDown is not executed after exception in TestFixtureSetUp</Title>
    <CreatedDate>20/10/2013</CreatedDate>
    <ClosedDate>11/05/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>32</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>32</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>32</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Code> C#
  [TestFixture]
  public class Base
  {
    [TestFixtureSetUp]
    public void TestFixtureSetUp()
    {
      Console.WriteLine("Running TestFixtureSetUp Base");
    }
    [SetUp]
    public void SetUp()
    {
      Console.WriteLine("Running SetUp Base");
    }
    [Test]
    public void TestBase()
    {
      Console.WriteLine("Running Test Base");
    }
    [TearDown]
    public void TearDown()
    {
      Console.WriteLine("Running TearDown Base");
    }
    [TestFixtureTearDown]
    public void TestFixtureTearDown()
    {
      Console.WriteLine("Running TestFixtureTearDown Base");
    }
  }

  [TestFixture]
  public class Derived : Base
  {
    [TestFixtureSetUp]
    public new void TestFixtureSetUp()
    {
      Console.WriteLine("Running TestFixtureSetUp Derived");
    }
    [SetUp]
    public new void SetUp()
    {
      Console.WriteLine("Running SetUp Derived");
    }
    [Test]
    public void TestDerived()
    {
      Console.WriteLine("Running Test Derived");
    }
    [TearDown]
    public new void TearDown()
    {
      Console.WriteLine("Running TearDown Derived");
    }
    [TestFixtureTearDown]
    public new void TestFixtureTearDown()
    {
      Console.WriteLine("Running TestFixtureTearDown Derived");
    }
  }


Executing TestDerived works as expected:


Running TestFixtureSetUp Base
Running TestFixtureSetUp Derived
Running SetUp Base
Running SetUp Derived
Running Test Derived
Running TearDown Derived
Running TearDown Base
Running TestFixtureTearDown Derived
Running TestFixtureTearDown Base


Now I introduce an Exception in SetUp of Base:

 C#
    [SetUp]
    public void SetUp()
    {
      Console.WriteLine("Running SetUp Base");
      throw new Exception("Exception in SetUp Base");
    }


Executing TestDerived now gives this output:


Running TestFixtureSetUp Base
Running TestFixtureSetUp Derived
Running SetUp Base
Running TearDown Derived
Running TearDown Base
Test 'Avl.TestAutomationFramework.Infrastructure.UnitTests.TestDriver.Derived.TestDerived' failed: SetUp : System.Exception : Exception in SetUp Base
    Base.cs(18,0): at Avl.TestAutomationFramework.Infrastructure.UnitTests.TestDriver.Base.SetUp()

Running TestFixtureTearDown Derived
Running TestFixtureTearDown Base


Since the behaviour of TearDown and TestFixtureTearDown in case of an exception in the corresponding SetUp function is described the same way, word by word, I would expect that if there was an Exception in TestFixtureSetUp Base, then also both TestFixtureTearDown Derived and TestFixtureTearDown Base will be called.

However, if I remove the Exception from SetUp Base again and instead add one to TestFixtureSetUp Base...

 C#
    [TestFixtureSetUp]
    public void TestFixtureSetUp()
    {
      Console.WriteLine("Running TestFixtureSetUp Base");
      throw new Exception("Exception in TestFixtureSetUp Base");
    }


... then running TestDerived gives the following output:


Running TestFixtureSetUp Base
Test 'Avl.TestAutomationFramework.Infrastructure.UnitTests.TestDriver.Derived.TestDerived' failed: TestFixtureSetUp failed in Derived

TestFixture failed: SetUp : System.Exception : Exception in TestFixtureSetUp Base
   at Avl.TestAutomationFramework.Infrastructure.UnitTests.TestDriver.Base.TestFixtureSetUp() in D:\git\TestAutomationFramework_V2013\Projects\Infrastructure\UnitTests\TestDriver\Base.cs:line 13
`</Code>
    <Description>(NUnit 2.5.10.11092 wit GUI runner)The behaviour of TearDown and TestFixtureTearDown in case of an Exception in the corresponding SetUp is described in the same way, but behaves differently.#### Decription of TearDown:So long as any SetUp method runs without error, the TearDown method is guaranteed to run. It will not run if a SetUp method fails or throws an exception.#### Description of TestFixtureTearDown:So long as any TestFixtureSetUp method runs without error, the TestFixtureTearDown method is guaranteed to run. It will not run if a TestFixtureSetUp method fails or throws an exception.I have the following two very simple classes:``From </Description>
    <PullRequests />
  </Issue>
  <Issue>
    <IssueID>31</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>31</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>report start and end time of test execution</Title>
    <CreatedDate>20/10/2013</CreatedDate>
    <ClosedDate>16/02/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>31</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>31</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>31</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>The result XML should also contain the start and end times of a test execution. This is useful to match additional log data from external sources to failing tests, especially when executing long-running tests like system or user acceptance tests or tests that are executed unattended.Proposed solution:- add "start"/"starttime" and "end"/"endtime" attributes to "test-case" and "test-suite" elements containing the appropriate time strings used for- rename the "time" attribute to "duration" to avoid confusion (I know, this is breaking compatibility...)- this solution may be conflicting with #1072379See comments at </Description>
  </Issue>
  <Issue>
    <IssueID>29</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Specifying a tolerance with "Within" doesn't work for DateTimeOffset data types</Title>
    <CreatedDate>20/10/2013</CreatedDate>
    <ClosedDate>15/12/2013</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>29</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>29</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>29</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I would expect the following test to pass:``NUnit.framework version 2.6.2.12296NUnit currently has special code for comparing two DateTimes within a tolerance, but not for DateTimeOffset.From See </Description>
    <PullRequests />
  </Issue>
  <Issue>
    <IssueID>28</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Add Support for Windows Phone</Title>
    <CreatedDate>20/10/2013</CreatedDate>
    <ClosedDate>12/12/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>28</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:feature</Name>
        <IssueID>28</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>28</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>We need a Windows Phone 7 / .NET 3.7 buildFrom </Description>
  </Issue>
  <Issue>
    <IssueID>27</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>27</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Values attribute support for enum types</Title>
    <CreatedDate>20/10/2013</CreatedDate>
    <ClosedDate>18/06/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>27</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:feature</Name>
        <IssueID>27</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>27</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>The Values attribute should support enum types as argument.Example:``From </Description>
    <PullRequests />
  </Issue>
  <Issue>
    <IssueID>25</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Honor nesting of classes when running tests</Title>
    <CreatedDate>20/10/2013</CreatedDate>
    <ClosedDate>16/01/2018</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:wontfix</Name>
        <IssueID>25</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:feature</Name>
        <IssueID>25</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>25</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Nested TestFixtures should be executed as sub-tests of the class that contains them.This is based on and a necessary prerequisite for </Description>
  </Issue>
  <Issue>
    <IssueID>24</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>constructor-igor</FixedById>
        <IssueID>24</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Assert on Dictionary Content</Title>
    <CreatedDate>19/10/2013</CreatedDate>
    <ClosedDate>22/04/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>24</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>good first issue</Name>
        <IssueID>24</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:feature</Name>
        <IssueID>24</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:low</Name>
        <IssueID>24</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Add constraints that test whether a dictionary contains a certain key and a certain value.Based on request at </Description>
    <PullRequests>
      <PullRequest>
        <RepoID>nunitWebScrap</RepoID>
        <IssueID>24</IssueID>
        <PullRequestID>483</PullRequestID>
        <Title>Adds constraint for asserting that a dictionary contains a particular key</Title>
        <Description>This partially fulfills Issue #24</Description>
        <CreatedDate>01/02/2015</CreatedDate>
        <ClosedDate>03/02/2015</ClosedDate>
        <PullRequestLabels>
          <PullRequestLabel>
            <Name>closed:done</Name>
            <IssueID>24</IssueID>
            <PullRequestID>483</PullRequestID>
            <RepoID>nunitWebScrap</RepoID>
          </PullRequestLabel>
          <PullRequestLabel>
            <Name>is:feature</Name>
            <IssueID>24</IssueID>
            <PullRequestID>483</PullRequestID>
            <RepoID>nunitWebScrap</RepoID>
          </PullRequestLabel>
          <PullRequestLabel>
            <Name>pri:low</Name>
            <IssueID>24</IssueID>
            <PullRequestID>483</PullRequestID>
            <RepoID>nunitWebScrap</RepoID>
          </PullRequestLabel>
        </PullRequestLabels>
        <PullRequestAssignees>
          <PullRequestAssignee>
            <FixedById>CharliePoole</FixedById>
            <PullRequestID>483</PullRequestID>
            <IssueID>24</IssueID>
            <RepoID>nunitWebScrap</RepoID>
          </PullRequestAssignee>
        </PullRequestAssignees>
      </PullRequest>
    </PullRequests>
  </Issue>
  <Issue>
    <IssueID>23</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Use overridden Equals for IEnumerables, Collections, etc.</Title>
    <CreatedDate>19/10/2013</CreatedDate>
    <ClosedDate>12/07/2017</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:wontfix</Name>
        <IssueID>23</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>When a user-defined class overrides Equals, we should use it even if the class implements IEnumerable, ICollection, etc.See discussion at From </Description>
  </Issue>
  <Issue>
    <IssueID>22</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>22</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Add OSArchitecture Attribute to Environment node in result xml </Title>
    <CreatedDate>19/10/2013</CreatedDate>
    <ClosedDate>16/04/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>22</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>good first issue</Name>
        <IssueID>22</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>22</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>22</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>To differ the results on Win7x86 and Win7x64 the user needs these information in the result file.So my idea was to extend the environment node in the result file&lt;environment nunit-version="2.5.6.10205" clr-version="2.0.50727.4927" os-version="Microsoft Windows NT 6.1.7600.0" osarchiteture="x64" platform="Win32NT" cwd="C:\Program Files (x86)\NUnit 2.5.6\bin\net-2.0" machine-name="ADMIN-PC" user="Administrator" user-domain="Admin-PC" /&gt;From </Description>
  </Issue>
  <Issue>
    <IssueID>21</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>21</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Is.InRange Constraint Ambiguity</Title>
    <CreatedDate>19/10/2013</CreatedDate>
    <ClosedDate>04/02/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>21</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>good first issue</Name>
        <IssueID>21</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>21</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>21</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>As discussed on NUnit-Discuss:Is.InRange Intellisense specifies direction-indepedent arguments "from" and "to" but behaves direction-dependent (e.g. "min" and "max").Example:``</Description>
  </Issue>
  <Issue>
    <IssueID>20</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>20</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>TestCaseAttribute needs Platform property</Title>
    <CreatedDate>19/10/2013</CreatedDate>
    <ClosedDate>09/01/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>20</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>20</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>20</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>There should be a way to add a TestCase conditioned on the platform.From </Description>
  </Issue>
  <Issue>
    <IssueID>18</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>ExpectedException specification</Title>
    <CreatedDate>19/10/2013</CreatedDate>
    <ClosedDate>19/03/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:notabug</Name>
        <IssueID>18</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>18</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>18</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I subclassed ExpectedException attribute passing to super constructor AssertionException type.Now if I attibute my test method with both my subclass and ExpectedException(AssertionException) I get runner and attribute order dependent behaviour:- R# runner interpretes all attributes in sequence so a test method body that passes is toggled to failure by the first ExpectedException attribute then the failure is toggled back to pass by the next ExpectedException attribute.- Nunit 2.5.3 gui-runner seems to interpret just the first onefor:``The documentation deserves a clarification.See discussion at </Description>
  </Issue>
  <Issue>
    <IssueID>17</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>simoneb</FixedById>
        <IssueID>17</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>No allowance is currently made for nullable arguments in TestCase parameter conversions</Title>
    <CreatedDate>19/10/2013</CreatedDate>
    <ClosedDate>09/08/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>17</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>17</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>17</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>From </Description>
  </Issue>
  <Issue>
    <IssueID>16</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Add support for AggregateException</Title>
    <CreatedDate>19/10/2013</CreatedDate>
    <ClosedDate>29/09/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>16</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>16</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>16</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Currently NUnit unrolls the InnerException property messages for an exception.It would be nice if it also recursively unrolls the InnerExceptions (note the s) property of the System.AggregateException.See </Description>
  </Issue>
  <Issue>
    <IssueID>15</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Need ability to turn off combinatorial</Title>
    <CreatedDate>19/10/2013</CreatedDate>
    <ClosedDate>13/04/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:wontfix</Name>
        <IssueID>15</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>15</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>When you have a combinatorial attribute such as the following:[Test, Combinatorial]public void MyTest(    [Values(1,2,3)] int x,    [Values("A","B")] string s){    ...}Sometimes there is an issue with a certain set of values and you need to debug it. Would be nice to just turn off the combinatorial feature (by not having the attribute!), so that this could work for debugging:[Test, TestCase(3,"A")]public void MyTest(    [Values(1,2,3)] int x,    [Values("A","B")] string s){    ...}As it is now, you have to completely redo the signature (and put it back after fixing bug/test) or setup a complex break point, etc....[Test, TestCase(3,"A")]public void MyTest(    int x,    string s){    ...}See discussion at </Description>
  </Issue>
  <Issue>
    <IssueID>14</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>simoneb</FixedById>
        <IssueID>14</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>CI Server for nunit framework</Title>
    <CreatedDate>19/10/2013</CreatedDate>
    <ClosedDate>14/03/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>14</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:build</Name>
        <IssueID>14</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>14</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>CI server should build on each change, run tests and support all platforms.</Description>
  </Issue>
  <Issue>
    <IssueID>13</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>CharliePoole</FixedById>
        <IssueID>13</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Standardize commandline options for nunitlite runner</Title>
    <CreatedDate>19/10/2013</CreatedDate>
    <ClosedDate>28/08/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>13</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>13</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>13</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>The NUnitLite integrated runner supports some of the same features as the full nunit-console but uses different options to access them. To the extent possible, where the features are common, we should use the same options in both programs.Ideally, NUnitLite commandline option processing should be converted to use Mono.Options at the same time. However, it turns out that mono.options won't compile in the compact framework, making it unsuitable for NUnitLite.We'll need to give more thought to a common approach to commandline interpretation across all nunit projects.From </Description>
  </Issue>
  <Issue>
    <IssueID>12</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Compact framework should support generic methods</Title>
    <CreatedDate>19/10/2013</CreatedDate>
    <ClosedDate>21/11/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>12</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>12</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>12</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>All support for generic test methods is missing in the compact framework builds, although generic fixtures are supported. Both CF 2.0 and 3.5 support generics, so we should as well, at least to whatever extent it's possible.That said, if this requires significant effort, we may consider postponing it to a future release.From </Description>
  </Issue>
  <Issue>
    <IssueID>11</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Perform build and packaging on different machines</Title>
    <CreatedDate>19/10/2013</CreatedDate>
    <ClosedDate>14/05/2019</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>is:build</Name>
        <IssueID>11</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>11</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Currently, it's only possible to do a release of NUnitLite on a machine with all the runtimes we support installed. This makes it difficult for contributors to handle releases. It would be better if the builds could be completed on different machines and then aggregated on a separate server.The main changes needed to the build script to accomplish this are:1. Provide a remote location to which builds are published2. Add a target to copy builds to that location.3. Modify package targets to use that location.In order to make sure that all the builds for a release are all based on the same source, we will need to tag the published packages with a revision number and/or date.From </Description>
  </Issue>
  <Issue>
    <IssueID>10</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Trace output is disabled by default</Title>
    <CreatedDate>19/10/2013</CreatedDate>
    <ClosedDate>22/08/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:wontfix</Name>
        <IssueID>10</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>10</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Before we upgraded to the mentioned version both the Debug.WriteLine and the Trace.WritLine had been written out to the output in version 2.5.9. But in the new version this is disabled by default. We found that checkbox which we can enabled this with. But there is no similar option in the nunit console. We need it because it is used in out test reult logging system.See discussion at </Description>
  </Issue>
  <Issue>
    <IssueID>9</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>9</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Add Xamarin Runners</Title>
    <CreatedDate>19/10/2013</CreatedDate>
    <ClosedDate>27/11/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>9</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:feature</Name>
        <IssueID>9</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:normal</Name>
        <IssueID>9</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>We should have a build version against MonoDroid.From </Description>
  </Issue>
  <Issue>
    <IssueID>8</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>[SetUpFixture] is not working as expected in GUI - Flat list mode</Title>
    <CreatedDate>19/10/2013</CreatedDate>
    <ClosedDate>02/02/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>8</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:enhancement</Name>
        <IssueID>8</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>8</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>When Settings-&gt;Gui-&gt;Tree Display-&gt;Test structure-&gt;Flat list of TestFixtures is selected then1. [SetUpFixture] methods are not being called when GUI Runner is used2.Class having [SetUpFixture] attribute is being shown in tests list in the GUI.More info at </Description>
  </Issue>
  <Issue>
    <IssueID>6</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>simoneb</FixedById>
        <IssueID>6</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Log4net not working with NUnit</Title>
    <CreatedDate>19/10/2013</CreatedDate>
    <ClosedDate>10/08/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>6</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>6</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>6</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Problem: Using log4net with newer versions of nunit means that nolog file is created.Demonstration follows.I created the solution in VS 2008.The OS is Windows XP.I tested using both the nunit GUI and console.I compared Nunit 2.2.5 with 2.5.5 (I suspect 2.5.0 will fail as well.)The solution is created as a console app.When the app is run as a console application a Log file is produced.When the app is run using 2.2.5 a Log file is produced.When the app is run using 2.5.5 no Log file is produced.Repro details and other info at </Description>
  </Issue>
  <Issue>
    <IssueID>4</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title> SimpleTestRunner miss handles point of exception</Title>
    <CreatedDate>19/10/2013</CreatedDate>
    <ClosedDate>07/03/2014</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:wontfix</Name>
        <IssueID>4</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:bug</Name>
        <IssueID>4</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>4</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>The SimpleTestRunner performs a an odd skip of Exception processing when faced with a fully un-implemented EventListener. What happens is that my RunStarted throws an Exception and this gets caught end then RunFinished is called which then throws an exception -- the stack trace makes it look like the RunFinished was the culprit when in fact the RunStart began the exceptional behavior. This occurs mainly because the catch( Exception exception ) catches everything. Perhaps what it should do is catch NUnit exceptions and throw all other exceptions -- I'm not familiar enough with the architecture around Exception testing, Assert Exceptions, etc.So here is the culprit code in SimpleTestRunner, Line 141, of release 2.5.5.101112.public virtual TestResult Run( EventListener listener, ITestFilter filter ){ try {        log.Debug("Starting test run");  // Take note of the fact that we are running  this.runThread = Thread.CurrentThread;  listener.RunStarted( this.Test.TestName.FullName, test.CountTestCases( filter ) );  testResult = test.Run( listener, filter );  // Signal that we are done  listener.RunFinished( testResult );        log.Debug("Test run complete");  // Return result array  return testResult; } catch( Exception exception ) {                // RunStart actually threw the exception. so RunFinish doesn't make sense.``  // Signal that we finished with an exception  listener.RunFinished( exception );  // Rethrow - should we do this?  throw; } finally {  runThread = null; }}Cheers,L</Description>
  </Issue>
  <Issue>
    <IssueID>2</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees />
    <Title>Data Driven TestFixture</Title>
    <CreatedDate>19/10/2013</CreatedDate>
    <ClosedDate>20/07/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:done</Name>
        <IssueID>2</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>is:feature</Name>
        <IssueID>2</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
      <IssueLabel>
        <Name>pri:high</Name>
        <IssueID>2</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>I have hierarchy like data-driven test cases that’s 3 levels deep.Currently the TestFixture can only be instantiated only a constantnumber of times. How can I parameterize the TestFixture based onsource input, same like the TestCaseSource attribute?More info at </Description>
  </Issue>
  <Issue>
    <IssueID>1</IssueID>
    <RepoID>nunitWebScrap</RepoID>
    <IssueAssignees>
      <IssueAssignee>
        <FixedById>rprouse</FixedById>
        <IssueID>1</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueAssignee>
    </IssueAssignees>
    <Title>Add Monotouch build</Title>
    <CreatedDate>19/10/2013</CreatedDate>
    <ClosedDate>03/09/2015</ClosedDate>
    <IssueLabels>
      <IssueLabel>
        <Name>closed:duplicate</Name>
        <IssueID>1</IssueID>
        <RepoID>nunitWebScrap</RepoID>
      </IssueLabel>
    </IssueLabels>
    <Description>Build NUnitLite using the monotouch profile. This requires a Mac.From </Description>
  </Issue>
</Issues>